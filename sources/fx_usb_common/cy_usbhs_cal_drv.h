/***************************************************************************//**
* \file cy_usbhs_cal_drv.h
* \version 1.0
*
* Defines the interfaces of the USBHS block driver.
*
*******************************************************************************
* \copyright
* (c) (2024), Cypress Semiconductor Corporation (an Infineon company) or
* an affiliate of Cypress Semiconductor Corporation.
*
* SPDX-License-Identifier: Apache-2.0
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*     http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*******************************************************************************/

/**
 * \addtogroup group_usbfxstack_usb_common
 * \{
 */

/**
 * \addtogroup group_usbfxstack_usb_common_macros
 * \{
 */

#if !defined(CY_USBHS_CAL_DRV_H)

/** Indicates the use of cy_usbd_cal_drv */
#define CY_USBHS_CAL_DRV_H

#include <stdbool.h>

#if defined(__cplusplus)
extern "C" {
#endif

#define CY_USBHS_PLL_LOCK_TIMEOUT_MS (10)               /**< Time to wait for PLL lock in ms */
#define CY_EXTERNAL_CLK_PIN          (P5_1_PIN)         /**< Pin on which external clock is connected.
                                                             XTALIN: P5_0_PIN, XTALOUT: P5_1_PIN. */

/** \} group_usbfxstack_usb_common_macros */

/**
 * \addtogroup group_usbfxstack_usb_common_enums
 * \{
 */

/**
 * @typedef cy_en_usb2_ref_clk_src_t
 * @brief Enumeration of possible clock sources for USB2 PLL REFCLK
 */
typedef enum cy_en_usb2_ref_clk_src_t
{
    USB2REF_CLK_SRC_ECO     = 0x00,                     /**< Clock generated by External Crystal Oscillator (ECO) */
    USB2REF_CLK_SRC_EXT_CLK = 0x01,                     /**< External clock input. */
    USB2REF_CLK_SRC_NA      = 0xFF                      /**< Invalid value */
} cy_en_usb2_ref_clk_src_t;

/** \} group_usbfxstack_usb_common_enums */

/**
 * \addtogroup group_usbfxstack_usb_common_macros
 * \{
 */

/**
 * Duration for which remote wake signal should be driven in the LPM-L1 state.
 * 1500 cycles at 30 MHz = 50 us.
 */
#define USBHSDEV_LPM_L1_WAKE_DURATION   (0x05DCUL)

/**
 * Duration for which remote wake signal should be driven in the L2 (Suspend) state.
 * 210000 cycles at 30 MHz = 7 ms.
 */
#define USBHSDEV_LPM_L2_WAKE_DURATION   (0x33450UL)

/** Control bit to be set in LEGACY_FEATURE_EN register to reduce round trip latency. */
#define USBHSDEV_LEGFEAT_BYPASS_FLOP_EN (0x0008UL)

/** \} group_usbfxstack_usb_common_macros */

/**
 * \addtogroup group_usbfxstack_usb_common_enums
 * \{
 */

/**
 * @typedef cy_en_usbhs_cal_test_mode_t
 * @brief List of USB 2.x electrical test modes.
 */
typedef enum {
    CY_USBHS_CAL_TEST_MODE_NORMAL=0,                    /**< No test mode. */
    CY_USBHS_CAL_TEST_MODE_TEST_J,                      /**< TEST_J mode. */
    CY_USBHS_CAL_TEST_MODE_TEST_K,                      /**< TEST_K mode. */
    CY_USBHS_CAL_TEST_MODE_TEST_SE0_NAK,                /**< TEST_SE0_NAK mode. */
    CY_USBHS_CAL_TEST_MODE_TEST_PACKET,                 /**< TEST_Packet mode. */
    CY_USBHS_CAL_TEST_MODE_TEST_RESERVED                /**< Invalid test selection. */
}cy_en_usbhs_cal_test_mode_t;

/** \} group_usbfxstack_usb_common_enums */

/**
 * \addtogroup group_usbfxstack_usb_common_structs
 * \{
 */

/**
 * @brief Context structure which holds all information about the USBHS
 * controller abstraction layer or driver.
 */
typedef struct cy_stc_usb_cal_ctxt_t
{
    USBHSDEV_Type  *pCalBase;                   /**< Pointer to the USBHSDEV control registers. */
    USBHSPHY_Type  *pPhyBase;                   /**< Pointer to the USBHSPHY control registers. */
    void *pUsbdCtxt;                            /**< Pointer to the USBD stack context structure.
                                                     Used for sending interrupt callbacks only. */
    void *queueCtxt;                            /**< Message queue context pointer: Not used. */
    cy_usb_cal_msg_callback_t msgCb;            /**< Callback function pointer used to notify the USBD stack. */
    cy_en_usb2_ref_clk_src_t clkSrcType;        /**< Clock source type - ECO or external clock */
}cy_stc_usb_cal_ctxt_t;

/*
 * List of API provided by CAL layer. While calling API, USBD layer has to pass
 * cal_ctxt alongwith other para meters.
 */

/** \} group_usbfxstack_usb_common_structs */

/**
 * \addtogroup group_usbfxstack_usb_common_functions
 * \{
 */

/*******************************************************************************
* Function name: Cy_USBHS_Cal_Init
****************************************************************************//**
*
* Initializes the HS controller ie CAL layer and PHY. It also stores callback
* function and USBD layer context.
*
* \param pCalCtxt
* CAL layer context pointer.
*
* \param pUsbdCtxt
* USBd layer context pointer.
*
* \param callBackFunc
* Callback function provied by Upper layer ie USBD layer.
*
*******************************************************************************/
void Cy_USBHS_Cal_Init(cy_stc_usb_cal_ctxt_t *pCalCtxt,
                       void *pUsbdCtxt,
                       cy_usb_cal_msg_callback_t callBackFunc);

/*******************************************************************************
* Function name: Cy_USBHS_Cal_FsHsModePhyInit
****************************************************************************//**
*
* Initializes high speed PHY.
*
* \param pCalCtxt
* CAL layer context pointer.
*
*******************************************************************************/
void Cy_USBHS_Cal_FsHsModePhyInit(cy_stc_usb_cal_ctxt_t *pCalCtxt);

/*******************************************************************************
* Function name: Cy_USBHS_Cal_PhyCommonInit
****************************************************************************//**
*
* Initializes registers common to full and high speed PHY configuration.
*
* \param pCalCtxt
* CAL layer context pointer.
*
*******************************************************************************/
void Cy_USBHS_Cal_PhyCommonInit(cy_stc_usb_cal_ctxt_t *pCalCtxt);

/*******************************************************************************
* Function name: Cy_USBHS_Cal_HandleReset
****************************************************************************//**
*
* During reset controller updates.
*
* \param pCalCtxt
* CAL layer context pointer.
*
* \return
* CY_USB_CAL_STATUS_SUCCESS if the operation is successful.
* CY_USB_CAL_STATUS_CAL_BASE_NULL if register base pointer is NULL.
*
*******************************************************************************/
cy_en_usb_cal_ret_code_t Cy_USBHS_Cal_HandleReset (cy_stc_usb_cal_ctxt_t *pCalCtxt);

/*******************************************************************************
* Function name: Cy_USBHS_Cal_ConnUsbPins
****************************************************************************//**
*
* Update USB device controller register to make USB device visible on Bus. Once
* device is visible, host will start reset and Enumeration.
*
* \param pCalCtxt
* CAL layer context pointer.
*
* \return
* CY_USB_CAL_STATUS_SUCCESS if the operation is successful.
* CY_USB_CAL_STATUS_CAL_BASE_NULL if register base pointer is NULL.
*
*******************************************************************************/
cy_en_usb_cal_ret_code_t Cy_USBHS_Cal_ConnUsbPins(cy_stc_usb_cal_ctxt_t *pCalCtxt);

/*******************************************************************************
* Function name: Cy_USBHS_Cal_DisconUsbPins
****************************************************************************//**
*
* Update Controller register to make USB device invisible on Bus.
*
* \param pCalCtxt
* CAL layer context pointer.
*
* \return
* CY_USB_CAL_STATUS_SUCCESS if the operation is successful.
* CY_USB_CAL_STATUS_CAL_BASE_NULL if register base pointer is NULL.
*
*******************************************************************************/
cy_en_usb_cal_ret_code_t Cy_USBHS_Cal_DisconUsbPins(cy_stc_usb_cal_ctxt_t *pCalCtxt);

/* LPM Related Functions  */
/*******************************************************************************
* Function name: Cy_USBHS_Cal_HsHandleL1Sleep
****************************************************************************//**
*
* L1-SLEEP request during device in high speed mode will be handled here.
*
* \param pCalCtxt
* CAL layer context pointer.
*
*******************************************************************************/
void Cy_USBHS_Cal_HsHandleL1Sleep(cy_stc_usb_cal_ctxt_t *pCalCtxt);

/*******************************************************************************
* Function name: Cy_USBHS_Cal_HsHandleL1WakeupCommon
****************************************************************************//**
*
* L1-Wakeup request during device in high speed mode will be handled here.
*
* \param pCalCtxt
* CAL layer context pointer.
*
*******************************************************************************/
void Cy_USBHS_Cal_HsHandleL1WakeupCommon(cy_stc_usb_cal_ctxt_t *pCalCtxt);


/*******************************************************************************
* Function name: Cy_USBHS_Cal_DevInitiatedL1Exit
****************************************************************************//**
*
* Function helps device to initiate resume from L1 SleepDevice.
*
* \param pCalCtxt
* CAL layer context pointer.
*
* \param duration
* LPM timing parameter as per Specification.
*
*******************************************************************************/
void Cy_USBHS_Cal_DevInitiatedL1Exit(cy_stc_usb_cal_ctxt_t *pCalCtxt,
                                     uint32_t duration);

/*******************************************************************************
* Function name: Cy_USBHS_Cal_DevInitiatedResumeL2Sleep
****************************************************************************//**
*
* Function helps device to initiate resume from L2 SleepDevice.
*
* \param pCalCtxt
* CAL layer context pointer.
*
* \param duration
* LPM timing parameter as per Specification.
*
*******************************************************************************/
void Cy_USBHS_Cal_DevInitiatedResumeL2Sleep(cy_stc_usb_cal_ctxt_t *pCalCtxt,
                                            uint32_t duration);

/*******************************************************************************
* Function name: Cy_USBHS_Cal_HsHandleL2SuspendEntry
****************************************************************************//**
*
* This function Handles Suspend at CAL layer in High speed mode.
*
* \param pCalCtxt
* CAL layer context pointer.
*
* \param keepPllOn
* Whether to keep the PLL and references in the PHY ON.
*
*******************************************************************************/
void Cy_USBHS_Cal_HsHandleL2SuspendEntry(cy_stc_usb_cal_ctxt_t *pCalCtxt,
                                         bool keepPllOn);

/*******************************************************************************
* Function name: Cy_USBHS_Cal_FsHandleSuspend
****************************************************************************//**
*
* This function Handles Suspend at CAL layer in Full speed mode.
*
* \param pCalCtxt
* CAL layer context pointer.
*
*******************************************************************************/
void Cy_USBHS_Cal_FsHandleSuspend(cy_stc_usb_cal_ctxt_t *pCalCtxt);

/*******************************************************************************
* Function name: Cy_USBHS_Cal_HsHandleL2ResumePhySeq
****************************************************************************//**
*
* This function Handles resume at CAL layer in high speed mode.
*
* \param pCalCtxt
* CAL layer context pointer.
*
*******************************************************************************/
void Cy_USBHS_Cal_HsHandleL2Resume (cy_stc_usb_cal_ctxt_t *pCalCtxt);

/*******************************************************************************
* Function name: Cy_USBHS_Cal_FsHandleResume
****************************************************************************//**
*
* This function Handles resume at CAL layer in full speed mode.
*
* \param pCalCtxt
* CAL layer context pointer.
*
*******************************************************************************/
void Cy_USBHS_Cal_FsHandleResume(cy_stc_usb_cal_ctxt_t *pCalCtxt);

/*******************************************************************************
* Function name: Cy_USBHS_Cal_IntrHandler
****************************************************************************//**
*
* This function Handles All interrupt related to controller. Based on interrupt
* required function will be invoked.
*
* \param pCalCtxt
* CAL layer context pointer.
*
* \return
* true if yield is pending when the ISR returns, false otherwise.
*
*******************************************************************************/
bool Cy_USBHS_Cal_IntrHandler (cy_stc_usb_cal_ctxt_t  *pCalCtxt);

/*******************************************************************************
* Function name: Cy_USBHS_Cal_EnableReqDevCtrlIntr
****************************************************************************//**
*
* This function will enable required interrupt under device ctrl reister.
*
* \param pCalCtxt
* CAL layer context pointer.
*
* \return
* CY_USB_CAL_STATUS_SUCCESS if the operation is successful.
* CY_USB_CAL_STATUS_CAL_BASE_NULL if register base pointer is NULL.
*
*******************************************************************************/
cy_en_usb_cal_ret_code_t Cy_USBHS_Cal_EnableReqDevCtrlIntr
                                             (cy_stc_usb_cal_ctxt_t *pCalCtxt);

/*******************************************************************************
* Function name: Cy_USBHS_Cal_DisableAllDevCtrlIntr
****************************************************************************//**
*
* This function will disable all possible interrupt generated by USB device.
*
* \param pCalCtxt
* CAL layer context pointer.
*
* \return
* CY_USB_CAL_STATUS_SUCCESS if the operation is successful.
* CY_USB_CAL_STATUS_CAL_BASE_NULL if register base pointer is NULL.
*
*******************************************************************************/
cy_en_usb_cal_ret_code_t Cy_USBHS_Cal_DisableAllDevCtrlIntr
                                             (cy_stc_usb_cal_ctxt_t *pCalCtxt);

/*******************************************************************************
* Function name: Cy_USBHS_Cal_ClearAllDevCtrlIntr
****************************************************************************//**
*
* This function will clear all interrupt bit in device ctrl register.
*
* \param pCalCtxt
* CAL layer context pointer.
*
* \return
* CY_USB_CAL_STATUS_SUCCESS if the operation is successful.
* CY_USB_CAL_STATUS_CAL_BASE_NULL if register base pointer is NULL.
*
*******************************************************************************/
cy_en_usb_cal_ret_code_t Cy_USBHS_Cal_ClearAllDevCtrlIntr
                                             (cy_stc_usb_cal_ctxt_t *pCalCtxt);

/*******************************************************************************
* Function name: Cy_USBHS_Cal_UpdateEpIntrMask
****************************************************************************//**
*
* This function updates the interrupt mask for an endpoint with the desired values.
*
* \param pCalCtxt
* CAL layer context pointer.
*
* \param endpNumber
* Endpoint number.
*
* \param endpDirection
* Endpoint direction.
*
* \param epIntrMask
* Endpoint interrupt mask.
*
* \param setClear
* Interrupt Mask bits to be set or cleared.
*
* \return
* CY_USB_CAL_STATUS_SUCCESS if the operation is successful.
* CY_USB_CAL_STATUS_CAL_BASE_NULL if register base pointer is NULL.
*
*******************************************************************************/
cy_en_usb_cal_ret_code_t Cy_USBHS_Cal_UpdateEpIntrMask
                                (cy_stc_usb_cal_ctxt_t *pCalCtxt,
                                 uint32_t endpNumber,
                                 cy_en_usb_endp_dir_t endpDirection,
                                 uint32_t epIntrMask,
                                 bool setClear);

/*******************************************************************************
* Function name: Cy_USBHS_Cal_ClearZlpSlpIntrEnableMask
****************************************************************************//**
*
* This function clears endpoint interrupt for ingress and egress intrrupt and
* enables respective mask register. Writing 1 in intr register will clear the
* interrupt. writting 1 in mask register will enable that register.
*
* \param pCalCtxt
* CAL layer context pointer.
*
* \param endpNum
* Endpoint number.
*
* \param endpDir
* Endpoint direction.
*
* \param zlpSlp
* 1 for ZLP and 0 for SLP.
*
* \return
* CY_USB_CAL_STATUS_SUCCESS if the operation is successful.
* CY_USB_CAL_STATUS_CAL_BASE_NULL if register base pointer is NULL.
*
*******************************************************************************/
cy_en_usb_cal_ret_code_t Cy_USBHS_Cal_ClearZlpSlpIntrEnableMask
                                           (cy_stc_usb_cal_ctxt_t *pCalCtxt,
                                            uint32_t endpNum,
                                            cy_en_usb_endp_dir_t endpDir,
                                            bool zlpSlp);

/*******************************************************************************
* Function name: Cy_USBHS_Cal_EnableCtrlSlpIntr
****************************************************************************//**
*
* This function enables the SLP_RCVD interrupt for EP0-OUT.
*
* \param pCalCtxt
* CAL layer context pointer.
*
* \return
* CY_USB_CAL_STATUS_SUCCESS if the operation is successful.
* CY_USB_CAL_STATUS_CAL_BASE_NULL if register base pointer is NULL.
*
*******************************************************************************/
cy_en_usb_cal_ret_code_t Cy_USBHS_Cal_EnableCtrlSlpIntr(cy_stc_usb_cal_ctxt_t *pCalCtxt);

/*******************************************************************************
* Function name: Cy_USBHS_Cal_DisableCtrlSlpIntr
****************************************************************************//**
*
*  This function disable the SLP_RCVD interrupt for EP0-OUT.
*
* \param pCalCtxt
* CAL layer context pointer.
*
* \return
* CY_USB_CAL_STATUS_SUCCESS if the operation is successful.
* CY_USB_CAL_STATUS_CAL_BASE_NULL if register base pointer is NULL.
*
*******************************************************************************/
cy_en_usb_cal_ret_code_t Cy_USBHS_Cal_DisableCtrlSlpIntr(cy_stc_usb_cal_ctxt_t *pCalCtxt);

/*******************************************************************************
* Function name: Cy_USBHS_Cal_EnableEndp
****************************************************************************//**
*
* This function enables/disable endpoint and set/reset respective interrupt.
*
* \param pCalCtxt
* CAL layer context pointer.
*
* \param endpNum
* Endpoint number.
*
* \param endpDir
* Endpoint direction.
*
* \param enable
* 1 for enable and 0 for disable.
*
* \return
* CY_USB_CAL_STATUS_SUCCESS if the operation is successful.
* CY_USB_CAL_STATUS_BAD_PARAM if direction and endpoint number invalid.
* CY_USB_CAL_STATUS_CAL_BASE_NULL if register base pointer is NULL.
*
*******************************************************************************/
cy_en_usb_cal_ret_code_t Cy_USBHS_Cal_EnableEndp
                                            (cy_stc_usb_cal_ctxt_t *pCalCtxt,
                                             uint32_t endpNum,
                                             cy_en_usb_endp_dir_t endpDir,
                                             bool enable);

/*******************************************************************************
* Function name: Cy_USBHS_Cal_EndpConfig
****************************************************************************//**
*
* This function handles configuration of endpoint.
*
* \param pCalCtxt
* CAL layer context pointer.
*
* \param configParam
* Contains all config parameters.
*
* \return
* CY_USB_CAL_STATUS_SUCCESS if the operation is successful.
* CY_USB_CAL_STATUS_BAD_PARAM if direction and endpoint number invalid.
* CY_USB_CAL_STATUS_CAL_BASE_NULL if register base pointer is NULL.
*
*******************************************************************************/
cy_en_usb_cal_ret_code_t Cy_USBHS_Cal_EndpConfig
                                        (cy_stc_usb_cal_ctxt_t *pCalCtxt,
                                         cy_stc_usb_endp_config_t configParam);

/*******************************************************************************
* Function name: Cy_USBHS_Cal_UpdateXferCount
****************************************************************************//**
*
* This function updates register with transfer count.
*
* \param pCalCtxt
* CAL layer context pointer.
*
* \param endpNum
* Endpoint number.
*
* \param endpDir
* Endpoint direction.
*
* \param xferCount
* transfer count.
*
* \return
* CY_USB_CAL_STATUS_SUCCESS if the operation is successful.
* CY_USB_CAL_STATUS_BAD_PARAM if direction and endpoint number invalid.
* CY_USB_CAL_STATUS_CAL_BASE_NULL if register base pointer is NULL.
*
*******************************************************************************/
cy_en_usb_cal_ret_code_t Cy_USBHS_Cal_UpdateXferCount
                                           (cy_stc_usb_cal_ctxt_t *pCalCtxt,
                                            uint32_t endpNum,
                                            cy_en_usb_endp_dir_t endpDir,
                                            uint32_t xferCount);

/*******************************************************************************
* Function name: Cy_USBHS_Cal_EndpSetClearNak
****************************************************************************//**
*
* This function enable or disable NAK condition in hw. By setting NAK bit,
* endpoint will keep sending NAK till NAK bit is cleared.
*
* \param pCalCtxt
* CAL layer context pointer.
*
* \param endpNum
* Endpoint number.
*
* \param endpDir
* Endpoint direction.
*
* \param setClear
* 1 for set and 0 for clear.
*
* \return
* CY_USB_CAL_STATUS_SUCCESS if the operation is successful.
* CY_USB_CAL_STATUS_BAD_PARAM if direction and endpoint number invalid.
* CY_USB_CAL_STATUS_CAL_BASE_NULL if register base pointer is NULL.
*
*******************************************************************************/
cy_en_usb_cal_ret_code_t Cy_USBHS_Cal_EndpSetClearNak
                                              (cy_stc_usb_cal_ctxt_t *pCalCtxt,
                                               uint32_t endpNum,
                                               cy_en_usb_endp_dir_t endpDir,
                                               bool setClear);

/*******************************************************************************
* Function name: Cy_USBHS_Cal_SetClearNakAll
****************************************************************************//**
*
* This function either set or clear NAK for all endpoint.
*
* \param pCalCtxt
* CAL layer context pointer.
*
* \param setClear
* 1 for set and 0 for clear.
*
* \return
* CY_USB_CAL_STATUS_SUCCESS if the operation is successful.
* CY_USB_CAL_STATUS_CAL_BASE_NULL if register base pointer is NULL.
*
*******************************************************************************/
cy_en_usb_cal_ret_code_t Cy_USBHS_Cal_SetClearNakAll
                                              (cy_stc_usb_cal_ctxt_t *pCalCtxt,
                                               bool setClear);

/*******************************************************************************
* Function name: Cy_USBHS_Cal_EndpIsNakNrdySet
****************************************************************************//**
*
* This function checks endpoint's status related to NAK bit is set or reset.
*
* \param pCalCtxt
* CAL layer context pointer.
*
* \param endpNumber
* Endpoint number.
*
* \param endpDirection
* Endpoint direction.
*
* \return
* 1 if NAK bit is set.
* 0 if NAK bit is reset.
*
*******************************************************************************/
bool Cy_USBHS_Cal_EndpIsNakNrdySet(cy_stc_usb_cal_ctxt_t *pCalCtxt,
                                   uint32_t endpNumber,
                                   cy_en_usb_endp_dir_t endpDirection);

/*******************************************************************************
* Function name: Cy_USBHS_Cal_EndpSetClearStall
****************************************************************************//**
*
* This function enable or disable STALL condition in hw.
*
* \param pCalCtxt
* CAL layer context pointer.
*
* \param endpNum
* Endpoint number.
*
* \param endpDir
* Endpoint direction.
*
* \param setClear
* 1 for set and 0 for clear.
*
* \return
* CY_USB_CAL_STATUS_SUCCESS if the operation is successful.
* CY_USB_CAL_STATUS_BAD_PARAM if direction and endpoint number invalid.
* CY_USB_CAL_STATUS_CAL_BASE_NULL if register base pointer is NULL.
*
*******************************************************************************/
cy_en_usb_cal_ret_code_t Cy_USBHS_Cal_EndpSetClearStall
                                    (cy_stc_usb_cal_ctxt_t *pCalCtxt,
                                     uint32_t endpNum,
                                     cy_en_usb_endp_dir_t endpDir,
                                     bool setClear);

/*******************************************************************************
* Function name: Cy_USBHS_Cal_EndpIsStallSet
****************************************************************************//**
*
* This function checks whether the specified endpoint is currently in the STALLed
* state.
*
* \param pCalCtxt
* CAL layer context pointer.
*
* \param endpNum
* Endpoint number.
*
* \param endpDir
* Endpoint direction.
*
* \return
* 1 if NAK bit is set.
* 0 if NAK bit is reset.
*
*******************************************************************************/
bool Cy_USBHS_Cal_EndpIsStallSet(cy_stc_usb_cal_ctxt_t *pCalCtxt,
                                 uint32_t endpNum,
                                 cy_en_usb_endp_dir_t endpDir);

/*******************************************************************************
* Function name: Cy_USBHS_Cal_FlushEndp
****************************************************************************//**
*
* This function will flush data available in perticular endpoint FIFO. High speed
* USB IP supports flush functionality only for IN endpoint.
*
* \param pCalCtxt
* CAL layer context pointer.
*
* \param endpNum
* Endpoint number.
*
* \param endpDir
* Endpoint direction.
*
* \return
* CY_USB_CAL_STATUS_SUCCESS if the operation is successful.
* CY_USB_CAL_STATUS_BAD_PARAM if direction and endpoint number invalid.
* CY_USB_CAL_STATUS_CAL_BASE_NULL if register base pointer is NULL.
*
*******************************************************************************/
cy_en_usb_cal_ret_code_t Cy_USBHS_Cal_FlushEndp
                                          (cy_stc_usb_cal_ctxt_t *pCalCtxt,
                                           uint32_t endpNum,
                                           cy_en_usb_endp_dir_t endpDir);

/*******************************************************************************
* Function name: Cy_USBHS_Cal_FlushAllEndp
****************************************************************************//**
*
* This function will flush data available in all Ingress and egress endpoint FIFO.
*
* \param pCalCtxt
* CAL layer context pointer.
*
* \return
* CY_USB_CAL_STATUS_SUCCESS if the operation is successful.
* CY_USB_CAL_STATUS_CAL_BASE_NULL if register base pointer is NULL.
*
*******************************************************************************/
cy_en_usb_cal_ret_code_t Cy_USBHS_Cal_FlushAllEndp(cy_stc_usb_cal_ctxt_t *pCalCtxt);

/*******************************************************************************
* Function name: Cy_USBHS_Cal_SendEgressZLP
****************************************************************************//**
*
* This function triggers sending of a ZLP on an Egress endpoint.
*
* \param pCalCtxt
* CAL layer context pointer.
*
* \param endpNum
* Endpoint number.
*
* \return
* CY_USB_CAL_STATUS_SUCCESS if the operation is successful.
* CY_USB_CAL_STATUS_BAD_PARAM if direction and endpoint number invalid.
* CY_USB_CAL_STATUS_CAL_BASE_NULL if register base pointer is NULL.
*
*******************************************************************************/
cy_en_usb_cal_ret_code_t Cy_USBHS_Cal_SendEgressZLP
                        (cy_stc_usb_cal_ctxt_t *pCalCtxt, uint32_t endpNum);

/*******************************************************************************
* Function name: Cy_USBHS_Cal_HandleCtrlOutSlp
****************************************************************************//**
*
* This function clears SLP ingress interrupt.
*
* \param pCalCtxt
* CAL layer context pointer.
*
* \return
* CY_USB_CAL_STATUS_SUCCESS if the operation is successful.
* CY_USB_CAL_STATUS_CAL_BASE_NULL if register base pointer is NULL.
*
*******************************************************************************/
cy_en_usb_cal_ret_code_t Cy_USBHS_Cal_HandleCtrlOutSlp(cy_stc_usb_cal_ctxt_t *pCalCtxt);

/*******************************************************************************
* Function name: Cy_USBHS_Cal_CtrlEndp0DataOutAck
****************************************************************************//**
*
* Data stage ACK for endpoint0 is controlled by this function. In USBHS,
* when "CONT_TO_DATA" bit is set then controller wont send ACK till data is
* validated.
*
* \param pCalCtxt
* CAL layer context pointer.
*
*  \param setClear
* 1 for set and 0 for clear.
*
* \return
* CY_USB_CAL_STATUS_SUCCESS if the operation is successful.
* CY_USB_CAL_STATUS_CAL_BASE_NULL if register base pointer is NULL.
*
*******************************************************************************/
cy_en_usb_cal_ret_code_t Cy_USBHS_Cal_CtrlEndp0DataOutAck
                                        (cy_stc_usb_cal_ctxt_t *pCalCtxt,
                                         bool setClear);

/*******************************************************************************
* Function name: Cy_USBHS_Cal_SendAckSetupDataStatusStage
****************************************************************************//**
*
* This function update register so that device will send ACK to complete control
* transfer.
*
* \param pCalCtxt
* CAL layer context pointer.
*
* \return
* CY_USB_CAL_STATUS_SUCCESS if the operation is successful.
* CY_USB_CAL_STATUS_CAL_BASE_NULL if register base pointer is NULL.
*
*******************************************************************************/
cy_en_usb_cal_ret_code_t Cy_USBHS_Cal_SendAckSetupDataStatusStage
                                             (cy_stc_usb_cal_ctxt_t *pCalCtxt);

#ifndef DOXYGEN
#define Cy_USBHS_Cal_SendACkSetupDataStatusStage(pCtxt) Cy_USBHS_Cal_SendAckSetupDataStatusStage(pCtxt)
#endif /* DOXYGEN */


/*******************************************************************************
* Function name: Cy_USBHS_Cal_GetRemoteWakeupStatus
****************************************************************************//**
*
* This function returns status of L2 remote wakeup in HW.
*
* \param pCalCtxt
* CAL layer context pointer.
*
* \return
* true if L2 remote wakeup is enabled.
* false if L2 remote wakeup is disabled.
*
*******************************************************************************/
bool Cy_USBHS_Cal_GetRemoteWakeupStatus(cy_stc_usb_cal_ctxt_t *pCalCtxt);

/*******************************************************************************
* Function name: Cy_USBHS_Cal_GetL1RemoteWakeupStatus
****************************************************************************//**
*
* This function returns status of L1 remote wakeup in HW.
*
* \param pCalCtxt
* CAL layer context pointer.
*
* \return
* true if L1 remote wakeup is enabled.
* false if L1 remote wakeup is disabled.
*
*******************************************************************************/
bool Cy_USBHS_Cal_GetL1RemoteWakeupStatus(cy_stc_usb_cal_ctxt_t *pCalCtxt);

/*******************************************************************************
* Function name: Cy_USBHS_Cal_SignalRemotWakup
****************************************************************************//**
*
* This function will update register so that device will initiate remote wakeup 
* signaling ie it will try to comeout from L2_SUSPEND.
*
* \param pCalCtxt
* CAL layer context pointer.
*
* \param startEndSignal
* Input to tell either start or end signaling.
*
* \return
* CY_USB_CAL_STATUS_SUCCESS if the operation is successful.
* CY_USB_CAL_STATUS_CAL_BASE_NULL if register base pointer is NULL.
*
*******************************************************************************/
cy_en_usb_cal_ret_code_t Cy_USBHS_Cal_SignalRemotWakup
                                              (cy_stc_usb_cal_ctxt_t *pCalCtxt,
                                               bool startEndSignal);


/*******************************************************************************
* Function name: Cy_USBHS_Cal_SetTestMode
****************************************************************************//**
*
* This function will update register to setup required test mode.
*
* \param pCalCtxt
* CAL layer context pointer.
*
* \param testMode
* perticular test mode.
*
* \return
* CY_USB_CAL_STATUS_SUCCESS if the operation is successful.
* CY_USB_CAL_STATUS_CAL_BASE_NULL if register base pointer is NULL.
*
*******************************************************************************/
cy_en_usb_cal_ret_code_t Cy_USBHS_Cal_SetTestMode
                                        (cy_stc_usb_cal_ctxt_t *pCalCtxt,
                                         cy_en_usbhs_cal_test_mode_t testMode);

/*******************************************************************************
* Function name: Cy_USBHS_Cal_LpmSetClearNYET
****************************************************************************//**
*
* This function either set or clear NYET bit for LPM response.
*
* \param pCalCtxt
* CAL layer context pointer.
*
* \param setClear
* 1 for set and 0 for clear.
*
* \return
* CY_USB_CAL_STATUS_SUCCESS if the operation is successful.
* CY_USB_CAL_STATUS_CAL_BASE_NULL if register base pointer is NULL.
*
*******************************************************************************/
cy_en_usb_cal_ret_code_t Cy_USBHS_Cal_LpmSetClearNYET
                              (cy_stc_usb_cal_ctxt_t *pCalCtxt, bool setClear);

/*******************************************************************************
* Function name: Cy_USBHS_Cal_SetControllerSpeed
****************************************************************************//**
*
* This function set controller speed to FS or HS. If explicitly FS is not
* mentioned then function will set speed to HS.
*
* \param pCalCtxt
* CAL layer context pointer.
*
* \param speed
* iether HS or FS.
*
* \return
* CY_USB_CAL_STATUS_SUCCESS if the operation is successful.
* CY_USB_CAL_STATUS_CAL_BASE_NULL if register base pointer is NULL.
*
*******************************************************************************/
cy_en_usb_cal_ret_code_t Cy_USBHS_Cal_SetControllerSpeed
                                              (cy_stc_usb_cal_ctxt_t *pCalCtxt,
                                               cy_en_usb_speed_t speed);

/*******************************************************************************
* Function name: Cy_USBHS_Cal_GetDevAddress
****************************************************************************//**
*
* This function will get device address assigned by Host.
*
* \param pCalCtxt
* CAL layer context pointer.
*
* \param pDevAddr
* Address of device will be stored here.
*
* \return
* CY_USB_CAL_STATUS_SUCCESS if the operation is successful.
* CY_USB_CAL_STATUS_BAD_PARAM if direction and endpoint number invalid.
* CY_USB_CAL_STATUS_CAL_BASE_NULL if register base pointer is NULL.
*
*******************************************************************************/
cy_en_usb_cal_ret_code_t Cy_USBHS_Cal_GetDevAddress
                                            (cy_stc_usb_cal_ctxt_t *pCalCtxt,
                                             uint8_t *pDevAddr);

/*******************************************************************************
* Function name: Cy_USBHS_Cal_GetLinkActive
****************************************************************************//**
*
* This function makes sure that the USB 2.x link gets into the L0 state if it
* is in L1.
*
* \param pCalCtxt
* CAL layer context pointer.
*
* \return
* CY_USB_CAL_STATUS_SUCCESS if the operation is successful.
* CY_USB_CAL_STATUS_CAL_BASE_NULL if register base pointer is NULL.
*
*******************************************************************************/
cy_en_usb_cal_ret_code_t Cy_USBHS_Cal_GetLinkActive
                              (cy_stc_usb_cal_ctxt_t *pCalCtxt);

/*******************************************************************************
* Function name: Cy_USBHS_Cal_SendMsg
****************************************************************************//**
*
* This function send message to upper layer ie USBD layer.
*
* \param pCalCtxt
* CAL layer context pointer.
*
* \param pMsg
* message will be given to upper layer.
*
* \return
* Whether context switch is required at the end of the callback.
*
*******************************************************************************/
bool
Cy_USBHS_Cal_SendMsg(cy_stc_usb_cal_ctxt_t *pCalCtxt, void *pMsg);

/*******************************************************************************
* Function name: Cy_USBHS_Cal_DeinitPLL
****************************************************************************//**
*
* Function to de-initialize the PLL in the USBHS block.
*
* \param pCalCtxt
* CAL layer context pointer.
*
* \return
* CY_USB_CAL_STATUS_SUCCESS in case of success; error code otherwise.
*
*******************************************************************************/
cy_en_usb_cal_ret_code_t
Cy_USBHS_Cal_DeinitPLL(cy_stc_usb_cal_ctxt_t *pCalCtxt);

/*******************************************************************************
* Function name: Cy_USBHS_Cal_InitPLL
****************************************************************************//**
*
* Function to initialize the PLL in the USBHS block to generate the 480 MHz
* clock required by the High BandWidth SubSystem for its operation.
*
* \param pCalCtxt
* CAL layer context pointer.
*
* \return
* CY_USB_CAL_STATUS_SUCCESS in case of success; error code otherwise.
*
*******************************************************************************/
cy_en_usb_cal_ret_code_t
Cy_USBHS_Cal_InitPLL(cy_stc_usb_cal_ctxt_t *pCalCtxt);

/*******************************************************************************
* Function name: Cy_USBHS_Cal_IsLinkActive
****************************************************************************//**
*
* Check whether the USB 2.x link is in active (L0) state.
*
* \param pCalCtxt
* CAL layer context pointer.
*
* \return
* true if link is in L0, false if link is in L1 or L2.
*******************************************************************************/
bool Cy_USBHS_Cal_IsLinkActive(cy_stc_usb_cal_ctxt_t *pCalCtxt);

/*******************************************************************************
* Function name: Cy_USBHS_Cal_GetXferCount
****************************************************************************//**
*
* Retrieve the remaining transfer count on the specified endpoint.
*
* \param pCalCtxt
* CAL layer context pointer.
*
* \param endpNum
* Endpoint number.
*
* \param endpDir
* Endpoint direction.
*
* \param pCntPending
* Return parameter through which pending count is returned.
*
* \return
* CY_USB_CAL_STATUS_SUCCESS if the operation is successful.
* CY_USB_CAL_STATUS_BAD_PARAM if direction and endpoint number invalid.
* CY_USB_CAL_STATUS_CAL_BASE_NULL if register base pointer is NULL.
*
*******************************************************************************/
cy_en_usb_cal_ret_code_t
Cy_USBHS_Cal_GetXferCount(cy_stc_usb_cal_ctxt_t *pCalCtxt,
                          uint32_t endpNum,
                          cy_en_usb_endp_dir_t endpDir,
                          uint32_t *pCntPending);

/** \} group_usbfxstack_usb_common_functions */

#if defined(__cplusplus)
}
#endif

#endif /* (!defined(CY_USBHS_CAL_DRV_H)) */

/** \} group_usbfxstack_usb_common */

/* EOF */

