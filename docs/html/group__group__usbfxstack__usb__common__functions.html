<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ModusToolbox USBFXStack</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen_style.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><a href="http://www.cypress.com/"><img alt="Logo" src="logo.png"/></a></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">ModusToolbox USBFXStack</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('group__group__usbfxstack__usb__common__functions.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">Functions<div class="ingroups"><a class="el" href="group__group__usbfxstack__usb__common.html">FX USB common</a></div></div></div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">General Description</h2>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga24e3cac8dbacb620555a0964b7dc23a9"><td class="memItemLeft" align="right" valign="top">static uint32_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__usb__common__functions.html#ga24e3cac8dbacb620555a0964b7dc23a9">Cy_USBHS_CalculateEpmAddr</a> (uint32_t endpNum, <a class="el" href="group__group__usbfxstack__usb__common__enums.html#gaaebdfe5d46401ad52420b00ca401e6f8">cy_en_usb_endp_dir_t</a> endpDirection)</td></tr>
<tr class="memdesc:ga24e3cac8dbacb620555a0964b7dc23a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the base address of the Endpoint Memory region corresponding to a USBHSDEV endpoint.  <a href="group__group__usbfxstack__usb__common__functions.html#ga24e3cac8dbacb620555a0964b7dc23a9">More...</a><br /></td></tr>
<tr class="separator:ga24e3cac8dbacb620555a0964b7dc23a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0938c4349056963283a568dad3864e9d"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__usb__common__functions.html#ga0938c4349056963283a568dad3864e9d">Cy_USBD_GetVersion</a> (void)</td></tr>
<tr class="memdesc:ga0938c4349056963283a568dad3864e9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the USBD middleware version information.  <a href="group__group__usbfxstack__usb__common__functions.html#ga0938c4349056963283a568dad3864e9d">More...</a><br /></td></tr>
<tr class="separator:ga0938c4349056963283a568dad3864e9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga153dcd5f7d32f548cb7f1d2e54740ba7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#gae84a77ef84aee90fcb7773ad13acab34">cy_en_usbd_ret_code_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__usb__common__functions.html#ga153dcd5f7d32f548cb7f1d2e54740ba7">Cy_USB_USBD_Init</a> (void *pAppCtxt, <a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__usbd__ctxt__t">cy_stc_usb_usbd_ctxt_t</a> *pUsbdCtxt, DMAC_Type *pCpuDmacBase, <a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__cal__ctxt__t">cy_stc_usb_cal_ctxt_t</a> *pCalCtxt, <a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usbss__cal__ctxt__t">cy_stc_usbss_cal_ctxt_t</a> *pSsCalCtxt, <a class="el" href="group__group__usbfxstack__hb__dma__structs.html#structcy__stc__hbdma__mgr__context__t">cy_stc_hbdma_mgr_context_t</a> *pHbDmaMgrCtxt)</td></tr>
<tr class="memdesc:ga153dcd5f7d32f548cb7f1d2e54740ba7"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function initializes USBD layer and activates CAL layer initialization function for SS and HS controller.  <a href="group__group__usbfxstack__usb__common__functions.html#ga153dcd5f7d32f548cb7f1d2e54740ba7">More...</a><br /></td></tr>
<tr class="separator:ga153dcd5f7d32f548cb7f1d2e54740ba7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabeff2fa14eb96a51603827d920574b52"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#gae84a77ef84aee90fcb7773ad13acab34">cy_en_usbd_ret_code_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__usb__common__functions.html#gabeff2fa14eb96a51603827d920574b52">Cy_USBD_RegisterCallback</a> (<a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__usbd__ctxt__t">cy_stc_usb_usbd_ctxt_t</a> *pUsbdCtxt, <a class="el" href="group__group__usbfxstack__usb__common__enums.html#ga1d336f8c870e093b9296a003c7ead9ad">cy_en_usb_usbd_cb_t</a> callBackType, <a class="el" href="group__group__usbfxstack__usb__common__typedefs.html#gaf2703fc2b5baa958deb275bf19852376">cy_usb_usbd_callback_t</a> callBackFunc)</td></tr>
<tr class="memdesc:gabeff2fa14eb96a51603827d920574b52"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API will be used by application to register required callback.  <a href="group__group__usbfxstack__usb__common__functions.html#gabeff2fa14eb96a51603827d920574b52">More...</a><br /></td></tr>
<tr class="separator:gabeff2fa14eb96a51603827d920574b52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7b659598cdbee7177c9324c72cefa73c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#gae84a77ef84aee90fcb7773ad13acab34">cy_en_usbd_ret_code_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__usb__common__functions.html#ga7b659598cdbee7177c9324c72cefa73c">Cy_USBD_SetDscr</a> (<a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__usbd__ctxt__t">cy_stc_usb_usbd_ctxt_t</a> *pUsbdCtxt, <a class="el" href="group__group__usbfxstack__usb__common__enums.html#gac1532edf4b09382d66f09dc7849aacd1">cy_en_usb_set_dscr_type_t</a> dscrType, uint8_t dscrIndex, uint8_t *pDscr)</td></tr>
<tr class="memdesc:ga7b659598cdbee7177c9324c72cefa73c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API will be used by application to provide various standard descriptors to USBD layer and USBD layer will use this descriptor in "fast enumeration".  <a href="group__group__usbfxstack__usb__common__functions.html#ga7b659598cdbee7177c9324c72cefa73c">More...</a><br /></td></tr>
<tr class="separator:ga7b659598cdbee7177c9324c72cefa73c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3612f6d61611a49d62c68bb9f1c52de0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#ga0355d30a754a1ef18fec29f288f59880">cy_en_usb_speed_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__usb__common__functions.html#ga3612f6d61611a49d62c68bb9f1c52de0">Cy_USBD_GetDeviceSpeed</a> (<a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__usbd__ctxt__t">cy_stc_usb_usbd_ctxt_t</a> *pUsbdCtxt)</td></tr>
<tr class="memdesc:ga3612f6d61611a49d62c68bb9f1c52de0"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API returns device's operating speed.  <a href="group__group__usbfxstack__usb__common__functions.html#ga3612f6d61611a49d62c68bb9f1c52de0">More...</a><br /></td></tr>
<tr class="separator:ga3612f6d61611a49d62c68bb9f1c52de0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac02ea1c6c587c0d885652a276fa59797"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__usb__common__functions.html#gac02ea1c6c587c0d885652a276fa59797">Cy_USBD_SetDeviceSpeed</a> (<a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__usbd__ctxt__t">cy_stc_usb_usbd_ctxt_t</a> *pUsbdCtxt, <a class="el" href="group__group__usbfxstack__usb__common__enums.html#ga0355d30a754a1ef18fec29f288f59880">cy_en_usb_speed_t</a> speed)</td></tr>
<tr class="memdesc:gac02ea1c6c587c0d885652a276fa59797"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API force operating speed of dvice.  <a href="group__group__usbfxstack__usb__common__functions.html#gac02ea1c6c587c0d885652a276fa59797">More...</a><br /></td></tr>
<tr class="separator:gac02ea1c6c587c0d885652a276fa59797"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac752cde7aa85499f41d4cda76a1882dd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__usb__common__functions.html#gac752cde7aa85499f41d4cda76a1882dd">Cy_USBD_SetDeviceSpeedAtUSBDOnly</a> (<a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__usbd__ctxt__t">cy_stc_usb_usbd_ctxt_t</a> *pUsbdCtxt, <a class="el" href="group__group__usbfxstack__usb__common__enums.html#ga0355d30a754a1ef18fec29f288f59880">cy_en_usb_speed_t</a> speed)</td></tr>
<tr class="memdesc:gac752cde7aa85499f41d4cda76a1882dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API is used to set device speed only at USBD layer.  <a href="group__group__usbfxstack__usb__common__functions.html#gac752cde7aa85499f41d4cda76a1882dd">More...</a><br /></td></tr>
<tr class="separator:gac752cde7aa85499f41d4cda76a1882dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga86dc8e2881413befb5eb131a7ad8da36"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#ga371db4682d00725909b7eb8edc0f7767">cy_en_usb_device_state_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__usb__common__functions.html#ga86dc8e2881413befb5eb131a7ad8da36">Cy_USBD_GetDeviceState</a> (<a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__usbd__ctxt__t">cy_stc_usb_usbd_ctxt_t</a> *pUsbdCtxt)</td></tr>
<tr class="memdesc:ga86dc8e2881413befb5eb131a7ad8da36"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API returns present state of device.  <a href="group__group__usbfxstack__usb__common__functions.html#ga86dc8e2881413befb5eb131a7ad8da36">More...</a><br /></td></tr>
<tr class="separator:ga86dc8e2881413befb5eb131a7ad8da36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6dbf88f3739d33ecd6a2e754bb6649a3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#gae84a77ef84aee90fcb7773ad13acab34">cy_en_usbd_ret_code_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__usb__common__functions.html#ga6dbf88f3739d33ecd6a2e754bb6649a3">Cy_USBD_FindEndp0MaxPktSize</a> (uint8_t *pDevDscr, <a class="el" href="group__group__usbfxstack__usb__common__enums.html#ga0355d30a754a1ef18fec29f288f59880">cy_en_usb_speed_t</a> devSpeed, uint32_t *pMaxPktSize)</td></tr>
<tr class="memdesc:ga6dbf88f3739d33ecd6a2e754bb6649a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API finds endpoint 0 max packet size from device descriptor.  <a href="group__group__usbfxstack__usb__common__functions.html#ga6dbf88f3739d33ecd6a2e754bb6649a3">More...</a><br /></td></tr>
<tr class="separator:ga6dbf88f3739d33ecd6a2e754bb6649a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga56166c586e0944a1f4a305c7b6bcc49c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#gae84a77ef84aee90fcb7773ad13acab34">cy_en_usbd_ret_code_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__usb__common__functions.html#ga56166c586e0944a1f4a305c7b6bcc49c">Cy_USBD_GetLpmBosUSBExt</a> (<a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__usbd__ctxt__t">cy_stc_usb_usbd_ctxt_t</a> *pUsbdCtxt, uint8_t *pLpmSupp)</td></tr>
<tr class="memdesc:ga56166c586e0944a1f4a305c7b6bcc49c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get information about LPM support from USB ext descriptor.  <a href="group__group__usbfxstack__usb__common__functions.html#ga56166c586e0944a1f4a305c7b6bcc49c">More...</a><br /></td></tr>
<tr class="separator:ga56166c586e0944a1f4a305c7b6bcc49c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3f98c9e790c257068f472fddf04b2c33"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#gae84a77ef84aee90fcb7773ad13acab34">cy_en_usbd_ret_code_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__usb__common__functions.html#ga3f98c9e790c257068f472fddf04b2c33">Cy_USBD_GetAttributeBosUSBExt</a> (<a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__usbd__ctxt__t">cy_stc_usb_usbd_ctxt_t</a> *pUsbdCtxt, uint32_t *pAttribute)</td></tr>
<tr class="memdesc:ga3f98c9e790c257068f472fddf04b2c33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get attribute from USB ext descriptor.  <a href="group__group__usbfxstack__usb__common__functions.html#ga3f98c9e790c257068f472fddf04b2c33">More...</a><br /></td></tr>
<tr class="separator:ga3f98c9e790c257068f472fddf04b2c33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabbfe7a2b518c1af086452f9672150f52"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#gae84a77ef84aee90fcb7773ad13acab34">cy_en_usbd_ret_code_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__usb__common__functions.html#gabbfe7a2b518c1af086452f9672150f52">Cy_USBD_GetAttributeBosSS</a> (<a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__usbd__ctxt__t">cy_stc_usb_usbd_ctxt_t</a> *pUsbdCtxt, uint8_t *pAttribute)</td></tr>
<tr class="memdesc:gabbfe7a2b518c1af086452f9672150f52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get attribute from Super speed BoS descriptor.  <a href="group__group__usbfxstack__usb__common__functions.html#gabbfe7a2b518c1af086452f9672150f52">More...</a><br /></td></tr>
<tr class="separator:gabbfe7a2b518c1af086452f9672150f52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabc7bf2f49deedf4ead753702ddf49c58"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#gae84a77ef84aee90fcb7773ad13acab34">cy_en_usbd_ret_code_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__usb__common__functions.html#gabc7bf2f49deedf4ead753702ddf49c58">Cy_USBD_GetSpeedSuppBosSS</a> (<a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__usbd__ctxt__t">cy_stc_usb_usbd_ctxt_t</a> *pUsbdCtxt, uint32_t *pSpeedSupp)</td></tr>
<tr class="memdesc:gabc7bf2f49deedf4ead753702ddf49c58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get Speed supported from Super speed descriptor.  <a href="group__group__usbfxstack__usb__common__functions.html#gabc7bf2f49deedf4ead753702ddf49c58">More...</a><br /></td></tr>
<tr class="separator:gabc7bf2f49deedf4ead753702ddf49c58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4b9f2c7fe1f9153344ef7a5adde069a4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#gae84a77ef84aee90fcb7773ad13acab34">cy_en_usbd_ret_code_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__usb__common__functions.html#ga4b9f2c7fe1f9153344ef7a5adde069a4">Cy_USBD_GetU1U2ExitLatBosSS</a> (<a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__usbd__ctxt__t">cy_stc_usb_usbd_ctxt_t</a> *pUsbdCtxt, uint8_t *pU1ExitLat, uint16_t *pU2ExitLat)</td></tr>
<tr class="memdesc:ga4b9f2c7fe1f9153344ef7a5adde069a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get U1 and U2 exit latency from Super speed BoS descriptor.  <a href="group__group__usbfxstack__usb__common__functions.html#ga4b9f2c7fe1f9153344ef7a5adde069a4">More...</a><br /></td></tr>
<tr class="separator:ga4b9f2c7fe1f9153344ef7a5adde069a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9201b4bcf9999d3bb01e137dd648c9d6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#gae84a77ef84aee90fcb7773ad13acab34">cy_en_usbd_ret_code_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__usb__common__functions.html#ga9201b4bcf9999d3bb01e137dd648c9d6">Cy_USBD_GetAttributeBosSSP</a> (<a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__usbd__ctxt__t">cy_stc_usb_usbd_ctxt_t</a> *pUsbdCtxt, uint32_t *pAttribute)</td></tr>
<tr class="memdesc:ga9201b4bcf9999d3bb01e137dd648c9d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get attribute from Super speed plus descriptor.  <a href="group__group__usbfxstack__usb__common__functions.html#ga9201b4bcf9999d3bb01e137dd648c9d6">More...</a><br /></td></tr>
<tr class="separator:ga9201b4bcf9999d3bb01e137dd648c9d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga930c19b3fb60589b8e5cd471c8048a28"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#gae84a77ef84aee90fcb7773ad13acab34">cy_en_usbd_ret_code_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__usb__common__functions.html#ga930c19b3fb60589b8e5cd471c8048a28">Cy_USBD_GetFunctSupportBosSSP</a> (<a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__usbd__ctxt__t">cy_stc_usb_usbd_ctxt_t</a> *pUsbdCtxt, uint32_t *pFuncSupp)</td></tr>
<tr class="memdesc:ga930c19b3fb60589b8e5cd471c8048a28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get functionality supported from Super speed plus descriptor.  <a href="group__group__usbfxstack__usb__common__functions.html#ga930c19b3fb60589b8e5cd471c8048a28">More...</a><br /></td></tr>
<tr class="separator:ga930c19b3fb60589b8e5cd471c8048a28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga593ef17222bff4f6b8d4315b488fdbb5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__usb__common__functions.html#ga593ef17222bff4f6b8d4315b488fdbb5">Cy_USBD_isCfgValid</a> (uint8_t cfgNum, const uint8_t *pCfgDscr)</td></tr>
<tr class="memdesc:ga593ef17222bff4f6b8d4315b488fdbb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function checks validity of given configuration.  <a href="group__group__usbfxstack__usb__common__functions.html#ga593ef17222bff4f6b8d4315b488fdbb5">More...</a><br /></td></tr>
<tr class="separator:ga593ef17222bff4f6b8d4315b488fdbb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae00d4cf55d463b39e38711a24fb0ec41"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#gae84a77ef84aee90fcb7773ad13acab34">cy_en_usbd_ret_code_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__usb__common__functions.html#gae00d4cf55d463b39e38711a24fb0ec41">Cy_USB_USBD_GetActiveCfgNum</a> (<a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__usbd__ctxt__t">cy_stc_usb_usbd_ctxt_t</a> *pUsbdCtxt, uint8_t *pCfgNum)</td></tr>
<tr class="memdesc:gae00d4cf55d463b39e38711a24fb0ec41"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API called by application to know active configuration number.  <a href="group__group__usbfxstack__usb__common__functions.html#gae00d4cf55d463b39e38711a24fb0ec41">More...</a><br /></td></tr>
<tr class="separator:gae00d4cf55d463b39e38711a24fb0ec41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad988c9830f6031995a7186195dda9ffb"><td class="memItemLeft" align="right" valign="top">uint8_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__usb__common__functions.html#gad988c9830f6031995a7186195dda9ffb">Cy_USB_USBD_GetActiveCfgDscr</a> (<a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__usbd__ctxt__t">cy_stc_usb_usbd_ctxt_t</a> *pUsbdCtxt)</td></tr>
<tr class="memdesc:gad988c9830f6031995a7186195dda9ffb"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API called by application to get active configuration descriptor.  <a href="group__group__usbfxstack__usb__common__functions.html#gad988c9830f6031995a7186195dda9ffb">More...</a><br /></td></tr>
<tr class="separator:gad988c9830f6031995a7186195dda9ffb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac502fe8d6a40cf3c4808bf7ba54e6dac"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__usb__common__functions.html#gac502fe8d6a40cf3c4808bf7ba54e6dac">Cy_USBD_FindNumOfIntf</a> (const uint8_t *pCfgDscr)</td></tr>
<tr class="memdesc:gac502fe8d6a40cf3c4808bf7ba54e6dac"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function finds number of interface supported in given configation.  <a href="group__group__usbfxstack__usb__common__functions.html#gac502fe8d6a40cf3c4808bf7ba54e6dac">More...</a><br /></td></tr>
<tr class="separator:gac502fe8d6a40cf3c4808bf7ba54e6dac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaef5256f41663a524a551ef0586b5070a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__usb__common__functions.html#gaef5256f41663a524a551ef0586b5070a">Cy_USBD_FindSelfPower</a> (const uint8_t *pCfgDscr)</td></tr>
<tr class="memdesc:gaef5256f41663a524a551ef0586b5070a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function finds device supports Self power or BUS power.  <a href="group__group__usbfxstack__usb__common__functions.html#gaef5256f41663a524a551ef0586b5070a">More...</a><br /></td></tr>
<tr class="separator:gaef5256f41663a524a551ef0586b5070a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2a55dc757997ab0c846776f59c386a4e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__usb__common__functions.html#ga2a55dc757997ab0c846776f59c386a4e">Cy_USBD_FindRemoteWakeupAbility</a> (uint8_t *pCfgDscr)</td></tr>
<tr class="memdesc:ga2a55dc757997ab0c846776f59c386a4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function finds device supports remote wakeup or not.  <a href="group__group__usbfxstack__usb__common__functions.html#ga2a55dc757997ab0c846776f59c386a4e">More...</a><br /></td></tr>
<tr class="separator:ga2a55dc757997ab0c846776f59c386a4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2160e5a9cddb1b4eb4a7191e57e8e59a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__usb__common__functions.html#ga2160e5a9cddb1b4eb4a7191e57e8e59a">Cy_USBD_GetRemoteWakeupStatus</a> (<a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__usbd__ctxt__t">cy_stc_usb_usbd_ctxt_t</a> *pUsbdCtxt)</td></tr>
<tr class="memdesc:ga2160e5a9cddb1b4eb4a7191e57e8e59a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function checks L2 remote wakeup status and return information.  <a href="group__group__usbfxstack__usb__common__functions.html#ga2160e5a9cddb1b4eb4a7191e57e8e59a">More...</a><br /></td></tr>
<tr class="separator:ga2160e5a9cddb1b4eb4a7191e57e8e59a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4991ac9c1d2f156fbfa00aec50e1711f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__usb__common__functions.html#ga4991ac9c1d2f156fbfa00aec50e1711f">Cy_USBD_SignalRemoteWakeup</a> (<a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__usbd__ctxt__t">cy_stc_usb_usbd_ctxt_t</a> *pUsbdCtxt, bool startEnd)</td></tr>
<tr class="memdesc:ga4991ac9c1d2f156fbfa00aec50e1711f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function triggers HW to start/end remotewakeup signaling.  <a href="group__group__usbfxstack__usb__common__functions.html#ga4991ac9c1d2f156fbfa00aec50e1711f">More...</a><br /></td></tr>
<tr class="separator:ga4991ac9c1d2f156fbfa00aec50e1711f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga90da5cda2e1aa5ef41fba534270a8dad"><td class="memItemLeft" align="right" valign="top">uint8_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__usb__common__functions.html#ga90da5cda2e1aa5ef41fba534270a8dad">Cy_USBD_GetIntfDscr</a> (<a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__usbd__ctxt__t">cy_stc_usb_usbd_ctxt_t</a> *pUsbdCtxt, uint8_t intfNum, uint8_t altSetting)</td></tr>
<tr class="memdesc:ga90da5cda2e1aa5ef41fba534270a8dad"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function called by application to get interface descriptor.  <a href="group__group__usbfxstack__usb__common__functions.html#ga90da5cda2e1aa5ef41fba534270a8dad">More...</a><br /></td></tr>
<tr class="separator:ga90da5cda2e1aa5ef41fba534270a8dad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4ca85038a7418ef62f6b1bdc1df65a84"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__usb__common__functions.html#ga4ca85038a7418ef62f6b1bdc1df65a84">Cy_USBD_isIntfValid</a> (uint16_t intf, uint8_t *pCfgDscr)</td></tr>
<tr class="memdesc:ga4ca85038a7418ef62f6b1bdc1df65a84"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function checks given interface is part of configuration descriptor or not.  <a href="group__group__usbfxstack__usb__common__functions.html#ga4ca85038a7418ef62f6b1bdc1df65a84">More...</a><br /></td></tr>
<tr class="separator:ga4ca85038a7418ef62f6b1bdc1df65a84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga40ac2f7b5ff37fdd621b2b5b6caa96c9"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__usb__common__functions.html#ga40ac2f7b5ff37fdd621b2b5b6caa96c9">Cy_USBD_FindNumOfEndp</a> (uint8_t *pIntfDscr)</td></tr>
<tr class="memdesc:ga40ac2f7b5ff37fdd621b2b5b6caa96c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function gives number of Endpoints supported by given interface.  <a href="group__group__usbfxstack__usb__common__functions.html#ga40ac2f7b5ff37fdd621b2b5b6caa96c9">More...</a><br /></td></tr>
<tr class="separator:ga40ac2f7b5ff37fdd621b2b5b6caa96c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1a7df92a3bc3fb0fb097bc56efb29711"><td class="memItemLeft" align="right" valign="top">uint8_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__usb__common__functions.html#ga1a7df92a3bc3fb0fb097bc56efb29711">Cy_USBD_GetEndpDscr</a> (<a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__usbd__ctxt__t">cy_stc_usb_usbd_ctxt_t</a> *pUsbdCtxt, uint8_t *pIntfDscr)</td></tr>
<tr class="memdesc:ga1a7df92a3bc3fb0fb097bc56efb29711"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function to fetch endpoint descriptor for a given interface descriptor.  <a href="group__group__usbfxstack__usb__common__functions.html#ga1a7df92a3bc3fb0fb097bc56efb29711">More...</a><br /></td></tr>
<tr class="separator:ga1a7df92a3bc3fb0fb097bc56efb29711"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafc517870de13bda5fe23540253903db8"><td class="memItemLeft" align="right" valign="top">uint8_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__usb__common__functions.html#gafc517870de13bda5fe23540253903db8">Cy_USBD_GetSsEndpCompDscr</a> (<a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__usbd__ctxt__t">cy_stc_usb_usbd_ctxt_t</a> *pUsbdCtxt, uint8_t *pEndpDscr)</td></tr>
<tr class="memdesc:gafc517870de13bda5fe23540253903db8"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function to fetch super speed endpoint companion descriptor.  <a href="group__group__usbfxstack__usb__common__functions.html#gafc517870de13bda5fe23540253903db8">More...</a><br /></td></tr>
<tr class="separator:gafc517870de13bda5fe23540253903db8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga54ead8b2424e1d1d74b7dc391ec32e45"><td class="memItemLeft" align="right" valign="top">uint8_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__usb__common__functions.html#ga54ead8b2424e1d1d74b7dc391ec32e45">Cy_USBD_GetSspIsoCompDscr</a> (<a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__usbd__ctxt__t">cy_stc_usb_usbd_ctxt_t</a> *pUsbdCtxt, uint8_t *pCompDscr)</td></tr>
<tr class="memdesc:ga54ead8b2424e1d1d74b7dc391ec32e45"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function to fetch super speed plus Iso endpoint companion descriptor from given companion descriptor.  <a href="group__group__usbfxstack__usb__common__functions.html#ga54ead8b2424e1d1d74b7dc391ec32e45">More...</a><br /></td></tr>
<tr class="separator:ga54ead8b2424e1d1d74b7dc391ec32e45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7e7dc77a42c929abd75fb8421749adfc"><td class="memItemLeft" align="right" valign="top">uint8_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__usb__common__functions.html#ga7e7dc77a42c929abd75fb8421749adfc">Cy_USBD_GetSspIsoEndpCompDscr</a> (<a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__usbd__ctxt__t">cy_stc_usb_usbd_ctxt_t</a> *pUsbdCtxt, uint8_t *pEndpDscr)</td></tr>
<tr class="memdesc:ga7e7dc77a42c929abd75fb8421749adfc"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function to fetch super speed plus Iso endpoint companion descriptor from given endpoint descriptor.  <a href="group__group__usbfxstack__usb__common__functions.html#ga7e7dc77a42c929abd75fb8421749adfc">More...</a><br /></td></tr>
<tr class="separator:ga7e7dc77a42c929abd75fb8421749adfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4da87a7c1473dc412193aedb67548a2e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#gae84a77ef84aee90fcb7773ad13acab34">cy_en_usbd_ret_code_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__usb__common__functions.html#ga4da87a7c1473dc412193aedb67548a2e">Cy_USB_USBD_GetActiveAltSetting</a> (<a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__usbd__ctxt__t">cy_stc_usb_usbd_ctxt_t</a> *pUsbdCtxt, uint8_t intfNum, uint8_t *pAltSetting)</td></tr>
<tr class="memdesc:ga4da87a7c1473dc412193aedb67548a2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function called by application to know active altSetting for a given interface.  <a href="group__group__usbfxstack__usb__common__functions.html#ga4da87a7c1473dc412193aedb67548a2e">More...</a><br /></td></tr>
<tr class="separator:ga4da87a7c1473dc412193aedb67548a2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9dc7b6c55e7d8994296d068f87390837"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__usb__common__functions.html#ga9dc7b6c55e7d8994296d068f87390837">Cy_USBD_FindAltSetting</a> (uint8_t *pIntfDscr)</td></tr>
<tr class="memdesc:ga9dc7b6c55e7d8994296d068f87390837"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API gives information about alt setting supported by given interface.  <a href="group__group__usbfxstack__usb__common__functions.html#ga9dc7b6c55e7d8994296d068f87390837">More...</a><br /></td></tr>
<tr class="separator:ga9dc7b6c55e7d8994296d068f87390837"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga82cbe8a76c66eb49dc65b7de44516f97"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__usb__common__functions.html#ga82cbe8a76c66eb49dc65b7de44516f97">Cy_USBD_GetNumOfAltSetting</a> (<a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__usbd__ctxt__t">cy_stc_usb_usbd_ctxt_t</a> *pUsbdCtxt, uint8_t intfNum)</td></tr>
<tr class="memdesc:ga82cbe8a76c66eb49dc65b7de44516f97"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API gets number of alt setting in an interface from USBD context data structure.  <a href="group__group__usbfxstack__usb__common__functions.html#ga82cbe8a76c66eb49dc65b7de44516f97">More...</a><br /></td></tr>
<tr class="separator:ga82cbe8a76c66eb49dc65b7de44516f97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa70e13191f5c98bec363426d05a25bd8"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__usb__common__functions.html#gaa70e13191f5c98bec363426d05a25bd8">Cy_USBD_UpdateNumOfAltSetting</a> (<a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__usbd__ctxt__t">cy_stc_usb_usbd_ctxt_t</a> *pUsbdCtxt, uint8_t intfNum)</td></tr>
<tr class="memdesc:gaa70e13191f5c98bec363426d05a25bd8"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API gets number of alt setting in an interface.  <a href="group__group__usbfxstack__usb__common__functions.html#gaa70e13191f5c98bec363426d05a25bd8">More...</a><br /></td></tr>
<tr class="separator:gaa70e13191f5c98bec363426d05a25bd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9e27d81be73ad39dec30145aa85340cc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__usb__common__functions.html#ga9e27d81be73ad39dec30145aa85340cc">Cy_USBD_EndpDscrValid</a> (uint8_t *pEndpDscr)</td></tr>
<tr class="memdesc:ga9e27d81be73ad39dec30145aa85340cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API confirms given descriptor is endpoint descriptor or not.  <a href="group__group__usbfxstack__usb__common__functions.html#ga9e27d81be73ad39dec30145aa85340cc">More...</a><br /></td></tr>
<tr class="separator:ga9e27d81be73ad39dec30145aa85340cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf1381bad137c8cd9563f163ec214f040"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#gae84a77ef84aee90fcb7773ad13acab34">cy_en_usbd_ret_code_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__usb__common__functions.html#gaf1381bad137c8cd9563f163ec214f040">Cy_USBD_GetEndpNumMaxPktDir</a> (uint8_t *pEndpDscr, uint32_t *pEndpNum, uint16_t *pMaxPktSize, uint32_t *pDir)</td></tr>
<tr class="memdesc:gaf1381bad137c8cd9563f163ec214f040"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function fetches endpoint number, maxPktSize and direction from endpoint descriptor.  <a href="group__group__usbfxstack__usb__common__functions.html#gaf1381bad137c8cd9563f163ec214f040">More...</a><br /></td></tr>
<tr class="separator:gaf1381bad137c8cd9563f163ec214f040"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga297593e06cb260f79ebb583d444fbdb5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#gae84a77ef84aee90fcb7773ad13acab34">cy_en_usbd_ret_code_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__usb__common__functions.html#ga297593e06cb260f79ebb583d444fbdb5">Cy_USBD_GetEndpMaxPktSize</a> (uint8_t *pEndpDscr, uint16_t *pMaxPktSize)</td></tr>
<tr class="memdesc:ga297593e06cb260f79ebb583d444fbdb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function fetches maxPktSize from endpoint descriptor.  <a href="group__group__usbfxstack__usb__common__functions.html#ga297593e06cb260f79ebb583d444fbdb5">More...</a><br /></td></tr>
<tr class="separator:ga297593e06cb260f79ebb583d444fbdb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga13e75fcb80a5ef2b1a88d1790375f223"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#gae84a77ef84aee90fcb7773ad13acab34">cy_en_usbd_ret_code_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__usb__common__functions.html#ga13e75fcb80a5ef2b1a88d1790375f223">Cy_USBD_GetIsoBytesPerIntvl</a> (uint8_t *pIsoCompDscr, uint32_t *pBytesPerIntvl)</td></tr>
<tr class="memdesc:ga13e75fcb80a5ef2b1a88d1790375f223"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function fetches max bytes per interval for Iso endpoint from iso companion endpoint descriptor.  <a href="group__group__usbfxstack__usb__common__functions.html#ga13e75fcb80a5ef2b1a88d1790375f223">More...</a><br /></td></tr>
<tr class="separator:ga13e75fcb80a5ef2b1a88d1790375f223"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7f03738269bc15e0918ae2c2ca84f329"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#gae84a77ef84aee90fcb7773ad13acab34">cy_en_usbd_ret_code_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__usb__common__functions.html#ga7f03738269bc15e0918ae2c2ca84f329">Cy_USBD_GetEndpAttribute</a> (uint8_t *pEndpDscr, uint8_t *pAttribute)</td></tr>
<tr class="memdesc:ga7f03738269bc15e0918ae2c2ca84f329"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function fetches endpoint attribute from endpoint descriptor.  <a href="group__group__usbfxstack__usb__common__functions.html#ga7f03738269bc15e0918ae2c2ca84f329">More...</a><br /></td></tr>
<tr class="separator:ga7f03738269bc15e0918ae2c2ca84f329"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae7268a6280238958eb27a1a5e6491657"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#gae84a77ef84aee90fcb7773ad13acab34">cy_en_usbd_ret_code_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__usb__common__functions.html#gae7268a6280238958eb27a1a5e6491657">Cy_USBD_GetEndpType</a> (uint8_t *pEndpDscr, uint32_t *pEndpType)</td></tr>
<tr class="memdesc:gae7268a6280238958eb27a1a5e6491657"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function fetches endpoint type from endpoint descriptor.  <a href="group__group__usbfxstack__usb__common__functions.html#gae7268a6280238958eb27a1a5e6491657">More...</a><br /></td></tr>
<tr class="separator:gae7268a6280238958eb27a1a5e6491657"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa3210c25334204266540479f8f45445e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#gae84a77ef84aee90fcb7773ad13acab34">cy_en_usbd_ret_code_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__usb__common__functions.html#gaa3210c25334204266540479f8f45445e">Cy_USBD_GetEndpInterval</a> (uint8_t *pEndpDscr, uint8_t *pInterval)</td></tr>
<tr class="memdesc:gaa3210c25334204266540479f8f45445e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function fetches bInterval from endpoint descriptor.  <a href="group__group__usbfxstack__usb__common__functions.html#gaa3210c25334204266540479f8f45445e">More...</a><br /></td></tr>
<tr class="separator:gaa3210c25334204266540479f8f45445e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf22af5687aca024286ecebbc68a60a4c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#gae84a77ef84aee90fcb7773ad13acab34">cy_en_usbd_ret_code_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__usb__common__functions.html#gaf22af5687aca024286ecebbc68a60a4c">Cy_USBD_GetEndpCompnMaxburst</a> (uint8_t *pEndpCompnDscr, uint8_t *pMaxBust)</td></tr>
<tr class="memdesc:gaf22af5687aca024286ecebbc68a60a4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function fetches bMaxBurst from endpoint companion descriptor.  <a href="group__group__usbfxstack__usb__common__functions.html#gaf22af5687aca024286ecebbc68a60a4c">More...</a><br /></td></tr>
<tr class="separator:gaf22af5687aca024286ecebbc68a60a4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa039c4b45b8a18cdf6958859304fbbc5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#gae84a77ef84aee90fcb7773ad13acab34">cy_en_usbd_ret_code_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__usb__common__functions.html#gaa039c4b45b8a18cdf6958859304fbbc5">Cy_USBD_GetEndpCompnMaxStream</a> (uint8_t *pEndpCompnDscr, uint8_t *pMaxStream)</td></tr>
<tr class="memdesc:gaa039c4b45b8a18cdf6958859304fbbc5"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function fetches bMaxStream from endpoint companion descriptor.  <a href="group__group__usbfxstack__usb__common__functions.html#gaa039c4b45b8a18cdf6958859304fbbc5">More...</a><br /></td></tr>
<tr class="separator:gaa039c4b45b8a18cdf6958859304fbbc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadc45ae4f9a67057f46829a8c440513a2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#gae84a77ef84aee90fcb7773ad13acab34">cy_en_usbd_ret_code_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__usb__common__functions.html#gadc45ae4f9a67057f46829a8c440513a2">Cy_USBD_GetEndpCompnAttribute</a> (uint8_t *pEndpCompnDscr, uint8_t *pAttribute)</td></tr>
<tr class="memdesc:gadc45ae4f9a67057f46829a8c440513a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function fetches attribute from endpoint companion descriptor.  <a href="group__group__usbfxstack__usb__common__functions.html#gadc45ae4f9a67057f46829a8c440513a2">More...</a><br /></td></tr>
<tr class="separator:gadc45ae4f9a67057f46829a8c440513a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga90ad5ed53545dd1607c99541de26ad4e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#gae84a77ef84aee90fcb7773ad13acab34">cy_en_usbd_ret_code_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__usb__common__functions.html#ga90ad5ed53545dd1607c99541de26ad4e">Cy_USBD_GetEndpCompnBytePerInterval</a> (uint8_t *pEndpCompnDscr, uint16_t *pBytePerInterval)</td></tr>
<tr class="memdesc:ga90ad5ed53545dd1607c99541de26ad4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function fetches bytePerInterval from endpoint companion descriptor.  <a href="group__group__usbfxstack__usb__common__functions.html#ga90ad5ed53545dd1607c99541de26ad4e">More...</a><br /></td></tr>
<tr class="separator:ga90ad5ed53545dd1607c99541de26ad4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaba62d87aea3874c9265d83cae762c4f0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#gae84a77ef84aee90fcb7773ad13acab34">cy_en_usbd_ret_code_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__usb__common__functions.html#gaba62d87aea3874c9265d83cae762c4f0">Cy_USBD_GetEndpSspIsoCompnBytePerInterval</a> (uint8_t *pSspIsoEndpCompnDscr, uint32_t *pBytePerInterval)</td></tr>
<tr class="memdesc:gaba62d87aea3874c9265d83cae762c4f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function fetches bytePerInterval from endpoint SS Iso companion descriptor.  <a href="group__group__usbfxstack__usb__common__functions.html#gaba62d87aea3874c9265d83cae762c4f0">More...</a><br /></td></tr>
<tr class="separator:gaba62d87aea3874c9265d83cae762c4f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7d124ac8af24c2cbe80b5563986c2e47"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#gae84a77ef84aee90fcb7773ad13acab34">cy_en_usbd_ret_code_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__usb__common__functions.html#ga7d124ac8af24c2cbe80b5563986c2e47">Cy_USBD_EnableEndp</a> (<a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__usbd__ctxt__t">cy_stc_usb_usbd_ctxt_t</a> *pUsbdCtxt, uint32_t endpNum, <a class="el" href="group__group__usbfxstack__usb__common__enums.html#gaaebdfe5d46401ad52420b00ca401e6f8">cy_en_usb_endp_dir_t</a> endpDir, bool enable)</td></tr>
<tr class="memdesc:ga7d124ac8af24c2cbe80b5563986c2e47"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function enable/disable endpoint.  <a href="group__group__usbfxstack__usb__common__functions.html#ga7d124ac8af24c2cbe80b5563986c2e47">More...</a><br /></td></tr>
<tr class="separator:ga7d124ac8af24c2cbe80b5563986c2e47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1be91a2a4ec8a7a364fddf195eb88425"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#gae84a77ef84aee90fcb7773ad13acab34">cy_en_usbd_ret_code_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__usb__common__functions.html#ga1be91a2a4ec8a7a364fddf195eb88425">Cy_USBD_SetEpBurstMode</a> (<a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__usbd__ctxt__t">cy_stc_usb_usbd_ctxt_t</a> *pUsbdCtxt, uint32_t endpNumber, <a class="el" href="group__group__usbfxstack__usb__common__enums.html#gaaebdfe5d46401ad52420b00ca401e6f8">cy_en_usb_endp_dir_t</a> endpDirection, bool enable)</td></tr>
<tr class="memdesc:ga1be91a2a4ec8a7a364fddf195eb88425"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function enables/disables the MULT (allow burst across multiple DMA buffers) feature for the specified USB endpoints.  <a href="group__group__usbfxstack__usb__common__functions.html#ga1be91a2a4ec8a7a364fddf195eb88425">More...</a><br /></td></tr>
<tr class="separator:ga1be91a2a4ec8a7a364fddf195eb88425"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacaba98384a734cd4182f89160fd2a646"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#gae84a77ef84aee90fcb7773ad13acab34">cy_en_usbd_ret_code_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__usb__common__functions.html#gacaba98384a734cd4182f89160fd2a646">Cy_USB_USBD_EndpConfig</a> (<a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__usbd__ctxt__t">cy_stc_usb_usbd_ctxt_t</a> *pUsbdCtxt, <a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__endp__config__t">cy_stc_usb_endp_config_t</a> endpConfig)</td></tr>
<tr class="memdesc:gacaba98384a734cd4182f89160fd2a646"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function configures endpoint based on user requirement.  <a href="group__group__usbfxstack__usb__common__functions.html#gacaba98384a734cd4182f89160fd2a646">More...</a><br /></td></tr>
<tr class="separator:gacaba98384a734cd4182f89160fd2a646"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf1da79bc3a477cbdfdb95c982bb41a04"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#gae84a77ef84aee90fcb7773ad13acab34">cy_en_usbd_ret_code_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__usb__common__functions.html#gaf1da79bc3a477cbdfdb95c982bb41a04">Cy_USB_USBD_EndpSetClearStall</a> (<a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__usbd__ctxt__t">cy_stc_usb_usbd_ctxt_t</a> *pUsbdCtxt, uint32_t endpNum, <a class="el" href="group__group__usbfxstack__usb__common__enums.html#gaaebdfe5d46401ad52420b00ca401e6f8">cy_en_usb_endp_dir_t</a> endpDir, bool setClear)</td></tr>
<tr class="memdesc:gaf1da79bc3a477cbdfdb95c982bb41a04"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function enable or disable STALL condition for the endpoint.  <a href="group__group__usbfxstack__usb__common__functions.html#gaf1da79bc3a477cbdfdb95c982bb41a04">More...</a><br /></td></tr>
<tr class="separator:gaf1da79bc3a477cbdfdb95c982bb41a04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6cfb5f60971661d85a8e59665a0b6d9d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#gae84a77ef84aee90fcb7773ad13acab34">cy_en_usbd_ret_code_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__usb__common__functions.html#ga6cfb5f60971661d85a8e59665a0b6d9d">Cy_USB_USBD_EndpSetClearNakNrdy</a> (<a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__usbd__ctxt__t">cy_stc_usb_usbd_ctxt_t</a> *pUsbdCtxt, uint32_t endpNum, <a class="el" href="group__group__usbfxstack__usb__common__enums.html#gaaebdfe5d46401ad52420b00ca401e6f8">cy_en_usb_endp_dir_t</a> endpDir, bool setClear)</td></tr>
<tr class="memdesc:ga6cfb5f60971661d85a8e59665a0b6d9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function enable or disable NAK/NRDY condition for the endpoint.  <a href="group__group__usbfxstack__usb__common__functions.html#ga6cfb5f60971661d85a8e59665a0b6d9d">More...</a><br /></td></tr>
<tr class="separator:ga6cfb5f60971661d85a8e59665a0b6d9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad2a5a168671e1484edd2e484bf94022d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__usb__common__functions.html#gad2a5a168671e1484edd2e484bf94022d">Cy_USBD_ResetEndp</a> (<a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__usbd__ctxt__t">cy_stc_usb_usbd_ctxt_t</a> *pUsbdCtxt, uint32_t endpNum, <a class="el" href="group__group__usbfxstack__usb__common__enums.html#gaaebdfe5d46401ad52420b00ca401e6f8">cy_en_usb_endp_dir_t</a> endpDir, bool preserveSeqNo)</td></tr>
<tr class="memdesc:gad2a5a168671e1484edd2e484bf94022d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function resets endpoint related paramters by calling appropriate function at HW level.  <a href="group__group__usbfxstack__usb__common__functions.html#gad2a5a168671e1484edd2e484bf94022d">More...</a><br /></td></tr>
<tr class="separator:gad2a5a168671e1484edd2e484bf94022d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa6d80ec6a7c1feccef3b932bf52bb1a3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__usb__common__functions.html#gaa6d80ec6a7c1feccef3b932bf52bb1a3">Cy_USBD_FlushEndp</a> (<a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__usbd__ctxt__t">cy_stc_usb_usbd_ctxt_t</a> *pUsbdCtxt, uint32_t endpNumber, <a class="el" href="group__group__usbfxstack__usb__common__enums.html#gaaebdfe5d46401ad52420b00ca401e6f8">cy_en_usb_endp_dir_t</a> endpDirection)</td></tr>
<tr class="memdesc:gaa6d80ec6a7c1feccef3b932bf52bb1a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function flush endpoint data present in EPM.  <a href="group__group__usbfxstack__usb__common__functions.html#gaa6d80ec6a7c1feccef3b932bf52bb1a3">More...</a><br /></td></tr>
<tr class="separator:gaa6d80ec6a7c1feccef3b932bf52bb1a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0e6ecbf5bf4f42b416a4446f6398fac4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__usb__common__functions.html#ga0e6ecbf5bf4f42b416a4446f6398fac4">Cy_USBD_FlushEndpAll</a> (<a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__usbd__ctxt__t">cy_stc_usb_usbd_ctxt_t</a> *pUsbdCtxt, <a class="el" href="group__group__usbfxstack__usb__common__enums.html#gaaebdfe5d46401ad52420b00ca401e6f8">cy_en_usb_endp_dir_t</a> endpDir)</td></tr>
<tr class="memdesc:ga0e6ecbf5bf4f42b416a4446f6398fac4"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function flush all endpoints data endpoint data present in EPM.  <a href="group__group__usbfxstack__usb__common__functions.html#ga0e6ecbf5bf4f42b416a4446f6398fac4">More...</a><br /></td></tr>
<tr class="separator:ga0e6ecbf5bf4f42b416a4446f6398fac4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga821a7397799e73dd3d243abc7514d544"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__usb__common__functions.html#ga821a7397799e73dd3d243abc7514d544">Cy_USBD_FlushResetEndpAll</a> (<a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__usbd__ctxt__t">cy_stc_usb_usbd_ctxt_t</a> *pUsbdCtxt, <a class="el" href="group__group__usbfxstack__usb__common__enums.html#gaaebdfe5d46401ad52420b00ca401e6f8">cy_en_usb_endp_dir_t</a> endpDirection)</td></tr>
<tr class="memdesc:ga821a7397799e73dd3d243abc7514d544"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function flush/reset all endpoint with perticular direction based on speed of device controller.  <a href="group__group__usbfxstack__usb__common__functions.html#ga821a7397799e73dd3d243abc7514d544">More...</a><br /></td></tr>
<tr class="separator:ga821a7397799e73dd3d243abc7514d544"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9f46fffd95cb649f1f5b64f9a9533af2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#gae84a77ef84aee90fcb7773ad13acab34">cy_en_usbd_ret_code_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__usb__common__functions.html#ga9f46fffd95cb649f1f5b64f9a9533af2">Cy_USB_USBD_EndpSetClearNakNrdyAll</a> (<a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__usbd__ctxt__t">cy_stc_usb_usbd_ctxt_t</a> *pUsbdCtxt, bool setClear)</td></tr>
<tr class="memdesc:ga9f46fffd95cb649f1f5b64f9a9533af2"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function enable or disable NAK/NRDY condition on all endpoints based on speed of device.  <a href="group__group__usbfxstack__usb__common__functions.html#ga9f46fffd95cb649f1f5b64f9a9533af2">More...</a><br /></td></tr>
<tr class="separator:ga9f46fffd95cb649f1f5b64f9a9533af2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1ccf7faf1524a69aa0648ab24ab4670b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__usb__common__functions.html#ga1ccf7faf1524a69aa0648ab24ab4670b">Cy_USBD_EndpIsNakNrdySet</a> (<a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__usbd__ctxt__t">cy_stc_usb_usbd_ctxt_t</a> *pUsbdCtxt, uint32_t endpNum, <a class="el" href="group__group__usbfxstack__usb__common__enums.html#gaaebdfe5d46401ad52420b00ca401e6f8">cy_en_usb_endp_dir_t</a> endpDir)</td></tr>
<tr class="memdesc:ga1ccf7faf1524a69aa0648ab24ab4670b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function checks whether the specified endpoint currently has the NAK/NRDY bit set.  <a href="group__group__usbfxstack__usb__common__functions.html#ga1ccf7faf1524a69aa0648ab24ab4670b">More...</a><br /></td></tr>
<tr class="separator:ga1ccf7faf1524a69aa0648ab24ab4670b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga62f120f49c6537697cbe1337055121e6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__usb__common__functions.html#ga62f120f49c6537697cbe1337055121e6">Cy_USBD_EndpIsStallSet</a> (<a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__usbd__ctxt__t">cy_stc_usb_usbd_ctxt_t</a> *pUsbdCtxt, uint32_t endpNum, <a class="el" href="group__group__usbfxstack__usb__common__enums.html#gaaebdfe5d46401ad52420b00ca401e6f8">cy_en_usb_endp_dir_t</a> endpDirection)</td></tr>
<tr class="memdesc:ga62f120f49c6537697cbe1337055121e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function checks whether the specified endpoint currently has the STALL bit set.  <a href="group__group__usbfxstack__usb__common__functions.html#ga62f120f49c6537697cbe1337055121e6">More...</a><br /></td></tr>
<tr class="separator:ga62f120f49c6537697cbe1337055121e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf747d68e5657ff171802bb908aade694"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#gae84a77ef84aee90fcb7773ad13acab34">cy_en_usbd_ret_code_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__usb__common__functions.html#gaf747d68e5657ff171802bb908aade694">Cy_USBD_EndpMapStream</a> (<a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__usbd__ctxt__t">cy_stc_usb_usbd_ctxt_t</a> *pUsbdCtxt, uint32_t endpNumber, <a class="el" href="group__group__usbfxstack__usb__common__enums.html#gaaebdfe5d46401ad52420b00ca401e6f8">cy_en_usb_endp_dir_t</a> endpDirection, uint16_t streamId, uint32_t socketNum)</td></tr>
<tr class="memdesc:gaf747d68e5657ff171802bb908aade694"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function maps an unused USB Ingress/Egress socket to the specified stream associated with a bulk endpoint.  <a href="group__group__usbfxstack__usb__common__functions.html#gaf747d68e5657ff171802bb908aade694">More...</a><br /></td></tr>
<tr class="separator:gaf747d68e5657ff171802bb908aade694"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gada92726f1df0b27c5fd06cc65a9390e7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#gae84a77ef84aee90fcb7773ad13acab34">cy_en_usbd_ret_code_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__usb__common__functions.html#gada92726f1df0b27c5fd06cc65a9390e7">Cy_USBD_EndpUnmapStream</a> (<a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__usbd__ctxt__t">cy_stc_usb_usbd_ctxt_t</a> *pUsbdCtxt, uint32_t endpNum, <a class="el" href="group__group__usbfxstack__usb__common__enums.html#gaaebdfe5d46401ad52420b00ca401e6f8">cy_en_usb_endp_dir_t</a> endpDir, uint32_t socketNum)</td></tr>
<tr class="memdesc:gada92726f1df0b27c5fd06cc65a9390e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function unmaps the USB ingress/egress socket to bulk stream mapping for a bulk endpoint and socket.  <a href="group__group__usbfxstack__usb__common__functions.html#gada92726f1df0b27c5fd06cc65a9390e7">More...</a><br /></td></tr>
<tr class="separator:gada92726f1df0b27c5fd06cc65a9390e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga333d4fe7dbfd5b6670ae9fa441421dcd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#gae84a77ef84aee90fcb7773ad13acab34">cy_en_usbd_ret_code_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__usb__common__functions.html#ga333d4fe7dbfd5b6670ae9fa441421dcd">Cy_USBD_EndpSetPktsPerBuffer</a> (<a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__usbd__ctxt__t">cy_stc_usb_usbd_ctxt_t</a> *pUsbdCtxt, uint32_t endpNumber, uint8_t pktsPerBuffer)</td></tr>
<tr class="memdesc:ga333d4fe7dbfd5b6670ae9fa441421dcd"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is used to update the USB block with the number of max.  <a href="group__group__usbfxstack__usb__common__functions.html#ga333d4fe7dbfd5b6670ae9fa441421dcd">More...</a><br /></td></tr>
<tr class="separator:ga333d4fe7dbfd5b6670ae9fa441421dcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5d33e619cb094cfe4bb25e79bd2938fc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__usb__common__functions.html#ga5d33e619cb094cfe4bb25e79bd2938fc">Cy_USBD_UpdateXferCount</a> (<a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__usbd__ctxt__t">cy_stc_usb_usbd_ctxt_t</a> *pUsbdCtxt, uint32_t endpNumber, <a class="el" href="group__group__usbfxstack__usb__common__enums.html#gaaebdfe5d46401ad52420b00ca401e6f8">cy_en_usb_endp_dir_t</a> endpDirection, uint32_t bufferSize)</td></tr>
<tr class="memdesc:ga5d33e619cb094cfe4bb25e79bd2938fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will update xfer count based on speed of device.  <a href="group__group__usbfxstack__usb__common__functions.html#ga5d33e619cb094cfe4bb25e79bd2938fc">More...</a><br /></td></tr>
<tr class="separator:ga5d33e619cb094cfe4bb25e79bd2938fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad9596e9f61e4d474c5d8ceab50b29e77"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__usb__common__functions.html#gad9596e9f61e4d474c5d8ceab50b29e77">Cy_USBD_CtrlEndp0DataOutAck</a> (<a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__usbd__ctxt__t">cy_stc_usb_usbd_ctxt_t</a> *pUsbdCtxt, bool setClear)</td></tr>
<tr class="memdesc:gad9596e9f61e4d474c5d8ceab50b29e77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data stage ACK for endpoint0 is controlled by this function.  <a href="group__group__usbfxstack__usb__common__functions.html#gad9596e9f61e4d474c5d8ceab50b29e77">More...</a><br /></td></tr>
<tr class="separator:gad9596e9f61e4d474c5d8ceab50b29e77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacc3236b5d736d112c5b9954195a9d07f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#gae84a77ef84aee90fcb7773ad13acab34">cy_en_usbd_ret_code_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__usb__common__functions.html#gacc3236b5d736d112c5b9954195a9d07f">Cy_USBD_EnableStatusCtrl</a> (<a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__usbd__ctxt__t">cy_stc_usb_usbd_ctxt_t</a> *pUsbdCtxt, bool enable)</td></tr>
<tr class="memdesc:gacc3236b5d736d112c5b9954195a9d07f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function enable/disable status control feature which is part of SS controller.  <a href="group__group__usbfxstack__usb__common__functions.html#gacc3236b5d736d112c5b9954195a9d07f">More...</a><br /></td></tr>
<tr class="separator:gacc3236b5d736d112c5b9954195a9d07f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacc22f450097f8a120f15547f2f5d9263"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#gae84a77ef84aee90fcb7773ad13acab34">cy_en_usbd_ret_code_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__usb__common__functions.html#gacc22f450097f8a120f15547f2f5d9263">Cy_USBD_ClearStatusClrBusy</a> (<a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__usbd__ctxt__t">cy_stc_usb_usbd_ctxt_t</a> *pUsbdCtxt)</td></tr>
<tr class="memdesc:gacc22f450097f8a120f15547f2f5d9263"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function write "1" to STATUS_CLR_BUSY which clears the bit to initiate STATUS response.  <a href="group__group__usbfxstack__usb__common__functions.html#gacc22f450097f8a120f15547f2f5d9263">More...</a><br /></td></tr>
<tr class="separator:gacc22f450097f8a120f15547f2f5d9263"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabcff797df0b1123869324c7e71dbfd01"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__usb__common__functions.html#gabcff797df0b1123869324c7e71dbfd01">Cy_USBD_SendAckSetupDataStatusStage</a> (<a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__usbd__ctxt__t">cy_stc_usb_usbd_ctxt_t</a> *pUsbdCtxt)</td></tr>
<tr class="memdesc:gabcff797df0b1123869324c7e71dbfd01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allow chipset to send ACK to complete control transfer.  <a href="group__group__usbfxstack__usb__common__functions.html#gabcff797df0b1123869324c7e71dbfd01">More...</a><br /></td></tr>
<tr class="separator:gabcff797df0b1123869324c7e71dbfd01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga82df864bb290c377687c5aa9ddffab36"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#gae84a77ef84aee90fcb7773ad13acab34">cy_en_usbd_ret_code_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__usb__common__functions.html#ga82df864bb290c377687c5aa9ddffab36">Cy_USB_USBD_SendEndp0Data</a> (<a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__usbd__ctxt__t">cy_stc_usb_usbd_ctxt_t</a> *pUsbdCtxt, uint8_t *pBuffer, uint32_t bufferSize)</td></tr>
<tr class="memdesc:ga82df864bb290c377687c5aa9ddffab36"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function sends data overthe DMA for endpoint 0.  <a href="group__group__usbfxstack__usb__common__functions.html#ga82df864bb290c377687c5aa9ddffab36">More...</a><br /></td></tr>
<tr class="separator:ga82df864bb290c377687c5aa9ddffab36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaba857ca0447aebe351c7f802fc758907"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#gae84a77ef84aee90fcb7773ad13acab34">cy_en_usbd_ret_code_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__usb__common__functions.html#gaba857ca0447aebe351c7f802fc758907">Cy_USB_USBD_SendEndp0DataSs</a> (<a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__usbd__ctxt__t">cy_stc_usb_usbd_ctxt_t</a> *pUsbdCtxt, uint8_t *pBuffer, uint32_t bufferSize)</td></tr>
<tr class="memdesc:gaba857ca0447aebe351c7f802fc758907"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function sends data overthe DMA for endpoint 0 of SS device.  <a href="group__group__usbfxstack__usb__common__functions.html#gaba857ca0447aebe351c7f802fc758907">More...</a><br /></td></tr>
<tr class="separator:gaba857ca0447aebe351c7f802fc758907"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae9974adc807741dbb090c1595b6786a1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#gae84a77ef84aee90fcb7773ad13acab34">cy_en_usbd_ret_code_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__usb__common__functions.html#gae9974adc807741dbb090c1595b6786a1">Cy_USB_USBD_SendEndp0DataHs</a> (<a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__usbd__ctxt__t">cy_stc_usb_usbd_ctxt_t</a> *pUsbdCtxt, uint8_t *pBuffer, uint32_t bufferSize)</td></tr>
<tr class="memdesc:gae9974adc807741dbb090c1595b6786a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function sends data overthe DMA for endpoint 0 of HS device.  <a href="group__group__usbfxstack__usb__common__functions.html#gae9974adc807741dbb090c1595b6786a1">More...</a><br /></td></tr>
<tr class="separator:gae9974adc807741dbb090c1595b6786a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga29e295da7e895b010412c44d23691270"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#gae84a77ef84aee90fcb7773ad13acab34">cy_en_usbd_ret_code_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__usb__common__functions.html#ga29e295da7e895b010412c44d23691270">Cy_USB_USBD_RecvEndp0Data</a> (<a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__usbd__ctxt__t">cy_stc_usb_usbd_ctxt_t</a> *pUsbdCtxt, uint8_t *pBuffer, uint32_t bufferSize)</td></tr>
<tr class="memdesc:ga29e295da7e895b010412c44d23691270"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function receives data overthe DMA for endpoint 0.  <a href="group__group__usbfxstack__usb__common__functions.html#ga29e295da7e895b010412c44d23691270">More...</a><br /></td></tr>
<tr class="separator:ga29e295da7e895b010412c44d23691270"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga42306ad5763a5ef88985afab49f0efef"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#gae84a77ef84aee90fcb7773ad13acab34">cy_en_usbd_ret_code_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__usb__common__functions.html#ga42306ad5763a5ef88985afab49f0efef">Cy_USB_USBD_RecvEndp0DataSs</a> (<a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__usbd__ctxt__t">cy_stc_usb_usbd_ctxt_t</a> *pUsbdCtxt, uint8_t *pBuffer, uint32_t bufferSize)</td></tr>
<tr class="memdesc:ga42306ad5763a5ef88985afab49f0efef"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function to recieve data for endpoint 0 through DMA for SS.  <a href="group__group__usbfxstack__usb__common__functions.html#ga42306ad5763a5ef88985afab49f0efef">More...</a><br /></td></tr>
<tr class="separator:ga42306ad5763a5ef88985afab49f0efef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac76c23b3433d3eb1ec9cd79f1f419d4e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#gae84a77ef84aee90fcb7773ad13acab34">cy_en_usbd_ret_code_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__usb__common__functions.html#gac76c23b3433d3eb1ec9cd79f1f419d4e">Cy_USB_USBD_RecvEndp0DataHs</a> (<a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__usbd__ctxt__t">cy_stc_usb_usbd_ctxt_t</a> *pUsbdCtxt, uint8_t *pBuffer, uint32_t bufferSize)</td></tr>
<tr class="memdesc:gac76c23b3433d3eb1ec9cd79f1f419d4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function to recieve data for endpoint 0 through DMA for HS.  <a href="group__group__usbfxstack__usb__common__functions.html#gac76c23b3433d3eb1ec9cd79f1f419d4e">More...</a><br /></td></tr>
<tr class="separator:gac76c23b3433d3eb1ec9cd79f1f419d4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8d2023c823502a6cc5bdc5fb1351c4c6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__usb__common__functions.html#ga8d2023c823502a6cc5bdc5fb1351c4c6">Cy_USBD_IsEp0ReceiveDone</a> (<a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__usbd__ctxt__t">cy_stc_usb_usbd_ctxt_t</a> *pUsbdCtxt)</td></tr>
<tr class="memdesc:ga8d2023c823502a6cc5bdc5fb1351c4c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function checks whether a EP0 data receive operation is pending.  <a href="group__group__usbfxstack__usb__common__functions.html#ga8d2023c823502a6cc5bdc5fb1351c4c6">More...</a><br /></td></tr>
<tr class="separator:ga8d2023c823502a6cc5bdc5fb1351c4c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga494034c62022f805d3714dc3a51fa7a5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#gae84a77ef84aee90fcb7773ad13acab34">cy_en_usbd_ret_code_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__usb__common__functions.html#ga494034c62022f805d3714dc3a51fa7a5">Cy_USBD_HandleGetDscr</a> (<a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__usbd__ctxt__t">cy_stc_usb_usbd_ctxt_t</a> *pUsbdCtxt, <a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__setup__req__t">cy_stc_usb_setup_req_t</a> setupReq, <a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__cal__msg__t">cy_stc_usb_cal_msg_t</a> *pMsg)</td></tr>
<tr class="memdesc:ga494034c62022f805d3714dc3a51fa7a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function handles all get descriptor command coming from host.  <a href="group__group__usbfxstack__usb__common__functions.html#ga494034c62022f805d3714dc3a51fa7a5">More...</a><br /></td></tr>
<tr class="separator:ga494034c62022f805d3714dc3a51fa7a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga58d0bcd2149941c51a7df4bf400391b5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#gae84a77ef84aee90fcb7773ad13acab34">cy_en_usbd_ret_code_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__usb__common__functions.html#ga58d0bcd2149941c51a7df4bf400391b5">Cy_USBD_HandleGetStatus</a> (<a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__usbd__ctxt__t">cy_stc_usb_usbd_ctxt_t</a> *pUsbdCtxt, <a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__setup__req__t">cy_stc_usb_setup_req_t</a> setupReq)</td></tr>
<tr class="memdesc:ga58d0bcd2149941c51a7df4bf400391b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function handles get status request coming from host.  <a href="group__group__usbfxstack__usb__common__functions.html#ga58d0bcd2149941c51a7df4bf400391b5">More...</a><br /></td></tr>
<tr class="separator:ga58d0bcd2149941c51a7df4bf400391b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3a71db97feb765576de168d1249e4a75"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#gae84a77ef84aee90fcb7773ad13acab34">cy_en_usbd_ret_code_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__usb__common__functions.html#ga3a71db97feb765576de168d1249e4a75">Cy_USBD_HandleSetFeature</a> (<a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__usbd__ctxt__t">cy_stc_usb_usbd_ctxt_t</a> *pUsbdCtxt, <a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__setup__req__t">cy_stc_usb_setup_req_t</a> setupReq, <a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__cal__msg__t">cy_stc_usb_cal_msg_t</a> *pMsg)</td></tr>
<tr class="memdesc:ga3a71db97feb765576de168d1249e4a75"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function handles set-feature request came from host.  <a href="group__group__usbfxstack__usb__common__functions.html#ga3a71db97feb765576de168d1249e4a75">More...</a><br /></td></tr>
<tr class="separator:ga3a71db97feb765576de168d1249e4a75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4f5e69968bee67460a97de7bf1daa8db"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#gae84a77ef84aee90fcb7773ad13acab34">cy_en_usbd_ret_code_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__usb__common__functions.html#ga4f5e69968bee67460a97de7bf1daa8db">Cy_USBD_HandleClearFeature</a> (<a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__usbd__ctxt__t">cy_stc_usb_usbd_ctxt_t</a> *pUsbdCtxt, <a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__setup__req__t">cy_stc_usb_setup_req_t</a> setupReq, <a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__cal__msg__t">cy_stc_usb_cal_msg_t</a> *pMsg)</td></tr>
<tr class="memdesc:ga4f5e69968bee67460a97de7bf1daa8db"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function handles clear-feature request came from host.  <a href="group__group__usbfxstack__usb__common__functions.html#ga4f5e69968bee67460a97de7bf1daa8db">More...</a><br /></td></tr>
<tr class="separator:ga4f5e69968bee67460a97de7bf1daa8db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac40e09702c31355f20bc92512f51a7f4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#gae84a77ef84aee90fcb7773ad13acab34">cy_en_usbd_ret_code_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__usb__common__functions.html#gac40e09702c31355f20bc92512f51a7f4">Cy_USBD_HandleSetConfiguration</a> (<a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__usbd__ctxt__t">cy_stc_usb_usbd_ctxt_t</a> *pUsbdCtxt, <a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__setup__req__t">cy_stc_usb_setup_req_t</a> setupReq, <a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__cal__msg__t">cy_stc_usb_cal_msg_t</a> *pMsg)</td></tr>
<tr class="memdesc:gac40e09702c31355f20bc92512f51a7f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function handles set configuration request came from host.  <a href="group__group__usbfxstack__usb__common__functions.html#gac40e09702c31355f20bc92512f51a7f4">More...</a><br /></td></tr>
<tr class="separator:gac40e09702c31355f20bc92512f51a7f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2fe891abc5be2f67cefb5fb78302a306"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#gae84a77ef84aee90fcb7773ad13acab34">cy_en_usbd_ret_code_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__usb__common__functions.html#ga2fe891abc5be2f67cefb5fb78302a306">Cy_USBD_HandleGetConfiguration</a> (<a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__usbd__ctxt__t">cy_stc_usb_usbd_ctxt_t</a> *pUsbdCtxt, <a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__setup__req__t">cy_stc_usb_setup_req_t</a> setupReq)</td></tr>
<tr class="memdesc:ga2fe891abc5be2f67cefb5fb78302a306"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function handles get configuration request came from host.  <a href="group__group__usbfxstack__usb__common__functions.html#ga2fe891abc5be2f67cefb5fb78302a306">More...</a><br /></td></tr>
<tr class="separator:ga2fe891abc5be2f67cefb5fb78302a306"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6d85d4f4520580f23d317650d1e0f973"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#gae84a77ef84aee90fcb7773ad13acab34">cy_en_usbd_ret_code_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__usb__common__functions.html#ga6d85d4f4520580f23d317650d1e0f973">Cy_USBD_HandleSetInterface</a> (<a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__usbd__ctxt__t">cy_stc_usb_usbd_ctxt_t</a> *pUsbdCtxt, <a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__setup__req__t">cy_stc_usb_setup_req_t</a> setupReq, <a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__cal__msg__t">cy_stc_usb_cal_msg_t</a> *pMsg)</td></tr>
<tr class="memdesc:ga6d85d4f4520580f23d317650d1e0f973"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function handles set interface request came from host.  <a href="group__group__usbfxstack__usb__common__functions.html#ga6d85d4f4520580f23d317650d1e0f973">More...</a><br /></td></tr>
<tr class="separator:ga6d85d4f4520580f23d317650d1e0f973"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab879bc0466d224eeb8ffa0e2b9b763b5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#gae84a77ef84aee90fcb7773ad13acab34">cy_en_usbd_ret_code_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__usb__common__functions.html#gab879bc0466d224eeb8ffa0e2b9b763b5">Cy_USBD_HandleGetInterface</a> (<a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__usbd__ctxt__t">cy_stc_usb_usbd_ctxt_t</a> *pUsbdCtxt, <a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__setup__req__t">cy_stc_usb_setup_req_t</a> setupReq)</td></tr>
<tr class="memdesc:gab879bc0466d224eeb8ffa0e2b9b763b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function handles get interface request came from host.  <a href="group__group__usbfxstack__usb__common__functions.html#gab879bc0466d224eeb8ffa0e2b9b763b5">More...</a><br /></td></tr>
<tr class="separator:gab879bc0466d224eeb8ffa0e2b9b763b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2b3edfc749fc256626f8be6d95a6b244"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#gae84a77ef84aee90fcb7773ad13acab34">cy_en_usbd_ret_code_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__usb__common__functions.html#ga2b3edfc749fc256626f8be6d95a6b244">Cy_USBD_HandleReset</a> (<a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__usbd__ctxt__t">cy_stc_usb_usbd_ctxt_t</a> *pUsbdCtxt, <a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__cal__msg__t">cy_stc_usb_cal_msg_t</a> *pMsg)</td></tr>
<tr class="memdesc:ga2b3edfc749fc256626f8be6d95a6b244"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function handles bus reset.  <a href="group__group__usbfxstack__usb__common__functions.html#ga2b3edfc749fc256626f8be6d95a6b244">More...</a><br /></td></tr>
<tr class="separator:ga2b3edfc749fc256626f8be6d95a6b244"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacece834783f030a04ae1bbca325de05f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__usb__common__functions.html#gacece834783f030a04ae1bbca325de05f">Cy_USBD_HandleRxFailure</a> (<a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__usbd__ctxt__t">cy_stc_usb_usbd_ctxt_t</a> *pUsbdCtxt, bool enable, uint8_t retry_cnt)</td></tr>
<tr class="memdesc:gacece834783f030a04ae1bbca325de05f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables USB stack level work-around to attempt Gen2 connection start-up multiple times in case of training failure in Polling.Active or Polling.Config states.  <a href="group__group__usbfxstack__usb__common__functions.html#gacece834783f030a04ae1bbca325de05f">More...</a><br /></td></tr>
<tr class="separator:gacece834783f030a04ae1bbca325de05f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga550e2adb4828075fd3610a71b1324eff"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#gae84a77ef84aee90fcb7773ad13acab34">cy_en_usbd_ret_code_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__usb__common__functions.html#ga550e2adb4828075fd3610a71b1324eff">Cy_USBD_HandleSsReset</a> (<a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__usbd__ctxt__t">cy_stc_usb_usbd_ctxt_t</a> *pUsbdCtxt, <a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__cal__msg__t">cy_stc_usb_cal_msg_t</a> *pMsg)</td></tr>
<tr class="memdesc:ga550e2adb4828075fd3610a71b1324eff"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function handles reset in SS mode.  <a href="group__group__usbfxstack__usb__common__functions.html#ga550e2adb4828075fd3610a71b1324eff">More...</a><br /></td></tr>
<tr class="separator:ga550e2adb4828075fd3610a71b1324eff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf79e574239e6758e42d1fc73fa558aec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#gae84a77ef84aee90fcb7773ad13acab34">cy_en_usbd_ret_code_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__usb__common__functions.html#gaf79e574239e6758e42d1fc73fa558aec">Cy_USBD_HandleHsGrant</a> (<a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__usbd__ctxt__t">cy_stc_usb_usbd_ctxt_t</a> *pUsbdCtxt, <a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__cal__msg__t">cy_stc_usb_cal_msg_t</a> *pMsg)</td></tr>
<tr class="memdesc:gaf79e574239e6758e42d1fc73fa558aec"><td class="mdescLeft">&#160;</td><td class="mdescRight">High speed related switching is handled here.  <a href="group__group__usbfxstack__usb__common__functions.html#gaf79e574239e6758e42d1fc73fa558aec">More...</a><br /></td></tr>
<tr class="separator:gaf79e574239e6758e42d1fc73fa558aec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3f4d47836a876ce053a8f42033d207e7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#gae84a77ef84aee90fcb7773ad13acab34">cy_en_usbd_ret_code_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__usb__common__functions.html#ga3f4d47836a876ce053a8f42033d207e7">Cy_USBD_HandleResetDone</a> (<a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__usbd__ctxt__t">cy_stc_usb_usbd_ctxt_t</a> *pUsbdCtxt, <a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__cal__msg__t">cy_stc_usb_cal_msg_t</a> *pMsg)</td></tr>
<tr class="memdesc:ga3f4d47836a876ce053a8f42033d207e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function handles reset-done message.  <a href="group__group__usbfxstack__usb__common__functions.html#ga3f4d47836a876ce053a8f42033d207e7">More...</a><br /></td></tr>
<tr class="separator:ga3f4d47836a876ce053a8f42033d207e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5137686978a925ec779f272c5a0183a7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#gae84a77ef84aee90fcb7773ad13acab34">cy_en_usbd_ret_code_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__usb__common__functions.html#ga5137686978a925ec779f272c5a0183a7">Cy_USBD_HandleCtrlXfrSetupStage</a> (<a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__usbd__ctxt__t">cy_stc_usb_usbd_ctxt_t</a> *pUsbdCtxt, <a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__cal__msg__t">cy_stc_usb_cal_msg_t</a> *pMsg)</td></tr>
<tr class="memdesc:ga5137686978a925ec779f272c5a0183a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function handles setup stage of control transfer.  <a href="group__group__usbfxstack__usb__common__functions.html#ga5137686978a925ec779f272c5a0183a7">More...</a><br /></td></tr>
<tr class="separator:ga5137686978a925ec779f272c5a0183a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga95f2024779831f22798134ea81a8a74f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#gae84a77ef84aee90fcb7773ad13acab34">cy_en_usbd_ret_code_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__usb__common__functions.html#ga95f2024779831f22798134ea81a8a74f">Cy_USBD_HandleStatusStage</a> (<a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__usbd__ctxt__t">cy_stc_usb_usbd_ctxt_t</a> *pUsbdCtxt, <a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__cal__msg__t">cy_stc_usb_cal_msg_t</a> *pMsg)</td></tr>
<tr class="memdesc:ga95f2024779831f22798134ea81a8a74f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function handles status stage of control transfer.  <a href="group__group__usbfxstack__usb__common__functions.html#ga95f2024779831f22798134ea81a8a74f">More...</a><br /></td></tr>
<tr class="separator:ga95f2024779831f22798134ea81a8a74f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6fcbc825324f0109aa266131f87e1daf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#gae84a77ef84aee90fcb7773ad13acab34">cy_en_usbd_ret_code_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__usb__common__functions.html#ga6fcbc825324f0109aa266131f87e1daf">Cy_USBD_HandleSuspend</a> (<a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__usbd__ctxt__t">cy_stc_usb_usbd_ctxt_t</a> *pUsbdCtxt, <a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__cal__msg__t">cy_stc_usb_cal_msg_t</a> *pMsg)</td></tr>
<tr class="memdesc:ga6fcbc825324f0109aa266131f87e1daf"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function handles suspend functionality.  <a href="group__group__usbfxstack__usb__common__functions.html#ga6fcbc825324f0109aa266131f87e1daf">More...</a><br /></td></tr>
<tr class="separator:ga6fcbc825324f0109aa266131f87e1daf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga93abdaba6a1c545a26516f5aea024c89"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#gae84a77ef84aee90fcb7773ad13acab34">cy_en_usbd_ret_code_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__usb__common__functions.html#ga93abdaba6a1c545a26516f5aea024c89">Cy_USBD_HandleResume</a> (<a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__usbd__ctxt__t">cy_stc_usb_usbd_ctxt_t</a> *pUsbdCtxt, <a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__cal__msg__t">cy_stc_usb_cal_msg_t</a> *pMsg)</td></tr>
<tr class="memdesc:ga93abdaba6a1c545a26516f5aea024c89"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function handles resume functionality.  <a href="group__group__usbfxstack__usb__common__functions.html#ga93abdaba6a1c545a26516f5aea024c89">More...</a><br /></td></tr>
<tr class="separator:ga93abdaba6a1c545a26516f5aea024c89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab655f02a1b553ceea53401a2974c34cc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#gae84a77ef84aee90fcb7773ad13acab34">cy_en_usbd_ret_code_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__usb__common__functions.html#gab655f02a1b553ceea53401a2974c34cc">Cy_USBD_HandleL1Sleep</a> (<a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__usbd__ctxt__t">cy_stc_usb_usbd_ctxt_t</a> *pUsbdCtxt, <a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__cal__msg__t">cy_stc_usb_cal_msg_t</a> *pMsg)</td></tr>
<tr class="memdesc:gab655f02a1b553ceea53401a2974c34cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function handles L1-Sleep functionality.  <a href="group__group__usbfxstack__usb__common__functions.html#gab655f02a1b553ceea53401a2974c34cc">More...</a><br /></td></tr>
<tr class="separator:gab655f02a1b553ceea53401a2974c34cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga67523878eb2b163f65cbd127720f3e5a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#gae84a77ef84aee90fcb7773ad13acab34">cy_en_usbd_ret_code_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__usb__common__functions.html#ga67523878eb2b163f65cbd127720f3e5a">Cy_USBD_HandleL1Resume</a> (<a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__usbd__ctxt__t">cy_stc_usb_usbd_ctxt_t</a> *pUsbdCtxt, <a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__cal__msg__t">cy_stc_usb_cal_msg_t</a> *pMsg)</td></tr>
<tr class="memdesc:ga67523878eb2b163f65cbd127720f3e5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function handles L1-Resume functionality.  <a href="group__group__usbfxstack__usb__common__functions.html#ga67523878eb2b163f65cbd127720f3e5a">More...</a><br /></td></tr>
<tr class="separator:ga67523878eb2b163f65cbd127720f3e5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga827a7b13b1cab4ba28f70a5bee33701d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#gae84a77ef84aee90fcb7773ad13acab34">cy_en_usbd_ret_code_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__usb__common__functions.html#ga827a7b13b1cab4ba28f70a5bee33701d">Cy_USBD_HandleZlp</a> (<a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__usbd__ctxt__t">cy_stc_usb_usbd_ctxt_t</a> *pUsbdCtxt, <a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__cal__msg__t">cy_stc_usb_cal_msg_t</a> *pMsg)</td></tr>
<tr class="memdesc:ga827a7b13b1cab4ba28f70a5bee33701d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function handles Zero-Length-Packet.  <a href="group__group__usbfxstack__usb__common__functions.html#ga827a7b13b1cab4ba28f70a5bee33701d">More...</a><br /></td></tr>
<tr class="separator:ga827a7b13b1cab4ba28f70a5bee33701d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf311aceab08016ebaf211f4df1226385"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#gae84a77ef84aee90fcb7773ad13acab34">cy_en_usbd_ret_code_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__usb__common__functions.html#gaf311aceab08016ebaf211f4df1226385">Cy_USBD_HandleDone</a> (<a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__usbd__ctxt__t">cy_stc_usb_usbd_ctxt_t</a> *pUsbdCtxt, <a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__cal__msg__t">cy_stc_usb_cal_msg_t</a> *pMsg)</td></tr>
<tr class="memdesc:gaf311aceab08016ebaf211f4df1226385"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function handles done interrupt for an endpoint.  <a href="group__group__usbfxstack__usb__common__functions.html#gaf311aceab08016ebaf211f4df1226385">More...</a><br /></td></tr>
<tr class="separator:gaf311aceab08016ebaf211f4df1226385"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadf1e3adb3e04d0cdcfe6a871d250e53e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#gae84a77ef84aee90fcb7773ad13acab34">cy_en_usbd_ret_code_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__usb__common__functions.html#gadf1e3adb3e04d0cdcfe6a871d250e53e">Cy_USBD_HandleRateChange</a> (<a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__usbd__ctxt__t">cy_stc_usb_usbd_ctxt_t</a> *pUsbdCtxt, <a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__cal__msg__t">cy_stc_usb_cal_msg_t</a> *pMsg)</td></tr>
<tr class="memdesc:gadf1e3adb3e04d0cdcfe6a871d250e53e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function handles rate change.  <a href="group__group__usbfxstack__usb__common__functions.html#gadf1e3adb3e04d0cdcfe6a871d250e53e">More...</a><br /></td></tr>
<tr class="separator:gadf1e3adb3e04d0cdcfe6a871d250e53e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafebe7d0add100f8fb32d3ff44b0e825d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#gae84a77ef84aee90fcb7773ad13acab34">cy_en_usbd_ret_code_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__usb__common__functions.html#gafebe7d0add100f8fb32d3ff44b0e825d">Cy_USBD_HandleSlp</a> (<a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__usbd__ctxt__t">cy_stc_usb_usbd_ctxt_t</a> *pUsbdCtxt, <a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__cal__msg__t">cy_stc_usb_cal_msg_t</a> *pMsg)</td></tr>
<tr class="memdesc:gafebe7d0add100f8fb32d3ff44b0e825d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function handles short length packet functionality.  <a href="group__group__usbfxstack__usb__common__functions.html#gafebe7d0add100f8fb32d3ff44b0e825d">More...</a><br /></td></tr>
<tr class="separator:gafebe7d0add100f8fb32d3ff44b0e825d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5223516b6ac49a76d31b99d0aa6f9928"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#gae84a77ef84aee90fcb7773ad13acab34">cy_en_usbd_ret_code_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__usb__common__functions.html#ga5223516b6ac49a76d31b99d0aa6f9928">Cy_USBD_HandleSsDisconnect</a> (<a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__usbd__ctxt__t">cy_stc_usb_usbd_ctxt_t</a> *pUsbdCtxt, <a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__cal__msg__t">cy_stc_usb_cal_msg_t</a> *pMsg)</td></tr>
<tr class="memdesc:ga5223516b6ac49a76d31b99d0aa6f9928"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function handles disconnect event/message came from bottom layer.  <a href="group__group__usbfxstack__usb__common__functions.html#ga5223516b6ac49a76d31b99d0aa6f9928">More...</a><br /></td></tr>
<tr class="separator:ga5223516b6ac49a76d31b99d0aa6f9928"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga32b62782b26309ed4d23171293dded2e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#gae84a77ef84aee90fcb7773ad13acab34">cy_en_usbd_ret_code_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__usb__common__functions.html#ga32b62782b26309ed4d23171293dded2e">Cy_USBD_HandleMsg</a> (<a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__usbd__ctxt__t">cy_stc_usb_usbd_ctxt_t</a> *pUsbdCtxt, <a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__cal__msg__t">cy_stc_usb_cal_msg_t</a> *pMsg)</td></tr>
<tr class="memdesc:ga32b62782b26309ed4d23171293dded2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function handles all messages comes from bottom layer.  <a href="group__group__usbfxstack__usb__common__functions.html#ga32b62782b26309ed4d23171293dded2e">More...</a><br /></td></tr>
<tr class="separator:ga32b62782b26309ed4d23171293dded2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad326897e3fefec5263bcd4cdb9eaef10"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__usb__common__functions.html#gad326897e3fefec5263bcd4cdb9eaef10">Cy_USBD_InitUsbDscrPtrs</a> (<a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__set__dscr__ptrs__t">cy_stc_usb_set_dscr_ptrs_t</a> *pDscr)</td></tr>
<tr class="memdesc:gad326897e3fefec5263bcd4cdb9eaef10"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function initializes all descriptor pointers to NULL.  <a href="group__group__usbfxstack__usb__common__functions.html#gad326897e3fefec5263bcd4cdb9eaef10">More...</a><br /></td></tr>
<tr class="separator:gad326897e3fefec5263bcd4cdb9eaef10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga420c764f5baa114d17721fd13a88f360"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__usb__common__functions.html#ga420c764f5baa114d17721fd13a88f360">Cy_USBD_ConnectHsDevice</a> (<a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__usbd__ctxt__t">cy_stc_usb_usbd_ctxt_t</a> *pUsbdCtxt)</td></tr>
<tr class="memdesc:ga420c764f5baa114d17721fd13a88f360"><td class="mdescLeft">&#160;</td><td class="mdescRight">This functions connects HS device to BUS and make it visible to host.  <a href="group__group__usbfxstack__usb__common__functions.html#ga420c764f5baa114d17721fd13a88f360">More...</a><br /></td></tr>
<tr class="separator:ga420c764f5baa114d17721fd13a88f360"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga05b97a72fd09dee078bb40268f5f7a05"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__usb__common__functions.html#ga05b97a72fd09dee078bb40268f5f7a05">Cy_USBD_ConnectSsDevice</a> (<a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__usbd__ctxt__t">cy_stc_usb_usbd_ctxt_t</a> *pUsbdCtxt)</td></tr>
<tr class="memdesc:ga05b97a72fd09dee078bb40268f5f7a05"><td class="mdescLeft">&#160;</td><td class="mdescRight">This functions connects SS device to BUS and make it visible to host.  <a href="group__group__usbfxstack__usb__common__functions.html#ga05b97a72fd09dee078bb40268f5f7a05">More...</a><br /></td></tr>
<tr class="separator:ga05b97a72fd09dee078bb40268f5f7a05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7efde427e45f7e6259d44841ae04ec60"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__usb__common__functions.html#ga7efde427e45f7e6259d44841ae04ec60">Cy_USBD_ConnectDevice</a> (<a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__usbd__ctxt__t">cy_stc_usb_usbd_ctxt_t</a> *pUsbdCtxt, <a class="el" href="group__group__usbfxstack__usb__common__enums.html#ga0355d30a754a1ef18fec29f288f59880">cy_en_usb_speed_t</a> usbSpeed)</td></tr>
<tr class="memdesc:ga7efde427e45f7e6259d44841ae04ec60"><td class="mdescLeft">&#160;</td><td class="mdescRight">This functions connects USB device with given speed and make it visible on BUS.  <a href="group__group__usbfxstack__usb__common__functions.html#ga7efde427e45f7e6259d44841ae04ec60">More...</a><br /></td></tr>
<tr class="separator:ga7efde427e45f7e6259d44841ae04ec60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga03dc549d3e78e8de9f50c1c56f509aee"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__usb__common__functions.html#ga03dc549d3e78e8de9f50c1c56f509aee">Cy_USBD_ResetUsbdCommonDs</a> (<a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__usbd__ctxt__t">cy_stc_usb_usbd_ctxt_t</a> *pUsbdCtxt)</td></tr>
<tr class="memdesc:ga03dc549d3e78e8de9f50c1c56f509aee"><td class="mdescLeft">&#160;</td><td class="mdescRight">This functions reset all USBD common data structure.  <a href="group__group__usbfxstack__usb__common__functions.html#ga03dc549d3e78e8de9f50c1c56f509aee">More...</a><br /></td></tr>
<tr class="separator:ga03dc549d3e78e8de9f50c1c56f509aee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7354164ae4f00f64a4faab8afc55ea1d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__usb__common__functions.html#ga7354164ae4f00f64a4faab8afc55ea1d">Cy_USBD_DisconnectHsDevice</a> (<a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__usbd__ctxt__t">cy_stc_usb_usbd_ctxt_t</a> *pUsbdCtxt)</td></tr>
<tr class="memdesc:ga7354164ae4f00f64a4faab8afc55ea1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This functions dis-connects HS device from BUS and make it invisible to host.  <a href="group__group__usbfxstack__usb__common__functions.html#ga7354164ae4f00f64a4faab8afc55ea1d">More...</a><br /></td></tr>
<tr class="separator:ga7354164ae4f00f64a4faab8afc55ea1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf1cc4cd8e7c2d90f8d781c0963a9492c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__usb__common__functions.html#gaf1cc4cd8e7c2d90f8d781c0963a9492c">Cy_USBD_DisconnectSsDevice</a> (<a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__usbd__ctxt__t">cy_stc_usb_usbd_ctxt_t</a> *pUsbdCtxt)</td></tr>
<tr class="memdesc:gaf1cc4cd8e7c2d90f8d781c0963a9492c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This functions dis-connects SS device from BUS and make it invisible to host.  <a href="group__group__usbfxstack__usb__common__functions.html#gaf1cc4cd8e7c2d90f8d781c0963a9492c">More...</a><br /></td></tr>
<tr class="separator:gaf1cc4cd8e7c2d90f8d781c0963a9492c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae5a37b29b528f0f3bf7bb399009c928f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__usb__common__functions.html#gae5a37b29b528f0f3bf7bb399009c928f">Cy_USBD_DisconnectDevice</a> (<a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__usbd__ctxt__t">cy_stc_usb_usbd_ctxt_t</a> *pUsbdCtxt)</td></tr>
<tr class="memdesc:gae5a37b29b528f0f3bf7bb399009c928f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disconnect device from BUS.  <a href="group__group__usbfxstack__usb__common__functions.html#gae5a37b29b528f0f3bf7bb399009c928f">More...</a><br /></td></tr>
<tr class="separator:gae5a37b29b528f0f3bf7bb399009c928f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8dbb776b31f61a3ddf8a5efc7a23a60e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__usb__common__functions.html#ga8dbb776b31f61a3ddf8a5efc7a23a60e">Cy_USB_USBD_InitEndp0InCpuDmaDscrConfig</a> (cy_stc_usbd_dma_descr_conf_t *pEndp0InCpuDmaDscrConfig, bool first)</td></tr>
<tr class="memdesc:ga8dbb776b31f61a3ddf8a5efc7a23a60e"><td class="mdescLeft">&#160;</td><td class="mdescRight">It initializes DMA descriptor for endpoint 0 IN transfer.  <a href="group__group__usbfxstack__usb__common__functions.html#ga8dbb776b31f61a3ddf8a5efc7a23a60e">More...</a><br /></td></tr>
<tr class="separator:ga8dbb776b31f61a3ddf8a5efc7a23a60e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga474d6d8014027b257f437bbab2e499aa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__usb__common__functions.html#ga474d6d8014027b257f437bbab2e499aa">Cy_USB_USBD_InitEndp0OutCpuDmaDscrConfig</a> (cy_stc_usbd_dma_descr_conf_t *pEndp0OutdscrConfig, bool first)</td></tr>
<tr class="memdesc:ga474d6d8014027b257f437bbab2e499aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">It initializes DMA descriptor for EP0-OUT transfers.  <a href="group__group__usbfxstack__usb__common__functions.html#ga474d6d8014027b257f437bbab2e499aa">More...</a><br /></td></tr>
<tr class="separator:ga474d6d8014027b257f437bbab2e499aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2f21cb330a6041dda91d9f6bf613cf1a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__usb__common__functions.html#ga2f21cb330a6041dda91d9f6bf613cf1a">Cy_USB_USBD_InitCpuDmaChannelCfg</a> (cy_stc_usbd_dma_chn_conf_t *pDmaChCfg, cy_stc_usbd_dma_descr_t *pDmaDscr)</td></tr>
<tr class="memdesc:ga2f21cb330a6041dda91d9f6bf613cf1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">It initializes DMA channel config.  <a href="group__group__usbfxstack__usb__common__functions.html#ga2f21cb330a6041dda91d9f6bf613cf1a">More...</a><br /></td></tr>
<tr class="separator:ga2f21cb330a6041dda91d9f6bf613cf1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6b1a4edc99d170c691a20628850f4cff"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#gae84a77ef84aee90fcb7773ad13acab34">cy_en_usbd_ret_code_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__usb__common__functions.html#ga6b1a4edc99d170c691a20628850f4cff">Cy_USB_USBD_cpuDmaInit</a> (<a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__usbd__ctxt__t">cy_stc_usb_usbd_ctxt_t</a> *pUsbdCtxt)</td></tr>
<tr class="memdesc:ga6b1a4edc99d170c691a20628850f4cff"><td class="mdescLeft">&#160;</td><td class="mdescRight">It initializes Cpu DMA functionality.  <a href="group__group__usbfxstack__usb__common__functions.html#ga6b1a4edc99d170c691a20628850f4cff">More...</a><br /></td></tr>
<tr class="separator:ga6b1a4edc99d170c691a20628850f4cff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8c0f7cea82a43cb3c8a85b78e832a16d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#gae84a77ef84aee90fcb7773ad13acab34">cy_en_usbd_ret_code_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__usb__common__functions.html#ga8c0f7cea82a43cb3c8a85b78e832a16d">Cy_USB_USBD_EndpInit</a> (<a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__usbd__ctxt__t">cy_stc_usb_usbd_ctxt_t</a> *pUsbdCtxt)</td></tr>
<tr class="memdesc:ga8c0f7cea82a43cb3c8a85b78e832a16d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function initializes endpoint 0 and other endpoints for HS and SS controller.  <a href="group__group__usbfxstack__usb__common__functions.html#ga8c0f7cea82a43cb3c8a85b78e832a16d">More...</a><br /></td></tr>
<tr class="separator:ga8c0f7cea82a43cb3c8a85b78e832a16d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9e36a9d8b7ed2bfc6f511a75f04e4a9d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__usb__common__functions.html#ga9e36a9d8b7ed2bfc6f511a75f04e4a9d">Cy_USB_USBD_DisableHsDevice</a> (<a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__usbd__ctxt__t">cy_stc_usb_usbd_ctxt_t</a> *pUsbdCtxt)</td></tr>
<tr class="memdesc:ga9e36a9d8b7ed2bfc6f511a75f04e4a9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function disable all HS device interrupt and make device invisible on BUS.  <a href="group__group__usbfxstack__usb__common__functions.html#ga9e36a9d8b7ed2bfc6f511a75f04e4a9d">More...</a><br /></td></tr>
<tr class="separator:ga9e36a9d8b7ed2bfc6f511a75f04e4a9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga711f5357e15324953d602f82b2dd5352"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__usb__common__functions.html#ga711f5357e15324953d602f82b2dd5352">Cy_USB_USBD_EnableHsDevice</a> (<a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__usbd__ctxt__t">cy_stc_usb_usbd_ctxt_t</a> *pUsbdCtxt)</td></tr>
<tr class="memdesc:ga711f5357e15324953d602f82b2dd5352"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function enable HS device and make it visible on BUS.  <a href="group__group__usbfxstack__usb__common__functions.html#ga711f5357e15324953d602f82b2dd5352">More...</a><br /></td></tr>
<tr class="separator:ga711f5357e15324953d602f82b2dd5352"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga25f65d5819842984443338e3e1e53589"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__usb__common__functions.html#ga25f65d5819842984443338e3e1e53589">Cy_USBD_CtrlHSEnableOnCompliance</a> (<a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__usbd__ctxt__t">cy_stc_usb_usbd_ctxt_t</a> *pUsbdCtxt, bool hsEnable)</td></tr>
<tr class="memdesc:ga25f65d5819842984443338e3e1e53589"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function used to enable/disable switch to USB-HS (2.0) mode on entry into the USB 3.x Compliance LTSSM state.  <a href="group__group__usbfxstack__usb__common__functions.html#ga25f65d5819842984443338e3e1e53589">More...</a><br /></td></tr>
<tr class="separator:ga25f65d5819842984443338e3e1e53589"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabdad35eff0a5a0edfafefd7e20dc04ee"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__usb__common__functions.html#gabdad35eff0a5a0edfafefd7e20dc04ee">Cy_USBD_TaskHandler</a> (void *pTaskParam)</td></tr>
<tr class="memdesc:gabdad35eff0a5a0edfafefd7e20dc04ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function handles msg coming from CAL layer.  <a href="group__group__usbfxstack__usb__common__functions.html#gabdad35eff0a5a0edfafefd7e20dc04ee">More...</a><br /></td></tr>
<tr class="separator:gabdad35eff0a5a0edfafefd7e20dc04ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga07d325da8e54e8406d237acb1a438fa3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__usb__common__functions.html#ga07d325da8e54e8406d237acb1a438fa3">Cy_USBD_ProcessMsg</a> (void *pUsbd, void *pCalMgs)</td></tr>
<tr class="memdesc:ga07d325da8e54e8406d237acb1a438fa3"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function sends msg to USBD thread.  <a href="group__group__usbfxstack__usb__common__functions.html#ga07d325da8e54e8406d237acb1a438fa3">More...</a><br /></td></tr>
<tr class="separator:ga07d325da8e54e8406d237acb1a438fa3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaead01314010be5d6a4d2e4ef9d8843ee"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#gae84a77ef84aee90fcb7773ad13acab34">cy_en_usbd_ret_code_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__usb__common__functions.html#gaead01314010be5d6a4d2e4ef9d8843ee">Cy_USBD_SendEgressZLP</a> (<a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__usbd__ctxt__t">cy_stc_usb_usbd_ctxt_t</a> *pUsbdCtxt, uint32_t endpNumber)</td></tr>
<tr class="memdesc:gaead01314010be5d6a4d2e4ef9d8843ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function sends ZLP for given endpoint.  <a href="group__group__usbfxstack__usb__common__functions.html#gaead01314010be5d6a4d2e4ef9d8843ee">More...</a><br /></td></tr>
<tr class="separator:gaead01314010be5d6a4d2e4ef9d8843ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa8932a5f32ae3ffbd2d70ddc73795dae"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#gae84a77ef84aee90fcb7773ad13acab34">cy_en_usbd_ret_code_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__usb__common__functions.html#gaa8932a5f32ae3ffbd2d70ddc73795dae">Cy_USBD_ClearZlpSlpIntrEnableMask</a> (<a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__usbd__ctxt__t">cy_stc_usb_usbd_ctxt_t</a> *pUsbdCtxt, uint32_t endpNum, <a class="el" href="group__group__usbfxstack__usb__common__enums.html#gaaebdfe5d46401ad52420b00ca401e6f8">cy_en_usb_endp_dir_t</a> endpDir, bool zlpSlp)</td></tr>
<tr class="memdesc:gaa8932a5f32ae3ffbd2d70ddc73795dae"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function clears endpoint interrupt for ingrress and egresss and enables respective mask register.  <a href="group__group__usbfxstack__usb__common__functions.html#gaa8932a5f32ae3ffbd2d70ddc73795dae">More...</a><br /></td></tr>
<tr class="separator:gaa8932a5f32ae3ffbd2d70ddc73795dae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabd14f162a950f462d349632ca07d527a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#gae84a77ef84aee90fcb7773ad13acab34">cy_en_usbd_ret_code_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__usb__common__functions.html#gabd14f162a950f462d349632ca07d527a">Cy_USB_LpmSetClearNYET</a> (<a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__usbd__ctxt__t">cy_stc_usb_usbd_ctxt_t</a> *pUsbdCtxt, bool setClear)</td></tr>
<tr class="memdesc:gabd14f162a950f462d349632ca07d527a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a stack internal function used to enable/disable LPM support.  <a href="group__group__usbfxstack__usb__common__functions.html#gabd14f162a950f462d349632ca07d527a">More...</a><br /></td></tr>
<tr class="separator:gabd14f162a950f462d349632ca07d527a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeabb052fbdb02fe439c1b225d605c8cc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#gae84a77ef84aee90fcb7773ad13acab34">cy_en_usbd_ret_code_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__usb__common__functions.html#gaeabb052fbdb02fe439c1b225d605c8cc">Cy_USBD_GetUSBLinkActive</a> (<a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__usbd__ctxt__t">cy_stc_usb_usbd_ctxt_t</a> *pUsbdCtxt)</td></tr>
<tr class="memdesc:gaeabb052fbdb02fe439c1b225d605c8cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function ensures that the USB link is brought into the L0 (USB2) or U0 (USB3) state when the respective low power states.  <a href="group__group__usbfxstack__usb__common__functions.html#gaeabb052fbdb02fe439c1b225d605c8cc">More...</a><br /></td></tr>
<tr class="separator:gaeabb052fbdb02fe439c1b225d605c8cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa17017e98b5c349540a72d60c4d2f49b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#gae84a77ef84aee90fcb7773ad13acab34">cy_en_usbd_ret_code_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__usb__common__functions.html#gaa17017e98b5c349540a72d60c4d2f49b">Cy_USBD_LpmDisable</a> (<a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__usbd__ctxt__t">cy_stc_usb_usbd_ctxt_t</a> *pUsbdCtxt)</td></tr>
<tr class="memdesc:gaa17017e98b5c349540a72d60c4d2f49b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function disables all further transitions into a USB low power (U1, U2, or L1) state.  <a href="group__group__usbfxstack__usb__common__functions.html#gaa17017e98b5c349540a72d60c4d2f49b">More...</a><br /></td></tr>
<tr class="separator:gaa17017e98b5c349540a72d60c4d2f49b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa97f804cfdf6b4f89626a82c558ba4ff"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#gae84a77ef84aee90fcb7773ad13acab34">cy_en_usbd_ret_code_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__usb__common__functions.html#gaa97f804cfdf6b4f89626a82c558ba4ff">Cy_USBD_LpmEnable</a> (<a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__usbd__ctxt__t">cy_stc_usb_usbd_ctxt_t</a> *pUsbdCtxt)</td></tr>
<tr class="memdesc:gaa97f804cfdf6b4f89626a82c558ba4ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function re-enables state based transitions into USB low power (U1, U2 and L1) modes.  <a href="group__group__usbfxstack__usb__common__functions.html#gaa97f804cfdf6b4f89626a82c558ba4ff">More...</a><br /></td></tr>
<tr class="separator:gaa97f804cfdf6b4f89626a82c558ba4ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4451fd6aadc9f43fc818a6511b5d745b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__usb__common__functions.html#ga4451fd6aadc9f43fc818a6511b5d745b">Cy_USB_USBD_RetireRecvEndp0DataSs</a> (<a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__usbd__ctxt__t">cy_stc_usb_usbd_ctxt_t</a> *pUsbdCtxt)</td></tr>
<tr class="memdesc:ga4451fd6aadc9f43fc818a6511b5d745b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will disable dma channel for SS which was submitted to recieve data.  <a href="group__group__usbfxstack__usb__common__functions.html#ga4451fd6aadc9f43fc818a6511b5d745b">More...</a><br /></td></tr>
<tr class="separator:ga4451fd6aadc9f43fc818a6511b5d745b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5b92166b8c837f55481aa500b5261271"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__usb__common__functions.html#ga5b92166b8c837f55481aa500b5261271">Cy_USB_USBD_RetireRecvEndp0DataHs</a> (<a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__usbd__ctxt__t">cy_stc_usb_usbd_ctxt_t</a> *pUsbdCtxt)</td></tr>
<tr class="memdesc:ga5b92166b8c837f55481aa500b5261271"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will disable dma channel for HS which was submitted to recieve data.  <a href="group__group__usbfxstack__usb__common__functions.html#ga5b92166b8c837f55481aa500b5261271">More...</a><br /></td></tr>
<tr class="separator:ga5b92166b8c837f55481aa500b5261271"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5edcd886c977e547c5ca31c7b460c347"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#gae84a77ef84aee90fcb7773ad13acab34">cy_en_usbd_ret_code_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__usb__common__functions.html#ga5edcd886c977e547c5ca31c7b460c347">Cy_USB_USBD_RetireRecvEndp0Data</a> (<a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__usbd__ctxt__t">cy_stc_usb_usbd_ctxt_t</a> *pUsbdCtxt)</td></tr>
<tr class="memdesc:ga5edcd886c977e547c5ca31c7b460c347"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will disable dma channel which was submitted to recieve data.  <a href="group__group__usbfxstack__usb__common__functions.html#ga5edcd886c977e547c5ca31c7b460c347">More...</a><br /></td></tr>
<tr class="separator:ga5edcd886c977e547c5ca31c7b460c347"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga24ba3ab096cd4feef6b1c288b690899e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#gae84a77ef84aee90fcb7773ad13acab34">cy_en_usbd_ret_code_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__usb__common__functions.html#ga24ba3ab096cd4feef6b1c288b690899e">Cy_USBD_SendSSDeviceNotification</a> (<a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__usbd__ctxt__t">cy_stc_usb_usbd_ctxt_t</a> *pUsbdCtxt, <a class="el" href="group__group__usbfxstack__usb__common__enums.html#ga046dd04402c38ba57a541948326bea7b">cy_en_usbd_notification_type_t</a> type, uint32_t param0, uint32_t param1)</td></tr>
<tr class="memdesc:ga24ba3ab096cd4feef6b1c288b690899e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function sends a Device Notification Transaction Packet to the host controller on a USB 3.2 link.  <a href="group__group__usbfxstack__usb__common__functions.html#ga24ba3ab096cd4feef6b1c288b690899e">More...</a><br /></td></tr>
<tr class="separator:ga24ba3ab096cd4feef6b1c288b690899e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5988904fa2be63f450f4ab76ec659b45"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#gae84a77ef84aee90fcb7773ad13acab34">cy_en_usbd_ret_code_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__usb__common__functions.html#ga5988904fa2be63f450f4ab76ec659b45">Cy_USBD_InitEventLog</a> (<a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__usbd__ctxt__t">cy_stc_usb_usbd_ctxt_t</a> *pUsbdCtxt, uint32_t *pEvtLogBuf, uint16_t evtLogSize)</td></tr>
<tr class="memdesc:ga5988904fa2be63f450f4ab76ec659b45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables capture of USB HS/SS driver events and state changes into RAM buffer.  <a href="group__group__usbfxstack__usb__common__functions.html#ga5988904fa2be63f450f4ab76ec659b45">More...</a><br /></td></tr>
<tr class="separator:ga5988904fa2be63f450f4ab76ec659b45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga51f51a314156345c4f9961a6dc74eaaa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__usb__common__functions.html#ga51f51a314156345c4f9961a6dc74eaaa">Cy_USBD_AddEvtToLog</a> (<a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__usbd__ctxt__t">cy_stc_usb_usbd_ctxt_t</a> *pUsbdCtxt, uint32_t evtId)</td></tr>
<tr class="memdesc:ga51f51a314156345c4f9961a6dc74eaaa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add USB event/state to the RAM log buffer.  <a href="group__group__usbfxstack__usb__common__functions.html#ga51f51a314156345c4f9961a6dc74eaaa">More...</a><br /></td></tr>
<tr class="separator:ga51f51a314156345c4f9961a6dc74eaaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1a7b6b16e9a08a83872cd309b3181b51"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__usb__common__functions.html#ga1a7b6b16e9a08a83872cd309b3181b51">Cy_USBD_GetEvtLogIndex</a> (<a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__usbd__ctxt__t">cy_stc_usb_usbd_ctxt_t</a> *pUsbdCtxt)</td></tr>
<tr class="memdesc:ga1a7b6b16e9a08a83872cd309b3181b51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current USB driver event log index.  <a href="group__group__usbfxstack__usb__common__functions.html#ga1a7b6b16e9a08a83872cd309b3181b51">More...</a><br /></td></tr>
<tr class="separator:ga1a7b6b16e9a08a83872cd309b3181b51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafb68a32a78e83c910476683bfb126fa2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__usb__common__functions.html#gafb68a32a78e83c910476683bfb126fa2">Cy_USBD_TickIncrement</a> (<a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__usbd__ctxt__t">cy_stc_usb_usbd_ctxt_t</a> *pUsbdCtxt)</td></tr>
<tr class="memdesc:gafb68a32a78e83c910476683bfb126fa2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increment the timer tick variable used to timestamp the USB event logs.  <a href="group__group__usbfxstack__usb__common__functions.html#gafb68a32a78e83c910476683bfb126fa2">More...</a><br /></td></tr>
<tr class="separator:gafb68a32a78e83c910476683bfb126fa2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad5858b0970f3af6ceffbdb684a412bbb"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__usb__common__functions.html#gad5858b0970f3af6ceffbdb684a412bbb">Cy_USBD_GetTimerTick</a> (void)</td></tr>
<tr class="memdesc:gad5858b0970f3af6ceffbdb684a412bbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the current value of the timer tick.  <a href="group__group__usbfxstack__usb__common__functions.html#gad5858b0970f3af6ceffbdb684a412bbb">More...</a><br /></td></tr>
<tr class="separator:gad5858b0970f3af6ceffbdb684a412bbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga319946754a25e52dfb47834b8671c44d"><td class="memItemLeft" align="right" valign="top"><a id="ga319946754a25e52dfb47834b8671c44d" name="ga319946754a25e52dfb47834b8671c44d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>Cy_USBD_ResetTimerTick</b> (void)</td></tr>
<tr class="memdesc:ga319946754a25e52dfb47834b8671c44d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear the timer tick value maintained in the USB stack. <br /></td></tr>
<tr class="separator:ga319946754a25e52dfb47834b8671c44d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaab2f099dae9ad338dc39e6f0ca4683f6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__usb__common__functions.html#gaab2f099dae9ad338dc39e6f0ca4683f6">Cy_USBD_EP0OutDma_IntrHandler</a> (<a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__usbd__ctxt__t">cy_stc_usb_usbd_ctxt_t</a> *pUsbdCtxt)</td></tr>
<tr class="memdesc:gaab2f099dae9ad338dc39e6f0ca4683f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handler for interrupt associated with EP0-OUT DMA transfer in USB 2.x modes.  <a href="group__group__usbfxstack__usb__common__functions.html#gaab2f099dae9ad338dc39e6f0ca4683f6">More...</a><br /></td></tr>
<tr class="separator:gaab2f099dae9ad338dc39e6f0ca4683f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab5dab22f472ba69a6aee8d29464e29f6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#gae84a77ef84aee90fcb7773ad13acab34">cy_en_usbd_ret_code_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__usb__common__functions.html#gab5dab22f472ba69a6aee8d29464e29f6">Cy_USBD_SetDmaClkFreq</a> (<a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__usbd__ctxt__t">cy_stc_usb_usbd_ctxt_t</a> *pUsbdCtxt, <a class="el" href="group__group__usbfxstack__hb__dma__enums.html#gaf07a15620aa6ac9a13b4fffef4cf6a8c">cy_en_hbdma_clk_freq_t</a> dmaFreq)</td></tr>
<tr class="memdesc:gab5dab22f472ba69a6aee8d29464e29f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function which sets the desired DMA clock frequency during USB 3.x operation on the FX3G2 device.  <a href="group__group__usbfxstack__usb__common__functions.html#gab5dab22f472ba69a6aee8d29464e29f6">More...</a><br /></td></tr>
<tr class="separator:gab5dab22f472ba69a6aee8d29464e29f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9b7af7161a52cf93c822dfa3d89f7f28"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__usb__common__functions.html#ga9b7af7161a52cf93c822dfa3d89f7f28">Cy_USBD_DisableLPMDeviceExit</a> (<a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__usbd__ctxt__t">cy_stc_usb_usbd_ctxt_t</a> *pUsbdCtxt, bool devExitDisable)</td></tr>
<tr class="memdesc:ga9b7af7161a52cf93c822dfa3d89f7f28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to disable support for device initiated exit from USB 3.x low power modes completely.  <a href="group__group__usbfxstack__usb__common__functions.html#ga9b7af7161a52cf93c822dfa3d89f7f28">More...</a><br /></td></tr>
<tr class="separator:ga9b7af7161a52cf93c822dfa3d89f7f28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9bc22556f358fd830746ff3305be8226"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__usb__common__functions.html#ga9bc22556f358fd830746ff3305be8226">Cy_USBHS_Cal_Init</a> (<a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__cal__ctxt__t">cy_stc_usb_cal_ctxt_t</a> *pCalCtxt, void *pUsbdCtxt, <a class="el" href="group__group__usbfxstack__usb__common__typedefs.html#gaeb0c3502dfb024979701c241f98ef8b6">cy_usb_cal_msg_callback_t</a> callBackFunc)</td></tr>
<tr class="memdesc:ga9bc22556f358fd830746ff3305be8226"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the HS controller ie CAL layer and PHY.  <a href="group__group__usbfxstack__usb__common__functions.html#ga9bc22556f358fd830746ff3305be8226">More...</a><br /></td></tr>
<tr class="separator:ga9bc22556f358fd830746ff3305be8226"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7c1c86e72768878c411c653324beca1b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__usb__common__functions.html#ga7c1c86e72768878c411c653324beca1b">Cy_USBHS_Cal_FsHsModePhyInit</a> (<a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__cal__ctxt__t">cy_stc_usb_cal_ctxt_t</a> *pCalCtxt)</td></tr>
<tr class="memdesc:ga7c1c86e72768878c411c653324beca1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes high speed PHY.  <a href="group__group__usbfxstack__usb__common__functions.html#ga7c1c86e72768878c411c653324beca1b">More...</a><br /></td></tr>
<tr class="separator:ga7c1c86e72768878c411c653324beca1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1b24e1816f2cd2217932da1146205bd9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__usb__common__functions.html#ga1b24e1816f2cd2217932da1146205bd9">Cy_USBHS_Cal_PhyCommonInit</a> (<a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__cal__ctxt__t">cy_stc_usb_cal_ctxt_t</a> *pCalCtxt)</td></tr>
<tr class="memdesc:ga1b24e1816f2cd2217932da1146205bd9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes registers common to full and high speed PHY configuration.  <a href="group__group__usbfxstack__usb__common__functions.html#ga1b24e1816f2cd2217932da1146205bd9">More...</a><br /></td></tr>
<tr class="separator:ga1b24e1816f2cd2217932da1146205bd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga939724090c913bfed8c3c326e5d057c7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#ga0d79c3063de7043b78fe79bae1e9278a">cy_en_usb_cal_ret_code_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__usb__common__functions.html#ga939724090c913bfed8c3c326e5d057c7">Cy_USBHS_Cal_HandleReset</a> (<a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__cal__ctxt__t">cy_stc_usb_cal_ctxt_t</a> *pCalCtxt)</td></tr>
<tr class="memdesc:ga939724090c913bfed8c3c326e5d057c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">During reset controller updates.  <a href="group__group__usbfxstack__usb__common__functions.html#ga939724090c913bfed8c3c326e5d057c7">More...</a><br /></td></tr>
<tr class="separator:ga939724090c913bfed8c3c326e5d057c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad370055b2e98592aeb8f820671a4d3fc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#ga0d79c3063de7043b78fe79bae1e9278a">cy_en_usb_cal_ret_code_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__usb__common__functions.html#gad370055b2e98592aeb8f820671a4d3fc">Cy_USBHS_Cal_ConnUsbPins</a> (<a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__cal__ctxt__t">cy_stc_usb_cal_ctxt_t</a> *pCalCtxt)</td></tr>
<tr class="memdesc:gad370055b2e98592aeb8f820671a4d3fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update USB device controller register to make USB device visible on Bus.  <a href="group__group__usbfxstack__usb__common__functions.html#gad370055b2e98592aeb8f820671a4d3fc">More...</a><br /></td></tr>
<tr class="separator:gad370055b2e98592aeb8f820671a4d3fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga28c6f1e60a0fe051f775cb5f7d0e7845"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#ga0d79c3063de7043b78fe79bae1e9278a">cy_en_usb_cal_ret_code_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__usb__common__functions.html#ga28c6f1e60a0fe051f775cb5f7d0e7845">Cy_USBHS_Cal_DisconUsbPins</a> (<a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__cal__ctxt__t">cy_stc_usb_cal_ctxt_t</a> *pCalCtxt)</td></tr>
<tr class="memdesc:ga28c6f1e60a0fe051f775cb5f7d0e7845"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update Controller register to make USB device invisible on Bus.  <a href="group__group__usbfxstack__usb__common__functions.html#ga28c6f1e60a0fe051f775cb5f7d0e7845">More...</a><br /></td></tr>
<tr class="separator:ga28c6f1e60a0fe051f775cb5f7d0e7845"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae64853fb68bd6e88ed6716cb790a8ed2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__usb__common__functions.html#gae64853fb68bd6e88ed6716cb790a8ed2">Cy_USBHS_Cal_HsHandleL1Sleep</a> (<a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__cal__ctxt__t">cy_stc_usb_cal_ctxt_t</a> *pCalCtxt)</td></tr>
<tr class="memdesc:gae64853fb68bd6e88ed6716cb790a8ed2"><td class="mdescLeft">&#160;</td><td class="mdescRight">L1-SLEEP request during device in high speed mode will be handled here.  <a href="group__group__usbfxstack__usb__common__functions.html#gae64853fb68bd6e88ed6716cb790a8ed2">More...</a><br /></td></tr>
<tr class="separator:gae64853fb68bd6e88ed6716cb790a8ed2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa83e7606e372f52ea2049e98e974f795"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__usb__common__functions.html#gaa83e7606e372f52ea2049e98e974f795">Cy_USBHS_Cal_HsHandleL1WakeupCommon</a> (<a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__cal__ctxt__t">cy_stc_usb_cal_ctxt_t</a> *pCalCtxt)</td></tr>
<tr class="memdesc:gaa83e7606e372f52ea2049e98e974f795"><td class="mdescLeft">&#160;</td><td class="mdescRight">L1-Wakeup request during device in high speed mode will be handled here.  <a href="group__group__usbfxstack__usb__common__functions.html#gaa83e7606e372f52ea2049e98e974f795">More...</a><br /></td></tr>
<tr class="separator:gaa83e7606e372f52ea2049e98e974f795"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3393a803361af47e4965421f0cb1ad6e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__usb__common__functions.html#ga3393a803361af47e4965421f0cb1ad6e">Cy_USBHS_Cal_DevInitiatedL1Exit</a> (<a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__cal__ctxt__t">cy_stc_usb_cal_ctxt_t</a> *pCalCtxt, uint32_t duration)</td></tr>
<tr class="memdesc:ga3393a803361af47e4965421f0cb1ad6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function helps device to initiate resume from L1 SleepDevice.  <a href="group__group__usbfxstack__usb__common__functions.html#ga3393a803361af47e4965421f0cb1ad6e">More...</a><br /></td></tr>
<tr class="separator:ga3393a803361af47e4965421f0cb1ad6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5f5a1080209e357636ea9dab3a4d8e52"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__usb__common__functions.html#ga5f5a1080209e357636ea9dab3a4d8e52">Cy_USBHS_Cal_DevInitiatedResumeL2Sleep</a> (<a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__cal__ctxt__t">cy_stc_usb_cal_ctxt_t</a> *pCalCtxt, uint32_t duration)</td></tr>
<tr class="memdesc:ga5f5a1080209e357636ea9dab3a4d8e52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function helps device to initiate resume from L2 SleepDevice.  <a href="group__group__usbfxstack__usb__common__functions.html#ga5f5a1080209e357636ea9dab3a4d8e52">More...</a><br /></td></tr>
<tr class="separator:ga5f5a1080209e357636ea9dab3a4d8e52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa30aa365f558a6cf06db26e0e8f1cd6c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__usb__common__functions.html#gaa30aa365f558a6cf06db26e0e8f1cd6c">Cy_USBHS_Cal_HsHandleL2SuspendEntry</a> (<a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__cal__ctxt__t">cy_stc_usb_cal_ctxt_t</a> *pCalCtxt, bool keepPllOn)</td></tr>
<tr class="memdesc:gaa30aa365f558a6cf06db26e0e8f1cd6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function Handles Suspend at CAL layer in High speed mode.  <a href="group__group__usbfxstack__usb__common__functions.html#gaa30aa365f558a6cf06db26e0e8f1cd6c">More...</a><br /></td></tr>
<tr class="separator:gaa30aa365f558a6cf06db26e0e8f1cd6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaedcb2a6b720948390f1a4ef1ea5dde4a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__usb__common__functions.html#gaedcb2a6b720948390f1a4ef1ea5dde4a">Cy_USBHS_Cal_FsHandleSuspend</a> (<a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__cal__ctxt__t">cy_stc_usb_cal_ctxt_t</a> *pCalCtxt)</td></tr>
<tr class="memdesc:gaedcb2a6b720948390f1a4ef1ea5dde4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function Handles Suspend at CAL layer in Full speed mode.  <a href="group__group__usbfxstack__usb__common__functions.html#gaedcb2a6b720948390f1a4ef1ea5dde4a">More...</a><br /></td></tr>
<tr class="separator:gaedcb2a6b720948390f1a4ef1ea5dde4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5cc027ca378a7158337cda401a891222"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__usb__common__functions.html#ga5cc027ca378a7158337cda401a891222">Cy_USBHS_Cal_HsHandleL2Resume</a> (<a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__cal__ctxt__t">cy_stc_usb_cal_ctxt_t</a> *pCalCtxt)</td></tr>
<tr class="memdesc:ga5cc027ca378a7158337cda401a891222"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function Handles resume at CAL layer in high speed mode.  <a href="group__group__usbfxstack__usb__common__functions.html#ga5cc027ca378a7158337cda401a891222">More...</a><br /></td></tr>
<tr class="separator:ga5cc027ca378a7158337cda401a891222"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga36cfe1c678e7866932b900b034512a2d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__usb__common__functions.html#ga36cfe1c678e7866932b900b034512a2d">Cy_USBHS_Cal_FsHandleResume</a> (<a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__cal__ctxt__t">cy_stc_usb_cal_ctxt_t</a> *pCalCtxt)</td></tr>
<tr class="memdesc:ga36cfe1c678e7866932b900b034512a2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function Handles resume at CAL layer in full speed mode.  <a href="group__group__usbfxstack__usb__common__functions.html#ga36cfe1c678e7866932b900b034512a2d">More...</a><br /></td></tr>
<tr class="separator:ga36cfe1c678e7866932b900b034512a2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabe11d33d22055e48992d5dc9df7af128"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__usb__common__functions.html#gabe11d33d22055e48992d5dc9df7af128">Cy_USBHS_Cal_IntrHandler</a> (<a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__cal__ctxt__t">cy_stc_usb_cal_ctxt_t</a> *pCalCtxt)</td></tr>
<tr class="memdesc:gabe11d33d22055e48992d5dc9df7af128"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function Handles All interrupt related to controller.  <a href="group__group__usbfxstack__usb__common__functions.html#gabe11d33d22055e48992d5dc9df7af128">More...</a><br /></td></tr>
<tr class="separator:gabe11d33d22055e48992d5dc9df7af128"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3947d7a658aaba60cd80df1bc6344056"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#ga0d79c3063de7043b78fe79bae1e9278a">cy_en_usb_cal_ret_code_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__usb__common__functions.html#ga3947d7a658aaba60cd80df1bc6344056">Cy_USBHS_Cal_EnableReqDevCtrlIntr</a> (<a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__cal__ctxt__t">cy_stc_usb_cal_ctxt_t</a> *pCalCtxt)</td></tr>
<tr class="memdesc:ga3947d7a658aaba60cd80df1bc6344056"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will enable required interrupt under device ctrl reister.  <a href="group__group__usbfxstack__usb__common__functions.html#ga3947d7a658aaba60cd80df1bc6344056">More...</a><br /></td></tr>
<tr class="separator:ga3947d7a658aaba60cd80df1bc6344056"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac23f4abaf8758644d41db48a92a1b7bd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#ga0d79c3063de7043b78fe79bae1e9278a">cy_en_usb_cal_ret_code_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__usb__common__functions.html#gac23f4abaf8758644d41db48a92a1b7bd">Cy_USBHS_Cal_DisableAllDevCtrlIntr</a> (<a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__cal__ctxt__t">cy_stc_usb_cal_ctxt_t</a> *pCalCtxt)</td></tr>
<tr class="memdesc:gac23f4abaf8758644d41db48a92a1b7bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will disable all possible interrupt generated by USB device.  <a href="group__group__usbfxstack__usb__common__functions.html#gac23f4abaf8758644d41db48a92a1b7bd">More...</a><br /></td></tr>
<tr class="separator:gac23f4abaf8758644d41db48a92a1b7bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga366eea9bc1dbb3165ec248f73fc49b59"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#ga0d79c3063de7043b78fe79bae1e9278a">cy_en_usb_cal_ret_code_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__usb__common__functions.html#ga366eea9bc1dbb3165ec248f73fc49b59">Cy_USBHS_Cal_ClearAllDevCtrlIntr</a> (<a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__cal__ctxt__t">cy_stc_usb_cal_ctxt_t</a> *pCalCtxt)</td></tr>
<tr class="memdesc:ga366eea9bc1dbb3165ec248f73fc49b59"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will clear all interrupt bit in device ctrl register.  <a href="group__group__usbfxstack__usb__common__functions.html#ga366eea9bc1dbb3165ec248f73fc49b59">More...</a><br /></td></tr>
<tr class="separator:ga366eea9bc1dbb3165ec248f73fc49b59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8b996e4089a6b771b1a498701995512c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#ga0d79c3063de7043b78fe79bae1e9278a">cy_en_usb_cal_ret_code_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__usb__common__functions.html#ga8b996e4089a6b771b1a498701995512c">Cy_USBHS_Cal_UpdateEpIntrMask</a> (<a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__cal__ctxt__t">cy_stc_usb_cal_ctxt_t</a> *pCalCtxt, uint32_t endpNumber, <a class="el" href="group__group__usbfxstack__usb__common__enums.html#gaaebdfe5d46401ad52420b00ca401e6f8">cy_en_usb_endp_dir_t</a> endpDirection, uint32_t epIntrMask, bool setClear)</td></tr>
<tr class="memdesc:ga8b996e4089a6b771b1a498701995512c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function updates the interrupt mask for an endpoint with the desired values.  <a href="group__group__usbfxstack__usb__common__functions.html#ga8b996e4089a6b771b1a498701995512c">More...</a><br /></td></tr>
<tr class="separator:ga8b996e4089a6b771b1a498701995512c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7841011690ec5ad8dbe841829d20306b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#ga0d79c3063de7043b78fe79bae1e9278a">cy_en_usb_cal_ret_code_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__usb__common__functions.html#ga7841011690ec5ad8dbe841829d20306b">Cy_USBHS_Cal_ClearZlpSlpIntrEnableMask</a> (<a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__cal__ctxt__t">cy_stc_usb_cal_ctxt_t</a> *pCalCtxt, uint32_t endpNum, <a class="el" href="group__group__usbfxstack__usb__common__enums.html#gaaebdfe5d46401ad52420b00ca401e6f8">cy_en_usb_endp_dir_t</a> endpDir, bool zlpSlp)</td></tr>
<tr class="memdesc:ga7841011690ec5ad8dbe841829d20306b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function clears endpoint interrupt for ingress and egress intrrupt and enables respective mask register.  <a href="group__group__usbfxstack__usb__common__functions.html#ga7841011690ec5ad8dbe841829d20306b">More...</a><br /></td></tr>
<tr class="separator:ga7841011690ec5ad8dbe841829d20306b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf44e50a3135ee8273ce087d82c2c91fa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#ga0d79c3063de7043b78fe79bae1e9278a">cy_en_usb_cal_ret_code_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__usb__common__functions.html#gaf44e50a3135ee8273ce087d82c2c91fa">Cy_USBHS_Cal_EnableCtrlSlpIntr</a> (<a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__cal__ctxt__t">cy_stc_usb_cal_ctxt_t</a> *pCalCtxt)</td></tr>
<tr class="memdesc:gaf44e50a3135ee8273ce087d82c2c91fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function enables the SLP_RCVD interrupt for EP0-OUT.  <a href="group__group__usbfxstack__usb__common__functions.html#gaf44e50a3135ee8273ce087d82c2c91fa">More...</a><br /></td></tr>
<tr class="separator:gaf44e50a3135ee8273ce087d82c2c91fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4b36a9828cf153c27c8af3b4a07a09a2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#ga0d79c3063de7043b78fe79bae1e9278a">cy_en_usb_cal_ret_code_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__usb__common__functions.html#ga4b36a9828cf153c27c8af3b4a07a09a2">Cy_USBHS_Cal_DisableCtrlSlpIntr</a> (<a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__cal__ctxt__t">cy_stc_usb_cal_ctxt_t</a> *pCalCtxt)</td></tr>
<tr class="memdesc:ga4b36a9828cf153c27c8af3b4a07a09a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function disable the SLP_RCVD interrupt for EP0-OUT.  <a href="group__group__usbfxstack__usb__common__functions.html#ga4b36a9828cf153c27c8af3b4a07a09a2">More...</a><br /></td></tr>
<tr class="separator:ga4b36a9828cf153c27c8af3b4a07a09a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga61ef4a767f73fb590c763f4dc215c6e0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#ga0d79c3063de7043b78fe79bae1e9278a">cy_en_usb_cal_ret_code_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__usb__common__functions.html#ga61ef4a767f73fb590c763f4dc215c6e0">Cy_USBHS_Cal_EnableEndp</a> (<a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__cal__ctxt__t">cy_stc_usb_cal_ctxt_t</a> *pCalCtxt, uint32_t endpNum, <a class="el" href="group__group__usbfxstack__usb__common__enums.html#gaaebdfe5d46401ad52420b00ca401e6f8">cy_en_usb_endp_dir_t</a> endpDir, bool enable)</td></tr>
<tr class="memdesc:ga61ef4a767f73fb590c763f4dc215c6e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function enables/disable endpoint and set/reset respective interrupt.  <a href="group__group__usbfxstack__usb__common__functions.html#ga61ef4a767f73fb590c763f4dc215c6e0">More...</a><br /></td></tr>
<tr class="separator:ga61ef4a767f73fb590c763f4dc215c6e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga318e82f99894d49e4ee5b2719826d9b2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#ga0d79c3063de7043b78fe79bae1e9278a">cy_en_usb_cal_ret_code_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__usb__common__functions.html#ga318e82f99894d49e4ee5b2719826d9b2">Cy_USBHS_Cal_EndpConfig</a> (<a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__cal__ctxt__t">cy_stc_usb_cal_ctxt_t</a> *pCalCtxt, <a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__endp__config__t">cy_stc_usb_endp_config_t</a> configParam)</td></tr>
<tr class="memdesc:ga318e82f99894d49e4ee5b2719826d9b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function handles configuration of endpoint.  <a href="group__group__usbfxstack__usb__common__functions.html#ga318e82f99894d49e4ee5b2719826d9b2">More...</a><br /></td></tr>
<tr class="separator:ga318e82f99894d49e4ee5b2719826d9b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4ae38bbb375b4b928690a4b1a0fc0d58"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#ga0d79c3063de7043b78fe79bae1e9278a">cy_en_usb_cal_ret_code_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__usb__common__functions.html#ga4ae38bbb375b4b928690a4b1a0fc0d58">Cy_USBHS_Cal_UpdateXferCount</a> (<a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__cal__ctxt__t">cy_stc_usb_cal_ctxt_t</a> *pCalCtxt, uint32_t endpNum, <a class="el" href="group__group__usbfxstack__usb__common__enums.html#gaaebdfe5d46401ad52420b00ca401e6f8">cy_en_usb_endp_dir_t</a> endpDir, uint32_t xferCount)</td></tr>
<tr class="memdesc:ga4ae38bbb375b4b928690a4b1a0fc0d58"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function updates register with transfer count.  <a href="group__group__usbfxstack__usb__common__functions.html#ga4ae38bbb375b4b928690a4b1a0fc0d58">More...</a><br /></td></tr>
<tr class="separator:ga4ae38bbb375b4b928690a4b1a0fc0d58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga58d868ff6ae4dcd0678a1f87bf3b9a3b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#ga0d79c3063de7043b78fe79bae1e9278a">cy_en_usb_cal_ret_code_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__usb__common__functions.html#ga58d868ff6ae4dcd0678a1f87bf3b9a3b">Cy_USBHS_Cal_EndpSetClearNak</a> (<a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__cal__ctxt__t">cy_stc_usb_cal_ctxt_t</a> *pCalCtxt, uint32_t endpNum, <a class="el" href="group__group__usbfxstack__usb__common__enums.html#gaaebdfe5d46401ad52420b00ca401e6f8">cy_en_usb_endp_dir_t</a> endpDir, bool setClear)</td></tr>
<tr class="memdesc:ga58d868ff6ae4dcd0678a1f87bf3b9a3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function enable or disable NAK condition in hw.  <a href="group__group__usbfxstack__usb__common__functions.html#ga58d868ff6ae4dcd0678a1f87bf3b9a3b">More...</a><br /></td></tr>
<tr class="separator:ga58d868ff6ae4dcd0678a1f87bf3b9a3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafbf101b9a4b4dc1fe7b273471e3afda3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#ga0d79c3063de7043b78fe79bae1e9278a">cy_en_usb_cal_ret_code_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__usb__common__functions.html#gafbf101b9a4b4dc1fe7b273471e3afda3">Cy_USBHS_Cal_SetClearNakAll</a> (<a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__cal__ctxt__t">cy_stc_usb_cal_ctxt_t</a> *pCalCtxt, bool setClear)</td></tr>
<tr class="memdesc:gafbf101b9a4b4dc1fe7b273471e3afda3"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function either set or clear NAK for all endpoint.  <a href="group__group__usbfxstack__usb__common__functions.html#gafbf101b9a4b4dc1fe7b273471e3afda3">More...</a><br /></td></tr>
<tr class="separator:gafbf101b9a4b4dc1fe7b273471e3afda3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga705fc19fa8352f83d859478975c307d3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__usb__common__functions.html#ga705fc19fa8352f83d859478975c307d3">Cy_USBHS_Cal_EndpIsNakNrdySet</a> (<a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__cal__ctxt__t">cy_stc_usb_cal_ctxt_t</a> *pCalCtxt, uint32_t endpNumber, <a class="el" href="group__group__usbfxstack__usb__common__enums.html#gaaebdfe5d46401ad52420b00ca401e6f8">cy_en_usb_endp_dir_t</a> endpDirection)</td></tr>
<tr class="memdesc:ga705fc19fa8352f83d859478975c307d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function checks endpoint's status related to NAK bit is set or reset.  <a href="group__group__usbfxstack__usb__common__functions.html#ga705fc19fa8352f83d859478975c307d3">More...</a><br /></td></tr>
<tr class="separator:ga705fc19fa8352f83d859478975c307d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga368c6a300743075228663db03a804c37"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#ga0d79c3063de7043b78fe79bae1e9278a">cy_en_usb_cal_ret_code_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__usb__common__functions.html#ga368c6a300743075228663db03a804c37">Cy_USBHS_Cal_EndpSetClearStall</a> (<a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__cal__ctxt__t">cy_stc_usb_cal_ctxt_t</a> *pCalCtxt, uint32_t endpNum, <a class="el" href="group__group__usbfxstack__usb__common__enums.html#gaaebdfe5d46401ad52420b00ca401e6f8">cy_en_usb_endp_dir_t</a> endpDir, bool setClear)</td></tr>
<tr class="memdesc:ga368c6a300743075228663db03a804c37"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function enable or disable STALL condition in hw.  <a href="group__group__usbfxstack__usb__common__functions.html#ga368c6a300743075228663db03a804c37">More...</a><br /></td></tr>
<tr class="separator:ga368c6a300743075228663db03a804c37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaab7605784f1b0db0700a92566fd11cda"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__usb__common__functions.html#gaab7605784f1b0db0700a92566fd11cda">Cy_USBHS_Cal_EndpIsStallSet</a> (<a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__cal__ctxt__t">cy_stc_usb_cal_ctxt_t</a> *pCalCtxt, uint32_t endpNum, <a class="el" href="group__group__usbfxstack__usb__common__enums.html#gaaebdfe5d46401ad52420b00ca401e6f8">cy_en_usb_endp_dir_t</a> endpDir)</td></tr>
<tr class="memdesc:gaab7605784f1b0db0700a92566fd11cda"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function checks whether the specified endpoint is currently in the STALLed state.  <a href="group__group__usbfxstack__usb__common__functions.html#gaab7605784f1b0db0700a92566fd11cda">More...</a><br /></td></tr>
<tr class="separator:gaab7605784f1b0db0700a92566fd11cda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga29778c9bc2fb8e75b5dcb9648bd15dcf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#ga0d79c3063de7043b78fe79bae1e9278a">cy_en_usb_cal_ret_code_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__usb__common__functions.html#ga29778c9bc2fb8e75b5dcb9648bd15dcf">Cy_USBHS_Cal_FlushEndp</a> (<a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__cal__ctxt__t">cy_stc_usb_cal_ctxt_t</a> *pCalCtxt, uint32_t endpNum, <a class="el" href="group__group__usbfxstack__usb__common__enums.html#gaaebdfe5d46401ad52420b00ca401e6f8">cy_en_usb_endp_dir_t</a> endpDir)</td></tr>
<tr class="memdesc:ga29778c9bc2fb8e75b5dcb9648bd15dcf"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will flush data available in perticular endpoint FIFO.  <a href="group__group__usbfxstack__usb__common__functions.html#ga29778c9bc2fb8e75b5dcb9648bd15dcf">More...</a><br /></td></tr>
<tr class="separator:ga29778c9bc2fb8e75b5dcb9648bd15dcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2ea5a8287848d8da27a9a85f300014a4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#ga0d79c3063de7043b78fe79bae1e9278a">cy_en_usb_cal_ret_code_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__usb__common__functions.html#ga2ea5a8287848d8da27a9a85f300014a4">Cy_USBHS_Cal_FlushAllEndp</a> (<a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__cal__ctxt__t">cy_stc_usb_cal_ctxt_t</a> *pCalCtxt)</td></tr>
<tr class="memdesc:ga2ea5a8287848d8da27a9a85f300014a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will flush data available in all Ingress and egress endpoint FIFO.  <a href="group__group__usbfxstack__usb__common__functions.html#ga2ea5a8287848d8da27a9a85f300014a4">More...</a><br /></td></tr>
<tr class="separator:ga2ea5a8287848d8da27a9a85f300014a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3d74512df96ccfb9af7b42560353a3be"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#ga0d79c3063de7043b78fe79bae1e9278a">cy_en_usb_cal_ret_code_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__usb__common__functions.html#ga3d74512df96ccfb9af7b42560353a3be">Cy_USBHS_Cal_SendEgressZLP</a> (<a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__cal__ctxt__t">cy_stc_usb_cal_ctxt_t</a> *pCalCtxt, uint32_t endpNum)</td></tr>
<tr class="memdesc:ga3d74512df96ccfb9af7b42560353a3be"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function triggers sending of a ZLP on an Egress endpoint.  <a href="group__group__usbfxstack__usb__common__functions.html#ga3d74512df96ccfb9af7b42560353a3be">More...</a><br /></td></tr>
<tr class="separator:ga3d74512df96ccfb9af7b42560353a3be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa952a9e2d5db22702f1d9824f7f3905e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#ga0d79c3063de7043b78fe79bae1e9278a">cy_en_usb_cal_ret_code_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__usb__common__functions.html#gaa952a9e2d5db22702f1d9824f7f3905e">Cy_USBHS_Cal_HandleCtrlOutSlp</a> (<a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__cal__ctxt__t">cy_stc_usb_cal_ctxt_t</a> *pCalCtxt)</td></tr>
<tr class="memdesc:gaa952a9e2d5db22702f1d9824f7f3905e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function clears SLP ingress interrupt.  <a href="group__group__usbfxstack__usb__common__functions.html#gaa952a9e2d5db22702f1d9824f7f3905e">More...</a><br /></td></tr>
<tr class="separator:gaa952a9e2d5db22702f1d9824f7f3905e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9ee6d92fd4206586b0f5a907ff046d77"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#ga0d79c3063de7043b78fe79bae1e9278a">cy_en_usb_cal_ret_code_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__usb__common__functions.html#ga9ee6d92fd4206586b0f5a907ff046d77">Cy_USBHS_Cal_CtrlEndp0DataOutAck</a> (<a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__cal__ctxt__t">cy_stc_usb_cal_ctxt_t</a> *pCalCtxt, bool setClear)</td></tr>
<tr class="memdesc:ga9ee6d92fd4206586b0f5a907ff046d77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data stage ACK for endpoint0 is controlled by this function.  <a href="group__group__usbfxstack__usb__common__functions.html#ga9ee6d92fd4206586b0f5a907ff046d77">More...</a><br /></td></tr>
<tr class="separator:ga9ee6d92fd4206586b0f5a907ff046d77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad65e7dc1465ebf8541049a30743c050e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#ga0d79c3063de7043b78fe79bae1e9278a">cy_en_usb_cal_ret_code_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__usb__common__functions.html#gad65e7dc1465ebf8541049a30743c050e">Cy_USBHS_Cal_SendAckSetupDataStatusStage</a> (<a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__cal__ctxt__t">cy_stc_usb_cal_ctxt_t</a> *pCalCtxt)</td></tr>
<tr class="memdesc:gad65e7dc1465ebf8541049a30743c050e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function update register so that device will send ACK to complete control transfer.  <a href="group__group__usbfxstack__usb__common__functions.html#gad65e7dc1465ebf8541049a30743c050e">More...</a><br /></td></tr>
<tr class="separator:gad65e7dc1465ebf8541049a30743c050e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac09e969f050fbcc9997d92f04843ea34"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__usb__common__functions.html#gac09e969f050fbcc9997d92f04843ea34">Cy_USBHS_Cal_GetRemoteWakeupStatus</a> (<a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__cal__ctxt__t">cy_stc_usb_cal_ctxt_t</a> *pCalCtxt)</td></tr>
<tr class="memdesc:gac09e969f050fbcc9997d92f04843ea34"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns status of L2 remote wakeup in HW.  <a href="group__group__usbfxstack__usb__common__functions.html#gac09e969f050fbcc9997d92f04843ea34">More...</a><br /></td></tr>
<tr class="separator:gac09e969f050fbcc9997d92f04843ea34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaedb9ab2fc0b386244b5aa885a115f318"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__usb__common__functions.html#gaedb9ab2fc0b386244b5aa885a115f318">Cy_USBHS_Cal_GetL1RemoteWakeupStatus</a> (<a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__cal__ctxt__t">cy_stc_usb_cal_ctxt_t</a> *pCalCtxt)</td></tr>
<tr class="memdesc:gaedb9ab2fc0b386244b5aa885a115f318"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns status of L1 remote wakeup in HW.  <a href="group__group__usbfxstack__usb__common__functions.html#gaedb9ab2fc0b386244b5aa885a115f318">More...</a><br /></td></tr>
<tr class="separator:gaedb9ab2fc0b386244b5aa885a115f318"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7f2fc1ed33c68775286b4b694454edb3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#ga0d79c3063de7043b78fe79bae1e9278a">cy_en_usb_cal_ret_code_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__usb__common__functions.html#ga7f2fc1ed33c68775286b4b694454edb3">Cy_USBHS_Cal_SignalRemotWakup</a> (<a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__cal__ctxt__t">cy_stc_usb_cal_ctxt_t</a> *pCalCtxt, bool startEndSignal)</td></tr>
<tr class="memdesc:ga7f2fc1ed33c68775286b4b694454edb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will update register so that device will initiate remote wakeup signaling ie it will try to comeout from L2_SUSPEND.  <a href="group__group__usbfxstack__usb__common__functions.html#ga7f2fc1ed33c68775286b4b694454edb3">More...</a><br /></td></tr>
<tr class="separator:ga7f2fc1ed33c68775286b4b694454edb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5c825bb623438c0a4922e9b7a4426693"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#ga0d79c3063de7043b78fe79bae1e9278a">cy_en_usb_cal_ret_code_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__usb__common__functions.html#ga5c825bb623438c0a4922e9b7a4426693">Cy_USBHS_Cal_SetTestMode</a> (<a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__cal__ctxt__t">cy_stc_usb_cal_ctxt_t</a> *pCalCtxt, <a class="el" href="group__group__usbfxstack__usb__common__enums.html#gaca7d219d5830d2365bfc9523d1a3cd0e">cy_en_usbhs_cal_test_mode_t</a> testMode)</td></tr>
<tr class="memdesc:ga5c825bb623438c0a4922e9b7a4426693"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will update register to setup required test mode.  <a href="group__group__usbfxstack__usb__common__functions.html#ga5c825bb623438c0a4922e9b7a4426693">More...</a><br /></td></tr>
<tr class="separator:ga5c825bb623438c0a4922e9b7a4426693"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga00c6f4e593c4d471b9c4e1ec0bbb9662"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#ga0d79c3063de7043b78fe79bae1e9278a">cy_en_usb_cal_ret_code_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__usb__common__functions.html#ga00c6f4e593c4d471b9c4e1ec0bbb9662">Cy_USBHS_Cal_LpmSetClearNYET</a> (<a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__cal__ctxt__t">cy_stc_usb_cal_ctxt_t</a> *pCalCtxt, bool setClear)</td></tr>
<tr class="memdesc:ga00c6f4e593c4d471b9c4e1ec0bbb9662"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function either set or clear NYET bit for LPM response.  <a href="group__group__usbfxstack__usb__common__functions.html#ga00c6f4e593c4d471b9c4e1ec0bbb9662">More...</a><br /></td></tr>
<tr class="separator:ga00c6f4e593c4d471b9c4e1ec0bbb9662"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga77ac6f8613e2d12dd94256a80b8f793c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#ga0d79c3063de7043b78fe79bae1e9278a">cy_en_usb_cal_ret_code_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__usb__common__functions.html#ga77ac6f8613e2d12dd94256a80b8f793c">Cy_USBHS_Cal_SetControllerSpeed</a> (<a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__cal__ctxt__t">cy_stc_usb_cal_ctxt_t</a> *pCalCtxt, <a class="el" href="group__group__usbfxstack__usb__common__enums.html#ga0355d30a754a1ef18fec29f288f59880">cy_en_usb_speed_t</a> speed)</td></tr>
<tr class="memdesc:ga77ac6f8613e2d12dd94256a80b8f793c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function set controller speed to FS or HS.  <a href="group__group__usbfxstack__usb__common__functions.html#ga77ac6f8613e2d12dd94256a80b8f793c">More...</a><br /></td></tr>
<tr class="separator:ga77ac6f8613e2d12dd94256a80b8f793c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3e321098fc4ec0f7c57467afbe000847"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#ga0d79c3063de7043b78fe79bae1e9278a">cy_en_usb_cal_ret_code_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__usb__common__functions.html#ga3e321098fc4ec0f7c57467afbe000847">Cy_USBHS_Cal_GetDevAddress</a> (<a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__cal__ctxt__t">cy_stc_usb_cal_ctxt_t</a> *pCalCtxt, uint8_t *pDevAddr)</td></tr>
<tr class="memdesc:ga3e321098fc4ec0f7c57467afbe000847"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will get device address assigned by Host.  <a href="group__group__usbfxstack__usb__common__functions.html#ga3e321098fc4ec0f7c57467afbe000847">More...</a><br /></td></tr>
<tr class="separator:ga3e321098fc4ec0f7c57467afbe000847"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0af855ce9d53226ab85b4c3a482a4aed"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#ga0d79c3063de7043b78fe79bae1e9278a">cy_en_usb_cal_ret_code_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__usb__common__functions.html#ga0af855ce9d53226ab85b4c3a482a4aed">Cy_USBHS_Cal_GetLinkActive</a> (<a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__cal__ctxt__t">cy_stc_usb_cal_ctxt_t</a> *pCalCtxt)</td></tr>
<tr class="memdesc:ga0af855ce9d53226ab85b4c3a482a4aed"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function makes sure that the USB 2.x link gets into the L0 state if it is in L1.  <a href="group__group__usbfxstack__usb__common__functions.html#ga0af855ce9d53226ab85b4c3a482a4aed">More...</a><br /></td></tr>
<tr class="separator:ga0af855ce9d53226ab85b4c3a482a4aed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8ac7dc6505e76c005b5bdb05db064bb1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__usb__common__functions.html#ga8ac7dc6505e76c005b5bdb05db064bb1">Cy_USBHS_Cal_SendMsg</a> (<a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__cal__ctxt__t">cy_stc_usb_cal_ctxt_t</a> *pCalCtxt, void *pMsg)</td></tr>
<tr class="memdesc:ga8ac7dc6505e76c005b5bdb05db064bb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function send message to upper layer ie USBD layer.  <a href="group__group__usbfxstack__usb__common__functions.html#ga8ac7dc6505e76c005b5bdb05db064bb1">More...</a><br /></td></tr>
<tr class="separator:ga8ac7dc6505e76c005b5bdb05db064bb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac6f0a2112cf786e800c8da2e5df81922"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#ga0d79c3063de7043b78fe79bae1e9278a">cy_en_usb_cal_ret_code_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__usb__common__functions.html#gac6f0a2112cf786e800c8da2e5df81922">Cy_USBHS_Cal_DeinitPLL</a> (<a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__cal__ctxt__t">cy_stc_usb_cal_ctxt_t</a> *pCalCtxt)</td></tr>
<tr class="memdesc:gac6f0a2112cf786e800c8da2e5df81922"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to de-initialize the PLL in the USBHS block.  <a href="group__group__usbfxstack__usb__common__functions.html#gac6f0a2112cf786e800c8da2e5df81922">More...</a><br /></td></tr>
<tr class="separator:gac6f0a2112cf786e800c8da2e5df81922"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9d790574d6f33073ac8e5ee6e4ee0c37"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#ga0d79c3063de7043b78fe79bae1e9278a">cy_en_usb_cal_ret_code_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__usb__common__functions.html#ga9d790574d6f33073ac8e5ee6e4ee0c37">Cy_USBHS_Cal_InitPLL</a> (<a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__cal__ctxt__t">cy_stc_usb_cal_ctxt_t</a> *pCalCtxt)</td></tr>
<tr class="memdesc:ga9d790574d6f33073ac8e5ee6e4ee0c37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to initialize the PLL in the USBHS block to generate the 480 MHz clock required by the High BandWidth SubSystem for its operation.  <a href="group__group__usbfxstack__usb__common__functions.html#ga9d790574d6f33073ac8e5ee6e4ee0c37">More...</a><br /></td></tr>
<tr class="separator:ga9d790574d6f33073ac8e5ee6e4ee0c37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9f2ce91cc402991e85e6ce7dd503401b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__usb__common__functions.html#ga9f2ce91cc402991e85e6ce7dd503401b">Cy_USBHS_Cal_IsLinkActive</a> (<a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__cal__ctxt__t">cy_stc_usb_cal_ctxt_t</a> *pCalCtxt)</td></tr>
<tr class="memdesc:ga9f2ce91cc402991e85e6ce7dd503401b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether the USB 2.x link is in active (L0) state.  <a href="group__group__usbfxstack__usb__common__functions.html#ga9f2ce91cc402991e85e6ce7dd503401b">More...</a><br /></td></tr>
<tr class="separator:ga9f2ce91cc402991e85e6ce7dd503401b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad1690cf72af4e895c1423fa15718bd4f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#ga0d79c3063de7043b78fe79bae1e9278a">cy_en_usb_cal_ret_code_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__usb__common__functions.html#gad1690cf72af4e895c1423fa15718bd4f">Cy_USBHS_Cal_GetXferCount</a> (<a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__cal__ctxt__t">cy_stc_usb_cal_ctxt_t</a> *pCalCtxt, uint32_t endpNum, <a class="el" href="group__group__usbfxstack__usb__common__enums.html#gaaebdfe5d46401ad52420b00ca401e6f8">cy_en_usb_endp_dir_t</a> endpDir, uint32_t *pCntPending)</td></tr>
<tr class="memdesc:gad1690cf72af4e895c1423fa15718bd4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the remaining transfer count on the specified endpoint.  <a href="group__group__usbfxstack__usb__common__functions.html#gad1690cf72af4e895c1423fa15718bd4f">More...</a><br /></td></tr>
<tr class="separator:gad1690cf72af4e895c1423fa15718bd4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga237a999056772a1d593dd9789d9395af"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#ga0d79c3063de7043b78fe79bae1e9278a">cy_en_usb_cal_ret_code_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__usb__common__functions.html#ga237a999056772a1d593dd9789d9395af">Cy_USBSS_Cal_Init</a> (<a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usbss__cal__ctxt__t">cy_stc_usbss_cal_ctxt_t</a> *pCalCtxt, void *pUsbdCtxt, <a class="el" href="group__group__usbfxstack__usb__common__typedefs.html#gaeb0c3502dfb024979701c241f98ef8b6">cy_usb_cal_msg_callback_t</a> cb)</td></tr>
<tr class="memdesc:ga237a999056772a1d593dd9789d9395af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the USBSS IP and relevant variables.  <a href="group__group__usbfxstack__usb__common__functions.html#ga237a999056772a1d593dd9789d9395af">More...</a><br /></td></tr>
<tr class="separator:ga237a999056772a1d593dd9789d9395af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga85efaaa39c0b6bda13218497e80c6979"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#ga0d79c3063de7043b78fe79bae1e9278a">cy_en_usb_cal_ret_code_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__usb__common__functions.html#ga85efaaa39c0b6bda13218497e80c6979">Cy_USBSS_Cal_Connect</a> (<a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usbss__cal__ctxt__t">cy_stc_usbss_cal_ctxt_t</a> *pCalCtxt, <a class="el" href="group__group__usbfxstack__usb__common__enums.html#ga0355d30a754a1ef18fec29f288f59880">cy_en_usb_speed_t</a> usbSpeed)</td></tr>
<tr class="memdesc:ga85efaaa39c0b6bda13218497e80c6979"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables the USB3 RX terminations for connecting to the host and enables relevant USB LINK and PROTOCOL interrupts.  <a href="group__group__usbfxstack__usb__common__functions.html#ga85efaaa39c0b6bda13218497e80c6979">More...</a><br /></td></tr>
<tr class="separator:ga85efaaa39c0b6bda13218497e80c6979"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga367dcac1778131a9ff33202dc3b0a7b5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__usb__common__functions.html#ga367dcac1778131a9ff33202dc3b0a7b5">Cy_USBSS_Cal_SendMsg</a> (<a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usbss__cal__ctxt__t">cy_stc_usbss_cal_ctxt_t</a> *pCalCtxt, void *pMsg)</td></tr>
<tr class="memdesc:ga367dcac1778131a9ff33202dc3b0a7b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends message to the USBD layer using a callback registered by the user.  <a href="group__group__usbfxstack__usb__common__functions.html#ga367dcac1778131a9ff33202dc3b0a7b5">More...</a><br /></td></tr>
<tr class="separator:ga367dcac1778131a9ff33202dc3b0a7b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacdebe291880500842ab6abfd62550af9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__usb__common__functions.html#gacdebe291880500842ab6abfd62550af9">Cy_USBSS_Cal_IntrHandler</a> (<a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usbss__cal__ctxt__t">cy_stc_usbss_cal_ctxt_t</a> *pCalCtxt)</td></tr>
<tr class="memdesc:gacdebe291880500842ab6abfd62550af9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interrupt Handler function for USB3 IP.  <a href="group__group__usbfxstack__usb__common__functions.html#gacdebe291880500842ab6abfd62550af9">More...</a><br /></td></tr>
<tr class="separator:gacdebe291880500842ab6abfd62550af9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaebd1dfaa99f713a76bf2c4a4de9b1d60"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__usb__common__functions.html#gaebd1dfaa99f713a76bf2c4a4de9b1d60">Cy_USBSS_Cal_WakeupIntrHandler</a> (<a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usbss__cal__ctxt__t">cy_stc_usbss_cal_ctxt_t</a> *pCalCtxt)</td></tr>
<tr class="memdesc:gaebd1dfaa99f713a76bf2c4a4de9b1d60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wakeup Interrupt Handler function for USB3 IP.  <a href="group__group__usbfxstack__usb__common__functions.html#gaebd1dfaa99f713a76bf2c4a4de9b1d60">More...</a><br /></td></tr>
<tr class="separator:gaebd1dfaa99f713a76bf2c4a4de9b1d60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1cfbefb28baeffb6c8e698a57b0e0568"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__usb__common__functions.html#ga1cfbefb28baeffb6c8e698a57b0e0568">Cy_USBSS_Cal_Get_PtmStatus</a> (<a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usbss__cal__ctxt__t">cy_stc_usbss_cal_ctxt_t</a> *pCalCtxt)</td></tr>
<tr class="memdesc:ga1cfbefb28baeffb6c8e698a57b0e0568"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends the PTM STATUS to the USBD layer to repsond to GET_STATUS request.  <a href="group__group__usbfxstack__usb__common__functions.html#ga1cfbefb28baeffb6c8e698a57b0e0568">More...</a><br /></td></tr>
<tr class="separator:ga1cfbefb28baeffb6c8e698a57b0e0568"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf5a08f8e21ebe384dbc6ed132bfab48c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#ga0d79c3063de7043b78fe79bae1e9278a">cy_en_usb_cal_ret_code_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__usb__common__functions.html#gaf5a08f8e21ebe384dbc6ed132bfab48c">Cy_USBSS_Cal_LPMEnable</a> (<a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usbss__cal__ctxt__t">cy_stc_usbss_cal_ctxt_t</a> *pCalCtxt, bool isResume)</td></tr>
<tr class="memdesc:gaf5a08f8e21ebe384dbc6ed132bfab48c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables the USB3 Link layer Low Power Mode Handling.  <a href="group__group__usbfxstack__usb__common__functions.html#gaf5a08f8e21ebe384dbc6ed132bfab48c">More...</a><br /></td></tr>
<tr class="separator:gaf5a08f8e21ebe384dbc6ed132bfab48c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadcfe87ded386bfe5d0b6d58c177cf04b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#ga0d79c3063de7043b78fe79bae1e9278a">cy_en_usb_cal_ret_code_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__usb__common__functions.html#gadcfe87ded386bfe5d0b6d58c177cf04b">Cy_USBSS_Cal_ForceLPMAccept</a> (<a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usbss__cal__ctxt__t">cy_stc_usbss_cal_ctxt_t</a> *pCalCtxt, bool enable)</td></tr>
<tr class="memdesc:gadcfe87ded386bfe5d0b6d58c177cf04b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables the USB3 Link layer to always accept LPM requests going into U1/U2 upon receiving LGO_U1/LGO_U2.  <a href="group__group__usbfxstack__usb__common__functions.html#gadcfe87ded386bfe5d0b6d58c177cf04b">More...</a><br /></td></tr>
<tr class="separator:gadcfe87ded386bfe5d0b6d58c177cf04b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga80c7c96a002982fe9977e6ab661c5c79"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#ga0d79c3063de7043b78fe79bae1e9278a">cy_en_usb_cal_ret_code_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__usb__common__functions.html#ga80c7c96a002982fe9977e6ab661c5c79">Cy_USBSS_Cal_LPMDisable</a> (<a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usbss__cal__ctxt__t">cy_stc_usbss_cal_ctxt_t</a> *pCalCtxt)</td></tr>
<tr class="memdesc:ga80c7c96a002982fe9977e6ab661c5c79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables the USB3 Link layer to disable accepting LPM requests going into U1/U2 upon receiving LGO_U1/LGO_U2.  <a href="group__group__usbfxstack__usb__common__functions.html#ga80c7c96a002982fe9977e6ab661c5c79">More...</a><br /></td></tr>
<tr class="separator:ga80c7c96a002982fe9977e6ab661c5c79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gace832c13695e8f500d229b4abfb8675b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#ga0d79c3063de7043b78fe79bae1e9278a">cy_en_usb_cal_ret_code_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__usb__common__functions.html#gace832c13695e8f500d229b4abfb8675b">Cy_USBSS_Cal_SetLinkPowerState</a> (<a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usbss__cal__ctxt__t">cy_stc_usbss_cal_ctxt_t</a> *pCalCtxt, <a class="el" href="group__group__usbfxstack__usb__common__enums.html#ga35921cf9e1a183014cfa7f5ca2e705bf">cy_en_usbss_lnk_power_mode_t</a> lnkMode)</td></tr>
<tr class="memdesc:gace832c13695e8f500d229b4abfb8675b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forces the USB3 Link layer to a particular Link Power State by sending LGO_Ux requests.  <a href="group__group__usbfxstack__usb__common__functions.html#gace832c13695e8f500d229b4abfb8675b">More...</a><br /></td></tr>
<tr class="separator:gace832c13695e8f500d229b4abfb8675b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7d17873e1586197d887704f733223f9d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__usb__common__functions.html#ga7d17873e1586197d887704f733223f9d">Cy_USBSS_Cal_GetUsbLinkActive</a> (<a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usbss__cal__ctxt__t">cy_stc_usbss_cal_ctxt_t</a> *pCalCtxt)</td></tr>
<tr class="memdesc:ga7d17873e1586197d887704f733223f9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the USB3 Link layer to U0 State if it is in U1/U2 state.  <a href="group__group__usbfxstack__usb__common__functions.html#ga7d17873e1586197d887704f733223f9d">More...</a><br /></td></tr>
<tr class="separator:ga7d17873e1586197d887704f733223f9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab47428ef44f354eed53288ea466ae0b9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#ga0d79c3063de7043b78fe79bae1e9278a">cy_en_usb_cal_ret_code_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__usb__common__functions.html#gab47428ef44f354eed53288ea466ae0b9">Cy_USBSS_Cal_GetLinkPowerState</a> (<a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usbss__cal__ctxt__t">cy_stc_usbss_cal_ctxt_t</a> *pCalCtxt, <a class="el" href="group__group__usbfxstack__usb__common__enums.html#ga35921cf9e1a183014cfa7f5ca2e705bf">cy_en_usbss_lnk_power_mode_t</a> *pMode)</td></tr>
<tr class="memdesc:gab47428ef44f354eed53288ea466ae0b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the Link Power State of the device.  <a href="group__group__usbfxstack__usb__common__functions.html#gab47428ef44f354eed53288ea466ae0b9">More...</a><br /></td></tr>
<tr class="separator:gab47428ef44f354eed53288ea466ae0b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga741a41ece9b8ae08d929e4677a4b3d55"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__usb__common__functions.html#ga741a41ece9b8ae08d929e4677a4b3d55">Cy_USBSS_Cal_ProtSendTp</a> (<a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usbss__cal__ctxt__t">cy_stc_usbss_cal_ctxt_t</a> *pCalCtxt, uint32_t *pTpData)</td></tr>
<tr class="memdesc:ga741a41ece9b8ae08d929e4677a4b3d55"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will send transaction packet.  <a href="group__group__usbfxstack__usb__common__functions.html#ga741a41ece9b8ae08d929e4677a4b3d55">More...</a><br /></td></tr>
<tr class="separator:ga741a41ece9b8ae08d929e4677a4b3d55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5b33e249e2ef805350b20d616c5659f3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#ga0d79c3063de7043b78fe79bae1e9278a">cy_en_usb_cal_ret_code_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__usb__common__functions.html#ga5b33e249e2ef805350b20d616c5659f3">Cy_USBSS_Cal_ProtSendAckTp</a> (<a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usbss__cal__ctxt__t">cy_stc_usbss_cal_ctxt_t</a> *pCalCtxt, uint32_t endpNum, <a class="el" href="group__group__usbfxstack__usb__common__enums.html#gaaebdfe5d46401ad52420b00ca401e6f8">cy_en_usb_endp_dir_t</a> endpDir, uint8_t numP, uint16_t bulkStream)</td></tr>
<tr class="memdesc:ga5b33e249e2ef805350b20d616c5659f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function prepares and send ACK transaction packet.  <a href="group__group__usbfxstack__usb__common__functions.html#ga5b33e249e2ef805350b20d616c5659f3">More...</a><br /></td></tr>
<tr class="separator:ga5b33e249e2ef805350b20d616c5659f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab19609a513659ac7080319c2934152a8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#ga0d79c3063de7043b78fe79bae1e9278a">cy_en_usb_cal_ret_code_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__usb__common__functions.html#gab19609a513659ac7080319c2934152a8">Cy_USBSS_Cal_ProtSendErdyTp</a> (<a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usbss__cal__ctxt__t">cy_stc_usbss_cal_ctxt_t</a> *pCalCtxt, uint32_t endpNum, <a class="el" href="group__group__usbfxstack__usb__common__enums.html#gaaebdfe5d46401ad52420b00ca401e6f8">cy_en_usb_endp_dir_t</a> endpDir, uint8_t numP, uint16_t bulkStream)</td></tr>
<tr class="memdesc:gab19609a513659ac7080319c2934152a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function prepares and send ERDY transaction packet.  <a href="group__group__usbfxstack__usb__common__functions.html#gab19609a513659ac7080319c2934152a8">More...</a><br /></td></tr>
<tr class="separator:gab19609a513659ac7080319c2934152a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6fc94a432de69295249007e974c94345"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#ga0d79c3063de7043b78fe79bae1e9278a">cy_en_usb_cal_ret_code_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__usb__common__functions.html#ga6fc94a432de69295249007e974c94345">Cy_USBSS_Cal_ProtSendZlpTp</a> (<a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usbss__cal__ctxt__t">cy_stc_usbss_cal_ctxt_t</a> *pCalCtxt)</td></tr>
<tr class="memdesc:ga6fc94a432de69295249007e974c94345"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function prepares and send ZLP transaction packet.  <a href="group__group__usbfxstack__usb__common__functions.html#ga6fc94a432de69295249007e974c94345">More...</a><br /></td></tr>
<tr class="separator:ga6fc94a432de69295249007e974c94345"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabb2310786629d43ca74668fbe4a3b506"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#ga0d79c3063de7043b78fe79bae1e9278a">cy_en_usb_cal_ret_code_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__usb__common__functions.html#gabb2310786629d43ca74668fbe4a3b506">Cy_USBSS_Cal_ProtSendNrdyTp</a> (<a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usbss__cal__ctxt__t">cy_stc_usbss_cal_ctxt_t</a> *pCalCtxt, uint32_t endpNum, <a class="el" href="group__group__usbfxstack__usb__common__enums.html#gaaebdfe5d46401ad52420b00ca401e6f8">cy_en_usb_endp_dir_t</a> endpDir, uint16_t bulkStream)</td></tr>
<tr class="memdesc:gabb2310786629d43ca74668fbe4a3b506"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function prepares and send NRDY transaction packet.  <a href="group__group__usbfxstack__usb__common__functions.html#gabb2310786629d43ca74668fbe4a3b506">More...</a><br /></td></tr>
<tr class="separator:gabb2310786629d43ca74668fbe4a3b506"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac852e995c7c1b9acfcfadc30bbb8c2f9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#ga0d79c3063de7043b78fe79bae1e9278a">cy_en_usb_cal_ret_code_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__usb__common__functions.html#gac852e995c7c1b9acfcfadc30bbb8c2f9">Cy_USBSS_Cal_EndpReset</a> (<a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usbss__cal__ctxt__t">cy_stc_usbss_cal_ctxt_t</a> *pCalCtxt, uint32_t endpNum, <a class="el" href="group__group__usbfxstack__usb__common__enums.html#gaaebdfe5d46401ad52420b00ca401e6f8">cy_en_usb_endp_dir_t</a> endpDir)</td></tr>
<tr class="memdesc:gac852e995c7c1b9acfcfadc30bbb8c2f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to reset an endpoint.  <a href="group__group__usbfxstack__usb__common__functions.html#gac852e995c7c1b9acfcfadc30bbb8c2f9">More...</a><br /></td></tr>
<tr class="separator:gac852e995c7c1b9acfcfadc30bbb8c2f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga86046fe28ba4d0995a12834166150e82"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#ga0d79c3063de7043b78fe79bae1e9278a">cy_en_usb_cal_ret_code_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__usb__common__functions.html#ga86046fe28ba4d0995a12834166150e82">Cy_USBSS_Cal_GetSeqNum</a> (<a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usbss__cal__ctxt__t">cy_stc_usbss_cal_ctxt_t</a> *pCalCtxt, uint32_t endpNum, <a class="el" href="group__group__usbfxstack__usb__common__enums.html#gaaebdfe5d46401ad52420b00ca401e6f8">cy_en_usb_endp_dir_t</a> endpDir, uint8_t *pSeqNum)</td></tr>
<tr class="memdesc:ga86046fe28ba4d0995a12834166150e82"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function gets the current value of sequence number for an endpoint.  <a href="group__group__usbfxstack__usb__common__functions.html#ga86046fe28ba4d0995a12834166150e82">More...</a><br /></td></tr>
<tr class="separator:ga86046fe28ba4d0995a12834166150e82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7c61f60b4dc28e446e392bb455ce9a5e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#ga0d79c3063de7043b78fe79bae1e9278a">cy_en_usb_cal_ret_code_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__usb__common__functions.html#ga7c61f60b4dc28e446e392bb455ce9a5e">Cy_USBSS_Cal_SetSeqNum</a> (<a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usbss__cal__ctxt__t">cy_stc_usbss_cal_ctxt_t</a> *pCalCtxt, uint32_t endpNum, <a class="el" href="group__group__usbfxstack__usb__common__enums.html#gaaebdfe5d46401ad52420b00ca401e6f8">cy_en_usb_endp_dir_t</a> endpDir, uint8_t seqNum)</td></tr>
<tr class="memdesc:ga7c61f60b4dc28e446e392bb455ce9a5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function sets value of sequence number in hardware for an endpoint.  <a href="group__group__usbfxstack__usb__common__functions.html#ga7c61f60b4dc28e446e392bb455ce9a5e">More...</a><br /></td></tr>
<tr class="separator:ga7c61f60b4dc28e446e392bb455ce9a5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2adbf6478437ddaff50aeff1b2f4d543"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#ga0d79c3063de7043b78fe79bae1e9278a">cy_en_usb_cal_ret_code_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__usb__common__functions.html#ga2adbf6478437ddaff50aeff1b2f4d543">Cy_USBSS_Cal_GetDevAddress</a> (<a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usbss__cal__ctxt__t">cy_stc_usbss_cal_ctxt_t</a> *pCalCtxt, uint8_t *pDevAddr)</td></tr>
<tr class="memdesc:ga2adbf6478437ddaff50aeff1b2f4d543"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will get device address assigned by Host.  <a href="group__group__usbfxstack__usb__common__functions.html#ga2adbf6478437ddaff50aeff1b2f4d543">More...</a><br /></td></tr>
<tr class="separator:ga2adbf6478437ddaff50aeff1b2f4d543"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6bdfc8cdd81fb31432daebaa33a48abf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#ga0d79c3063de7043b78fe79bae1e9278a">cy_en_usb_cal_ret_code_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__usb__common__functions.html#ga6bdfc8cdd81fb31432daebaa33a48abf">Cy_USBSS_Cal_EndpSetClearStall</a> (<a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usbss__cal__ctxt__t">cy_stc_usbss_cal_ctxt_t</a> *pCalCtxt, uint32_t endpNum, <a class="el" href="group__group__usbfxstack__usb__common__enums.html#gaaebdfe5d46401ad52420b00ca401e6f8">cy_en_usb_endp_dir_t</a> endpDir, bool setClear)</td></tr>
<tr class="memdesc:ga6bdfc8cdd81fb31432daebaa33a48abf"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function enable or disable NRDY condition in hw.  <a href="group__group__usbfxstack__usb__common__functions.html#ga6bdfc8cdd81fb31432daebaa33a48abf">More...</a><br /></td></tr>
<tr class="separator:ga6bdfc8cdd81fb31432daebaa33a48abf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad5247d94b681e640a18c389cc5bdb26f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#ga0d79c3063de7043b78fe79bae1e9278a">cy_en_usb_cal_ret_code_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__usb__common__functions.html#gad5247d94b681e640a18c389cc5bdb26f">Cy_USBSS_Cal_EndpSetClearNrdy</a> (<a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usbss__cal__ctxt__t">cy_stc_usbss_cal_ctxt_t</a> *pCalCtxt, uint32_t endpNum, <a class="el" href="group__group__usbfxstack__usb__common__enums.html#gaaebdfe5d46401ad52420b00ca401e6f8">cy_en_usb_endp_dir_t</a> endpDir, bool setClear)</td></tr>
<tr class="memdesc:gad5247d94b681e640a18c389cc5bdb26f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function enable or disable NRDY condition in hw.  <a href="group__group__usbfxstack__usb__common__functions.html#gad5247d94b681e640a18c389cc5bdb26f">More...</a><br /></td></tr>
<tr class="separator:gad5247d94b681e640a18c389cc5bdb26f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8eaec4aa577d2fc0bf5e6f279faa22bf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#ga0d79c3063de7043b78fe79bae1e9278a">cy_en_usb_cal_ret_code_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__usb__common__functions.html#ga8eaec4aa577d2fc0bf5e6f279faa22bf">Cy_USBSS_Cal_SetClearNrdyAll</a> (<a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usbss__cal__ctxt__t">cy_stc_usbss_cal_ctxt_t</a> *pCalCtxt, bool setClear)</td></tr>
<tr class="memdesc:ga8eaec4aa577d2fc0bf5e6f279faa22bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function enable or disable NRDY condition for all endpopint.  <a href="group__group__usbfxstack__usb__common__functions.html#ga8eaec4aa577d2fc0bf5e6f279faa22bf">More...</a><br /></td></tr>
<tr class="separator:ga8eaec4aa577d2fc0bf5e6f279faa22bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga69fee6dad3726a978cde261215d9b5cb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#ga0d79c3063de7043b78fe79bae1e9278a">cy_en_usb_cal_ret_code_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__usb__common__functions.html#ga69fee6dad3726a978cde261215d9b5cb">Cy_USBSS_Cal_EndpConfig</a> (<a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usbss__cal__ctxt__t">cy_stc_usbss_cal_ctxt_t</a> *pCalCtxt, <a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__endp__config__t">cy_stc_usb_endp_config_t</a> configParam)</td></tr>
<tr class="memdesc:ga69fee6dad3726a978cde261215d9b5cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function handles configuration of endpoint.  <a href="group__group__usbfxstack__usb__common__functions.html#ga69fee6dad3726a978cde261215d9b5cb">More...</a><br /></td></tr>
<tr class="separator:ga69fee6dad3726a978cde261215d9b5cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6fb9d01aaa5a5e17a5290cf3abd3226f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#ga0d79c3063de7043b78fe79bae1e9278a">cy_en_usb_cal_ret_code_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__usb__common__functions.html#ga6fb9d01aaa5a5e17a5290cf3abd3226f">Cy_USBSS_Cal_EndpSetPktsPerBuffer</a> (<a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usbss__cal__ctxt__t">cy_stc_usbss_cal_ctxt_t</a> *pCalCtxt, uint32_t endpNumber, uint8_t pktsPerBuffer)</td></tr>
<tr class="memdesc:ga6fb9d01aaa5a5e17a5290cf3abd3226f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function sets the number of maximum sized packets that can fit into a single DMA buffer for an Ingress endpoint.  <a href="group__group__usbfxstack__usb__common__functions.html#ga6fb9d01aaa5a5e17a5290cf3abd3226f">More...</a><br /></td></tr>
<tr class="separator:ga6fb9d01aaa5a5e17a5290cf3abd3226f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga40ae26797b2a9e62043d5a4921df5471"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#ga0d79c3063de7043b78fe79bae1e9278a">cy_en_usb_cal_ret_code_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__usb__common__functions.html#ga40ae26797b2a9e62043d5a4921df5471">Cy_USBSS_Cal_EndpMapStream</a> (<a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usbss__cal__ctxt__t">cy_stc_usbss_cal_ctxt_t</a> *pCalCtxt, uint32_t endpNumber, <a class="el" href="group__group__usbfxstack__usb__common__enums.html#gaaebdfe5d46401ad52420b00ca401e6f8">cy_en_usb_endp_dir_t</a> endpDirection, uint16_t streamId, uint32_t socketNum)</td></tr>
<tr class="memdesc:ga40ae26797b2a9e62043d5a4921df5471"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function maps an unused USB Ingress/Egress socket to the specified stream associated with a bulk endpoint.  <a href="group__group__usbfxstack__usb__common__functions.html#ga40ae26797b2a9e62043d5a4921df5471">More...</a><br /></td></tr>
<tr class="separator:ga40ae26797b2a9e62043d5a4921df5471"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga61e31d2f33a8e95c87ec0b50902b532e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#ga0d79c3063de7043b78fe79bae1e9278a">cy_en_usb_cal_ret_code_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__usb__common__functions.html#ga61e31d2f33a8e95c87ec0b50902b532e">Cy_USBSS_Cal_EndpUnmapStream</a> (<a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usbss__cal__ctxt__t">cy_stc_usbss_cal_ctxt_t</a> *pCalCtxt, uint32_t endpNum, <a class="el" href="group__group__usbfxstack__usb__common__enums.html#gaaebdfe5d46401ad52420b00ca401e6f8">cy_en_usb_endp_dir_t</a> endpDir, uint32_t socketNum)</td></tr>
<tr class="memdesc:ga61e31d2f33a8e95c87ec0b50902b532e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function unmaps the DMA socket to stream mapping for a bulk endpoint.  <a href="group__group__usbfxstack__usb__common__functions.html#ga61e31d2f33a8e95c87ec0b50902b532e">More...</a><br /></td></tr>
<tr class="separator:ga61e31d2f33a8e95c87ec0b50902b532e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga250aa6fee28c93889e34e6a738282dcd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#ga0d79c3063de7043b78fe79bae1e9278a">cy_en_usb_cal_ret_code_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__usb__common__functions.html#ga250aa6fee28c93889e34e6a738282dcd">Cy_USBSS_Cal_EnableEndp</a> (<a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usbss__cal__ctxt__t">cy_stc_usbss_cal_ctxt_t</a> *pCalCtxt, uint32_t endpNumber, <a class="el" href="group__group__usbfxstack__usb__common__enums.html#gaaebdfe5d46401ad52420b00ca401e6f8">cy_en_usb_endp_dir_t</a> endpDirection, bool enable)</td></tr>
<tr class="memdesc:ga250aa6fee28c93889e34e6a738282dcd"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function enables/disable endpoint and set/reset respective interrupt.  <a href="group__group__usbfxstack__usb__common__functions.html#ga250aa6fee28c93889e34e6a738282dcd">More...</a><br /></td></tr>
<tr class="separator:ga250aa6fee28c93889e34e6a738282dcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabff4770fe13d82f3f3bebfe1accd0897"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#ga0d79c3063de7043b78fe79bae1e9278a">cy_en_usb_cal_ret_code_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__usb__common__functions.html#gabff4770fe13d82f3f3bebfe1accd0897">Cy_USBSS_Cal_SetEpBurstMode</a> (<a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usbss__cal__ctxt__t">cy_stc_usbss_cal_ctxt_t</a> *pCalCtxt, uint32_t endpNumber, <a class="el" href="group__group__usbfxstack__usb__common__enums.html#gaaebdfe5d46401ad52420b00ca401e6f8">cy_en_usb_endp_dir_t</a> endpDirection, bool enable)</td></tr>
<tr class="memdesc:gabff4770fe13d82f3f3bebfe1accd0897"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function enables/disables the MULT (allow burst across multiple DMA buffers) feature for the specified USB endpoints.  <a href="group__group__usbfxstack__usb__common__functions.html#gabff4770fe13d82f3f3bebfe1accd0897">More...</a><br /></td></tr>
<tr class="separator:gabff4770fe13d82f3f3bebfe1accd0897"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac64a75339e3c8afe7aac0ad969a44a8b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#ga0d79c3063de7043b78fe79bae1e9278a">cy_en_usb_cal_ret_code_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__usb__common__functions.html#gac64a75339e3c8afe7aac0ad969a44a8b">Cy_USBSS_Cal_SetEndpRetryOffset</a> (<a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usbss__cal__ctxt__t">cy_stc_usbss_cal_ctxt_t</a> *pCalCtxt, uint32_t endpNumber, uint16_t retryBufOffset)</td></tr>
<tr class="memdesc:gac64a75339e3c8afe7aac0ad969a44a8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function sets the egress endpoint retry buffer offset for Type-2 (CTRL and BULK) endpoints.  <a href="group__group__usbfxstack__usb__common__functions.html#gac64a75339e3c8afe7aac0ad969a44a8b">More...</a><br /></td></tr>
<tr class="separator:gac64a75339e3c8afe7aac0ad969a44a8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac7906db6743acc9bc40421ec001156ab"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#ga0d79c3063de7043b78fe79bae1e9278a">cy_en_usb_cal_ret_code_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__usb__common__functions.html#gac7906db6743acc9bc40421ec001156ab">Cy_USBSS_Cal_UpdateXferCount</a> (<a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usbss__cal__ctxt__t">cy_stc_usbss_cal_ctxt_t</a> *pCalCtxt, uint32_t endpNum, <a class="el" href="group__group__usbfxstack__usb__common__enums.html#gaaebdfe5d46401ad52420b00ca401e6f8">cy_en_usb_endp_dir_t</a> endpDir, uint32_t xferCount)</td></tr>
<tr class="memdesc:gac7906db6743acc9bc40421ec001156ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function updates xfer count in an ndpoint register.  <a href="group__group__usbfxstack__usb__common__functions.html#gac7906db6743acc9bc40421ec001156ab">More...</a><br /></td></tr>
<tr class="separator:gac7906db6743acc9bc40421ec001156ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga12359d9088d69480459d21101f5e022e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#ga0d79c3063de7043b78fe79bae1e9278a">cy_en_usb_cal_ret_code_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__usb__common__functions.html#ga12359d9088d69480459d21101f5e022e">Cy_USBSS_Cal_EnableStatusCtrl</a> (<a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usbss__cal__ctxt__t">cy_stc_usbss_cal_ctxt_t</a> *pCalCtxt, bool enable)</td></tr>
<tr class="memdesc:ga12359d9088d69480459d21101f5e022e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function enable/disable Status Control feature mentioned in PROT_CS register.  <a href="group__group__usbfxstack__usb__common__functions.html#ga12359d9088d69480459d21101f5e022e">More...</a><br /></td></tr>
<tr class="separator:ga12359d9088d69480459d21101f5e022e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3c8cba365500310dc638b1e36cc7f932"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#ga0d79c3063de7043b78fe79bae1e9278a">cy_en_usb_cal_ret_code_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__usb__common__functions.html#ga3c8cba365500310dc638b1e36cc7f932">Cy_USBSS_Cal_ClearStatusClrBusy</a> (<a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usbss__cal__ctxt__t">cy_stc_usbss_cal_ctxt_t</a> *pCalCtxt)</td></tr>
<tr class="memdesc:ga3c8cba365500310dc638b1e36cc7f932"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function write "1" to STATUS_CLR_BUSY which clears the bit to initiate STATUS response.  <a href="group__group__usbfxstack__usb__common__functions.html#ga3c8cba365500310dc638b1e36cc7f932">More...</a><br /></td></tr>
<tr class="separator:ga3c8cba365500310dc638b1e36cc7f932"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga022037eca4b8a56180fa216ec80b03fe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#ga0d79c3063de7043b78fe79bae1e9278a">cy_en_usb_cal_ret_code_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__usb__common__functions.html#ga022037eca4b8a56180fa216ec80b03fe">Cy_USBSS_Cal_SendAckSetupDataStatusStage</a> (<a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usbss__cal__ctxt__t">cy_stc_usbss_cal_ctxt_t</a> *pCalCtxt)</td></tr>
<tr class="memdesc:ga022037eca4b8a56180fa216ec80b03fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function enable HW to send ACK in status stage.  <a href="group__group__usbfxstack__usb__common__functions.html#ga022037eca4b8a56180fa216ec80b03fe">More...</a><br /></td></tr>
<tr class="separator:ga022037eca4b8a56180fa216ec80b03fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga29ddaeff9647bef019a1de3818262b8d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#ga0d79c3063de7043b78fe79bae1e9278a">cy_en_usb_cal_ret_code_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__usb__common__functions.html#ga29ddaeff9647bef019a1de3818262b8d">Cy_USBSS_Cal_FlushEPM</a> (<a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usbss__cal__ctxt__t">cy_stc_usbss_cal_ctxt_t</a> *pCalCtxt, bool force)</td></tr>
<tr class="memdesc:ga29ddaeff9647bef019a1de3818262b8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will flush Ingress and egress both the EPM.  <a href="group__group__usbfxstack__usb__common__functions.html#ga29ddaeff9647bef019a1de3818262b8d">More...</a><br /></td></tr>
<tr class="separator:ga29ddaeff9647bef019a1de3818262b8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa99dc0c852b592d7cd814cbedd986675"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#ga0d79c3063de7043b78fe79bae1e9278a">cy_en_usb_cal_ret_code_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__usb__common__functions.html#gaa99dc0c852b592d7cd814cbedd986675">Cy_USBSS_Cal_FlushEndpSocket</a> (<a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usbss__cal__ctxt__t">cy_stc_usbss_cal_ctxt_t</a> *pCalCtxt, uint32_t endpNum, <a class="el" href="group__group__usbfxstack__usb__common__enums.html#gaaebdfe5d46401ad52420b00ca401e6f8">cy_en_usb_endp_dir_t</a> endpDir)</td></tr>
<tr class="memdesc:gaa99dc0c852b592d7cd814cbedd986675"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will flush socket associated with an endpoint.  <a href="group__group__usbfxstack__usb__common__functions.html#gaa99dc0c852b592d7cd814cbedd986675">More...</a><br /></td></tr>
<tr class="separator:gaa99dc0c852b592d7cd814cbedd986675"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga10fa6eedcea41f7952a00eee608fd878"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#ga0d79c3063de7043b78fe79bae1e9278a">cy_en_usb_cal_ret_code_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__usb__common__functions.html#ga10fa6eedcea41f7952a00eee608fd878">Cy_USBSS_Cal_FlushAllEndpSocket</a> (<a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usbss__cal__ctxt__t">cy_stc_usbss_cal_ctxt_t</a> *pCalCtxt)</td></tr>
<tr class="memdesc:ga10fa6eedcea41f7952a00eee608fd878"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will flush socket associated with all endpoints.  <a href="group__group__usbfxstack__usb__common__functions.html#ga10fa6eedcea41f7952a00eee608fd878">More...</a><br /></td></tr>
<tr class="separator:ga10fa6eedcea41f7952a00eee608fd878"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf6298913ecbaad5e28408bb858cf7553"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#ga0d79c3063de7043b78fe79bae1e9278a">cy_en_usb_cal_ret_code_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__usb__common__functions.html#gaf6298913ecbaad5e28408bb858cf7553">Cy_USBSS_Cal_EnableMainIntr</a> (<a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usbss__cal__ctxt__t">cy_stc_usbss_cal_ctxt_t</a> *pCalCtxt, bool EnableDisable)</td></tr>
<tr class="memdesc:gaf6298913ecbaad5e28408bb858cf7553"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will enable/disable main interrupts.  <a href="group__group__usbfxstack__usb__common__functions.html#gaf6298913ecbaad5e28408bb858cf7553">More...</a><br /></td></tr>
<tr class="separator:gaf6298913ecbaad5e28408bb858cf7553"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2cf1de36f201df94065e330650386217"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#ga0d79c3063de7043b78fe79bae1e9278a">cy_en_usb_cal_ret_code_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__usb__common__functions.html#ga2cf1de36f201df94065e330650386217">Cy_USBSS_Cal_EnableLinkIntr</a> (<a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usbss__cal__ctxt__t">cy_stc_usbss_cal_ctxt_t</a> *pCalCtxt, bool EnableDisable)</td></tr>
<tr class="memdesc:ga2cf1de36f201df94065e330650386217"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will enable/disable link interrupts.  <a href="group__group__usbfxstack__usb__common__functions.html#ga2cf1de36f201df94065e330650386217">More...</a><br /></td></tr>
<tr class="separator:ga2cf1de36f201df94065e330650386217"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2e72483b3db1bc2c7ba9cb05fc200a6a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#ga0d79c3063de7043b78fe79bae1e9278a">cy_en_usb_cal_ret_code_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__usb__common__functions.html#ga2e72483b3db1bc2c7ba9cb05fc200a6a">Cy_USBSS_Cal_EnableProtIntr</a> (<a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usbss__cal__ctxt__t">cy_stc_usbss_cal_ctxt_t</a> *pCalCtxt, bool EnableDisable)</td></tr>
<tr class="memdesc:ga2e72483b3db1bc2c7ba9cb05fc200a6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will enable/disable protocol interrupts.  <a href="group__group__usbfxstack__usb__common__functions.html#ga2e72483b3db1bc2c7ba9cb05fc200a6a">More...</a><br /></td></tr>
<tr class="separator:ga2e72483b3db1bc2c7ba9cb05fc200a6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga90002bb32c65433dc32498bec037e360"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__usb__common__functions.html#ga90002bb32c65433dc32498bec037e360">Cy_USBSS_Cal_EndpIsNakNrdySet</a> (<a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usbss__cal__ctxt__t">cy_stc_usbss_cal_ctxt_t</a> *pCalCtxt, uint32_t endpNum, <a class="el" href="group__group__usbfxstack__usb__common__enums.html#gaaebdfe5d46401ad52420b00ca401e6f8">cy_en_usb_endp_dir_t</a> endpDir)</td></tr>
<tr class="memdesc:ga90002bb32c65433dc32498bec037e360"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function checks whether the specified endpoint is currently in the NRDYed state.  <a href="group__group__usbfxstack__usb__common__functions.html#ga90002bb32c65433dc32498bec037e360">More...</a><br /></td></tr>
<tr class="separator:ga90002bb32c65433dc32498bec037e360"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2c9e719b163d97fb2e7ab4adcd2fd859"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__usb__common__functions.html#ga2c9e719b163d97fb2e7ab4adcd2fd859">Cy_USBSS_Cal_EndpIsStallSet</a> (<a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usbss__cal__ctxt__t">cy_stc_usbss_cal_ctxt_t</a> *pCalCtxt, uint32_t endpNumber, <a class="el" href="group__group__usbfxstack__usb__common__enums.html#gaaebdfe5d46401ad52420b00ca401e6f8">cy_en_usb_endp_dir_t</a> endpDirection)</td></tr>
<tr class="memdesc:ga2c9e719b163d97fb2e7ab4adcd2fd859"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function checks whether the specified endpoint is currently in the STALLed state.  <a href="group__group__usbfxstack__usb__common__functions.html#ga2c9e719b163d97fb2e7ab4adcd2fd859">More...</a><br /></td></tr>
<tr class="separator:ga2c9e719b163d97fb2e7ab4adcd2fd859"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad4e8a7317c5bfcbaca1d2737d2ff3c3a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#ga0d79c3063de7043b78fe79bae1e9278a">cy_en_usb_cal_ret_code_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__usb__common__functions.html#gad4e8a7317c5bfcbaca1d2737d2ff3c3a">Cy_USBSS_Cal_EnableSsDevice</a> (<a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usbss__cal__ctxt__t">cy_stc_usbss_cal_ctxt_t</a> *pCalCtxt, bool enable)</td></tr>
<tr class="memdesc:gad4e8a7317c5bfcbaca1d2737d2ff3c3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function enable/disable USB device in SS mode.  <a href="group__group__usbfxstack__usb__common__functions.html#gad4e8a7317c5bfcbaca1d2737d2ff3c3a">More...</a><br /></td></tr>
<tr class="separator:gad4e8a7317c5bfcbaca1d2737d2ff3c3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaded9ff1dc30cb9ecda87b24167df6f6e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#ga0d79c3063de7043b78fe79bae1e9278a">cy_en_usb_cal_ret_code_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__usb__common__functions.html#gaded9ff1dc30cb9ecda87b24167df6f6e">Cy_USBSS_Cal_DisConnect</a> (<a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usbss__cal__ctxt__t">cy_stc_usbss_cal_ctxt_t</a> *pCalCtxt)</td></tr>
<tr class="memdesc:gaded9ff1dc30cb9ecda87b24167df6f6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function handles disconnect device at CAL layer.  <a href="group__group__usbfxstack__usb__common__functions.html#gaded9ff1dc30cb9ecda87b24167df6f6e">More...</a><br /></td></tr>
<tr class="separator:gaded9ff1dc30cb9ecda87b24167df6f6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9ac0a7f597daad64a41710dcae6ac644"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#ga0d79c3063de7043b78fe79bae1e9278a">cy_en_usb_cal_ret_code_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__usb__common__functions.html#ga9ac0a7f597daad64a41710dcae6ac644">Cy_USBSS_Cal_PTMConfig</a> (<a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usbss__cal__ctxt__t">cy_stc_usbss_cal_ctxt_t</a> *pCalCtxt, bool ptmControl)</td></tr>
<tr class="memdesc:ga9ac0a7f597daad64a41710dcae6ac644"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function handles PTM related configuration.  <a href="group__group__usbfxstack__usb__common__functions.html#ga9ac0a7f597daad64a41710dcae6ac644">More...</a><br /></td></tr>
<tr class="separator:ga9ac0a7f597daad64a41710dcae6ac644"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga59e737b497c5fef98d45e23c958961de"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__usb__common__functions.html#ga59e737b497c5fef98d45e23c958961de">Cy_USBSS_Cal_EnterLinkCompliance</a> (<a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usbss__cal__ctxt__t">cy_stc_usbss_cal_ctxt_t</a> *pCalCtxt)</td></tr>
<tr class="memdesc:ga59e737b497c5fef98d45e23c958961de"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function performs the actions required when the USB LTSSM enters the Compliance state.  <a href="group__group__usbfxstack__usb__common__functions.html#ga59e737b497c5fef98d45e23c958961de">More...</a><br /></td></tr>
<tr class="separator:ga59e737b497c5fef98d45e23c958961de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga45eb794902d82fb81204ec9c714bc2bf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__usb__common__functions.html#ga45eb794902d82fb81204ec9c714bc2bf">Cy_USBSS_Cal_NextCompliancePattern</a> (<a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usbss__cal__ctxt__t">cy_stc_usbss_cal_ctxt_t</a> *pCalCtxt)</td></tr>
<tr class="memdesc:ga45eb794902d82fb81204ec9c714bc2bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function causes the LTSSM to move to the next compliance pattern once a Ping.LFPS has been detected.  <a href="group__group__usbfxstack__usb__common__functions.html#ga45eb794902d82fb81204ec9c714bc2bf">More...</a><br /></td></tr>
<tr class="separator:ga45eb794902d82fb81204ec9c714bc2bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5e0a6a9842c4b76b7199e7847b9a1c10"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__usb__common__functions.html#ga5e0a6a9842c4b76b7199e7847b9a1c10">Cy_USBSS_Cal_ExitLinkCompliance</a> (<a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usbss__cal__ctxt__t">cy_stc_usbss_cal_ctxt_t</a> *pCalCtxt)</td></tr>
<tr class="memdesc:ga5e0a6a9842c4b76b7199e7847b9a1c10"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function performs the required actions when the LTSSM exits the Compliance state due to a Warm Reset.  <a href="group__group__usbfxstack__usb__common__functions.html#ga5e0a6a9842c4b76b7199e7847b9a1c10">More...</a><br /></td></tr>
<tr class="separator:ga5e0a6a9842c4b76b7199e7847b9a1c10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4d5d81193ebdbe0cae106c762d85cfd5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__usb__common__functions.html#ga4d5d81193ebdbe0cae106c762d85cfd5">Cy_USBSS_Cal_SetGen2EBDepth</a> (<a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usbss__cal__ctxt__t">cy_stc_usbss_cal_ctxt_t</a> *pCalCtxt, uint8_t gen2_ebdepth)</td></tr>
<tr class="memdesc:ga4d5d81193ebdbe0cae106c762d85cfd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to update the Elastic Buffer Half Depth setting to be used in Gen2 USB connection.  <a href="group__group__usbfxstack__usb__common__functions.html#ga4d5d81193ebdbe0cae106c762d85cfd5">More...</a><br /></td></tr>
<tr class="separator:ga4d5d81193ebdbe0cae106c762d85cfd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9be60fd522b092a02e235886242afaa1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__usb__common__functions.html#ga9be60fd522b092a02e235886242afaa1">Cy_USBSS_Cal_IsEnabled</a> (<a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usbss__cal__ctxt__t">cy_stc_usbss_cal_ctxt_t</a> *pCalCtxt)</td></tr>
<tr class="memdesc:ga9be60fd522b092a02e235886242afaa1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates whether USB 3.x connection is enabled on the device.  <a href="group__group__usbfxstack__usb__common__functions.html#ga9be60fd522b092a02e235886242afaa1">More...</a><br /></td></tr>
<tr class="separator:ga9be60fd522b092a02e235886242afaa1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadf5c8b3b0cafbaed817e3440b2d1c00f"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__usb__common__functions.html#gadf5c8b3b0cafbaed817e3440b2d1c00f">Cy_USBSS_Cal_MeasureCCVoltage</a> (<a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usbss__cal__ctxt__t">cy_stc_usbss_cal_ctxt_t</a> *pCalCtxt, bool cc2select)</td></tr>
<tr class="memdesc:gadf5c8b3b0cafbaed817e3440b2d1c00f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Measure the voltage on CC line and return the corresponding ADC reading.  <a href="group__group__usbfxstack__usb__common__functions.html#gadf5c8b3b0cafbaed817e3440b2d1c00f">More...</a><br /></td></tr>
<tr class="separator:gadf5c8b3b0cafbaed817e3440b2d1c00f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga32dd04b81939a41a9407227c1fc6fd4a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#ga0d79c3063de7043b78fe79bae1e9278a">cy_en_usb_cal_ret_code_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__usb__common__functions.html#ga32dd04b81939a41a9407227c1fc6fd4a">Cy_USBSS_Cal_SetDmaClkFreq</a> (<a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usbss__cal__ctxt__t">cy_stc_usbss_cal_ctxt_t</a> *pCalCtxt, <a class="el" href="group__group__usbfxstack__hb__dma__enums.html#gaf07a15620aa6ac9a13b4fffef4cf6a8c">cy_en_hbdma_clk_freq_t</a> dmaFreq)</td></tr>
<tr class="memdesc:ga32dd04b81939a41a9407227c1fc6fd4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function which sets the desired DMA clock frequency on the FX3G2 device.  <a href="group__group__usbfxstack__usb__common__functions.html#ga32dd04b81939a41a9407227c1fc6fd4a">More...</a><br /></td></tr>
<tr class="separator:ga32dd04b81939a41a9407227c1fc6fd4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa5afb037192c8eef2e70b9f9e57bf1a7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__usb__common__functions.html#gaa5afb037192c8eef2e70b9f9e57bf1a7">Cy_USBSS_Cal_DeepSleepPrep</a> (<a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usbss__cal__ctxt__t">cy_stc_usbss_cal_ctxt_t</a> *pCalCtxt)</td></tr>
<tr class="memdesc:gaa5afb037192c8eef2e70b9f9e57bf1a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function prepares the USB32DEV controller IP block for entry into deep sleep state.  <a href="group__group__usbfxstack__usb__common__functions.html#gaa5afb037192c8eef2e70b9f9e57bf1a7">More...</a><br /></td></tr>
<tr class="separator:gaa5afb037192c8eef2e70b9f9e57bf1a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga07939514c39ef7faafacaa0bb3e9c477"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__usb__common__functions.html#ga07939514c39ef7faafacaa0bb3e9c477">Cy_USBSS_Cal_DeepSleepExit</a> (<a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usbss__cal__ctxt__t">cy_stc_usbss_cal_ctxt_t</a> *pCalCtxt)</td></tr>
<tr class="memdesc:ga07939514c39ef7faafacaa0bb3e9c477"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function restores the USB32DEV controller IP block state after USB link has resumed from U3 (suspend) state.  <a href="group__group__usbfxstack__usb__common__functions.html#ga07939514c39ef7faafacaa0bb3e9c477">More...</a><br /></td></tr>
<tr class="separator:ga07939514c39ef7faafacaa0bb3e9c477"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0a4f7f0c9590b1899c9d6786aebca0a2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__usb__common__functions.html#ga0a4f7f0c9590b1899c9d6786aebca0a2">Cy_USBSS_Cal_DisableLPMDeviceExit</a> (<a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usbss__cal__ctxt__t">cy_stc_usbss_cal_ctxt_t</a> *pCalCtxt, bool devExitDisable)</td></tr>
<tr class="memdesc:ga0a4f7f0c9590b1899c9d6786aebca0a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to disable support for device initiated exit from USB low power modes completely.  <a href="group__group__usbfxstack__usb__common__functions.html#ga0a4f7f0c9590b1899c9d6786aebca0a2">More...</a><br /></td></tr>
<tr class="separator:ga0a4f7f0c9590b1899c9d6786aebca0a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga24e3cac8dbacb620555a0964b7dc23a9" name="ga24e3cac8dbacb620555a0964b7dc23a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga24e3cac8dbacb620555a0964b7dc23a9">&#9670;&nbsp;</a></span>Cy_USBHS_CalculateEpmAddr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint32_t * Cy_USBHS_CalculateEpmAddr </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>endpNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#gaaebdfe5d46401ad52420b00ca401e6f8">cy_en_usb_endp_dir_t</a>&#160;</td>
          <td class="paramname"><em>endpDirection</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the base address of the Endpoint Memory region corresponding to a USBHSDEV endpoint. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">endpNum</td><td>Endpoint index (valid range is 0 to 15).</td></tr>
    <tr><td class="paramname">endpDirection</td><td>Direction of the endpoint</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The base address of the endpoint memory region for the endpoint. </dd></dl>

</div>
</div>
<a id="ga0938c4349056963283a568dad3864e9d" name="ga0938c4349056963283a568dad3864e9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0938c4349056963283a568dad3864e9d">&#9670;&nbsp;</a></span>Cy_USBD_GetVersion()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t Cy_USBD_GetVersion </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the USBD middleware version information. </p>
<dl class="section return"><dt>Returns</dt><dd>32-bit version information including major, minor, patch and build numbers. </dd></dl>

</div>
</div>
<a id="ga153dcd5f7d32f548cb7f1d2e54740ba7" name="ga153dcd5f7d32f548cb7f1d2e54740ba7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga153dcd5f7d32f548cb7f1d2e54740ba7">&#9670;&nbsp;</a></span>Cy_USB_USBD_Init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#gae84a77ef84aee90fcb7773ad13acab34">cy_en_usbd_ret_code_t</a> Cy_USB_USBD_Init </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pAppCtxt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__usbd__ctxt__t">cy_stc_usb_usbd_ctxt_t</a> *&#160;</td>
          <td class="paramname"><em>pUsbdCtxt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DMAC_Type *&#160;</td>
          <td class="paramname"><em>pCpuDmacBase</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__cal__ctxt__t">cy_stc_usb_cal_ctxt_t</a> *&#160;</td>
          <td class="paramname"><em>pCalCtxt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usbss__cal__ctxt__t">cy_stc_usbss_cal_ctxt_t</a> *&#160;</td>
          <td class="paramname"><em>pSsCalCtxt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__hb__dma__structs.html#structcy__stc__hbdma__mgr__context__t">cy_stc_hbdma_mgr_context_t</a> *&#160;</td>
          <td class="paramname"><em>pHbDmaMgrCtxt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function initializes USBD layer and activates CAL layer initialization function for SS and HS controller. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pAppCtxt</td><td>application layer context pointer</td></tr>
    <tr><td class="paramname">pUsbdCtxt</td><td>USBD layer context pointer.</td></tr>
    <tr><td class="paramname">pCpuDmacBase</td><td>Base address for CPU DMA.</td></tr>
    <tr><td class="paramname">pCalCtxt</td><td>CAL layer context pointer for HS controller.</td></tr>
    <tr><td class="paramname">pSsCalCtxt</td><td>CAL layer context pointer for SS controller.</td></tr>
    <tr><td class="paramname">pHbDmaMgrCtxt</td><td>High Bandwidth DMA MgrCtxt.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CY_USBD_STATUS_SUCCESS if the operation is successful. CY_USBD_STATUS_FAILURE if the opration is failed. </dd></dl>

</div>
</div>
<a id="gabeff2fa14eb96a51603827d920574b52" name="gabeff2fa14eb96a51603827d920574b52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabeff2fa14eb96a51603827d920574b52">&#9670;&nbsp;</a></span>Cy_USBD_RegisterCallback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#gae84a77ef84aee90fcb7773ad13acab34">cy_en_usbd_ret_code_t</a> Cy_USBD_RegisterCallback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__usbd__ctxt__t">cy_stc_usb_usbd_ctxt_t</a> *&#160;</td>
          <td class="paramname"><em>pUsbdCtxt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#ga1d336f8c870e093b9296a003c7ead9ad">cy_en_usb_usbd_cb_t</a>&#160;</td>
          <td class="paramname"><em>callBackType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__typedefs.html#gaf2703fc2b5baa958deb275bf19852376">cy_usb_usbd_callback_t</a>&#160;</td>
          <td class="paramname"><em>callBackFunc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API will be used by application to register required callback. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pUsbdCtxt</td><td>USBD layer context pointer.</td></tr>
    <tr><td class="paramname">callBackType</td><td>Base address for CPU DMA.</td></tr>
    <tr><td class="paramname">callBackFunc</td><td>Base address for DATAWIRE0.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CY_USBD_STATUS_SUCCESS if operation is successful. CY_USBD_STATUS_CTXT_NULL if usbd context is NULL. CY_USBD_STATUS_INVALID_CALLBACK_TYPE if callback type not supported. </dd></dl>

</div>
</div>
<a id="ga7b659598cdbee7177c9324c72cefa73c" name="ga7b659598cdbee7177c9324c72cefa73c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7b659598cdbee7177c9324c72cefa73c">&#9670;&nbsp;</a></span>Cy_USBD_SetDscr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#gae84a77ef84aee90fcb7773ad13acab34">cy_en_usbd_ret_code_t</a> Cy_USBD_SetDscr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__usbd__ctxt__t">cy_stc_usb_usbd_ctxt_t</a> *&#160;</td>
          <td class="paramname"><em>pUsbdCtxt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#gac1532edf4b09382d66f09dc7849aacd1">cy_en_usb_set_dscr_type_t</a>&#160;</td>
          <td class="paramname"><em>dscrType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>dscrIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>pDscr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API will be used by application to provide various standard descriptors to USBD layer and USBD layer will use this descriptor in "fast enumeration". </p>
<p >It is callers responsibility to provide proper descriptor with right index.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pUsbdCtxt</td><td>USBD layer context pointer.</td></tr>
    <tr><td class="paramname">dscrType</td><td>Type of descriptor.</td></tr>
    <tr><td class="paramname">dscrIndex</td><td>Descriptor Index.</td></tr>
    <tr><td class="paramname">pDscr</td><td>Pointer to descriptor data based on type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CY_USBD_STATUS_SUCCESS if operation is successful. CY_USBD_STATUS_CTXT_NULL if usbd context is NULL. CY_USBD_STATUS_BAD_PARAM if pointer to descriptor is NULL. CY_USBD_STATUS_INVALID_DSCR_TYPE if descriptor type not supported. </dd></dl>

</div>
</div>
<a id="ga3612f6d61611a49d62c68bb9f1c52de0" name="ga3612f6d61611a49d62c68bb9f1c52de0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3612f6d61611a49d62c68bb9f1c52de0">&#9670;&nbsp;</a></span>Cy_USBD_GetDeviceSpeed()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#ga0355d30a754a1ef18fec29f288f59880">cy_en_usb_speed_t</a> Cy_USBD_GetDeviceSpeed </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__usbd__ctxt__t">cy_stc_usb_usbd_ctxt_t</a> *&#160;</td>
          <td class="paramname"><em>pUsbdCtxt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API returns device's operating speed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pUsbdCtxt</td><td>USBD layer context pointer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CY_USBD_USB_DEV_NOT_CONNECTED if device is not connected. cy_en_usb_speed_t speed of device. </dd></dl>

</div>
</div>
<a id="gac02ea1c6c587c0d885652a276fa59797" name="gac02ea1c6c587c0d885652a276fa59797"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac02ea1c6c587c0d885652a276fa59797">&#9670;&nbsp;</a></span>Cy_USBD_SetDeviceSpeed()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cy_USBD_SetDeviceSpeed </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__usbd__ctxt__t">cy_stc_usb_usbd_ctxt_t</a> *&#160;</td>
          <td class="paramname"><em>pUsbdCtxt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#ga0355d30a754a1ef18fec29f288f59880">cy_en_usb_speed_t</a>&#160;</td>
          <td class="paramname"><em>speed</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API force operating speed of dvice. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pUsbdCtxt</td><td>USBD layer context pointer.</td></tr>
    <tr><td class="paramname">speed</td><td>speed of device. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gac752cde7aa85499f41d4cda76a1882dd" name="gac752cde7aa85499f41d4cda76a1882dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac752cde7aa85499f41d4cda76a1882dd">&#9670;&nbsp;</a></span>Cy_USBD_SetDeviceSpeedAtUSBDOnly()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cy_USBD_SetDeviceSpeedAtUSBDOnly </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__usbd__ctxt__t">cy_stc_usb_usbd_ctxt_t</a> *&#160;</td>
          <td class="paramname"><em>pUsbdCtxt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#ga0355d30a754a1ef18fec29f288f59880">cy_en_usb_speed_t</a>&#160;</td>
          <td class="paramname"><em>speed</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API is used to set device speed only at USBD layer. </p>
<p >This API should be used when application wants to fetch different speed dependent data even before enumaration is done. During enumeration speed field will be overwritten at USBD layer. It is application's responsibility to pass right speed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pUsbdCtxt</td><td>USBD layer context pointer.</td></tr>
    <tr><td class="paramname">speed</td><td>speed of device. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga86dc8e2881413befb5eb131a7ad8da36" name="ga86dc8e2881413befb5eb131a7ad8da36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga86dc8e2881413befb5eb131a7ad8da36">&#9670;&nbsp;</a></span>Cy_USBD_GetDeviceState()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#ga371db4682d00725909b7eb8edc0f7767">cy_en_usb_device_state_t</a> Cy_USBD_GetDeviceState </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__usbd__ctxt__t">cy_stc_usb_usbd_ctxt_t</a> *&#160;</td>
          <td class="paramname"><em>pUsbdCtxt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API returns present state of device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pUsbdCtxt</td><td>USBD layer context pointer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CY_USB_DEVICE_STATE_INVALID if usbd context NULL. cy_en_usb_device_state_t present state of device. </dd></dl>

</div>
</div>
<a id="ga6dbf88f3739d33ecd6a2e754bb6649a3" name="ga6dbf88f3739d33ecd6a2e754bb6649a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6dbf88f3739d33ecd6a2e754bb6649a3">&#9670;&nbsp;</a></span>Cy_USBD_FindEndp0MaxPktSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#gae84a77ef84aee90fcb7773ad13acab34">cy_en_usbd_ret_code_t</a> Cy_USBD_FindEndp0MaxPktSize </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>pDevDscr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#ga0355d30a754a1ef18fec29f288f59880">cy_en_usb_speed_t</a>&#160;</td>
          <td class="paramname"><em>devSpeed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>pMaxPktSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API finds endpoint 0 max packet size from device descriptor. </p>
<p >device descriptors are different at different speed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pDevDscr</td><td>Pointer to device descriptor.</td></tr>
    <tr><td class="paramname">devSpeed</td><td>Speed of device for which endpoint 0 size is required.</td></tr>
    <tr><td class="paramname">pMaxPktSize</td><td>Max packet size of endpoint 0 will be stored here.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CY_USBD_STATUS_SUCCESS if operation is successful. CY_USBD_STATUS_BAD_PARAM in all other case. cy_en_usb_device_state_t present state of device. </dd></dl>

</div>
</div>
<a id="ga56166c586e0944a1f4a305c7b6bcc49c" name="ga56166c586e0944a1f4a305c7b6bcc49c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga56166c586e0944a1f4a305c7b6bcc49c">&#9670;&nbsp;</a></span>Cy_USBD_GetLpmBosUSBExt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#gae84a77ef84aee90fcb7773ad13acab34">cy_en_usbd_ret_code_t</a> Cy_USBD_GetLpmBosUSBExt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__usbd__ctxt__t">cy_stc_usb_usbd_ctxt_t</a> *&#160;</td>
          <td class="paramname"><em>pUsbdCtxt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>pLpmSupp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get information about LPM support from USB ext descriptor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pUsbdCtxt</td><td>USBD layer context pointer.</td></tr>
    <tr><td class="paramname">pLpmSupp</td><td>Information about LPM support is stored here.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CY_USBD_STATUS_SUCCESS if operation is successful. CY_USBD_STATUS_CTXT_NULL if usbd context is NULL. CY_USBD_STATUS_PTR_NULL if BOS descriptor is not register OR pAttribute is NULL. CY_USBD_STATUS_FAILURE in all other cases. </dd></dl>

</div>
</div>
<a id="ga3f98c9e790c257068f472fddf04b2c33" name="ga3f98c9e790c257068f472fddf04b2c33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3f98c9e790c257068f472fddf04b2c33">&#9670;&nbsp;</a></span>Cy_USBD_GetAttributeBosUSBExt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#gae84a77ef84aee90fcb7773ad13acab34">cy_en_usbd_ret_code_t</a> Cy_USBD_GetAttributeBosUSBExt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__usbd__ctxt__t">cy_stc_usb_usbd_ctxt_t</a> *&#160;</td>
          <td class="paramname"><em>pUsbdCtxt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>pAttribute</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get attribute from USB ext descriptor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pUsbdCtxt</td><td>USBD layer context pointer.</td></tr>
    <tr><td class="paramname">pAttribute</td><td>Required information related to attribute will be stored here.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CY_USBD_STATUS_SUCCESS if operation is successful. CY_USBD_STATUS_CTXT_NULL if usbd context is NULL. CY_USBD_STATUS_PTR_NULL if BOS descriptor is not register OR pAttribute is NULL. CY_USBD_STATUS_FAILURE in all other cases. </dd></dl>

</div>
</div>
<a id="gabbfe7a2b518c1af086452f9672150f52" name="gabbfe7a2b518c1af086452f9672150f52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabbfe7a2b518c1af086452f9672150f52">&#9670;&nbsp;</a></span>Cy_USBD_GetAttributeBosSS()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#gae84a77ef84aee90fcb7773ad13acab34">cy_en_usbd_ret_code_t</a> Cy_USBD_GetAttributeBosSS </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__usbd__ctxt__t">cy_stc_usb_usbd_ctxt_t</a> *&#160;</td>
          <td class="paramname"><em>pUsbdCtxt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>pAttribute</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get attribute from Super speed BoS descriptor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pUsbdCtxt</td><td>USBD layer context pointer.</td></tr>
    <tr><td class="paramname">pAttribute</td><td>Attribute field from BOS descriptor will be stored here.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CY_USBD_STATUS_SUCCESS if operation is successful. CY_USBD_STATUS_CTXT_NULL if usbd context is NULL. CY_USBD_STATUS_PTR_NULL if BOS descriptor is not registered OR pAttribute is NULL. CY_USBD_STATUS_FAILURE in all other cases. </dd></dl>

</div>
</div>
<a id="gabc7bf2f49deedf4ead753702ddf49c58" name="gabc7bf2f49deedf4ead753702ddf49c58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabc7bf2f49deedf4ead753702ddf49c58">&#9670;&nbsp;</a></span>Cy_USBD_GetSpeedSuppBosSS()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#gae84a77ef84aee90fcb7773ad13acab34">cy_en_usbd_ret_code_t</a> Cy_USBD_GetSpeedSuppBosSS </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__usbd__ctxt__t">cy_stc_usb_usbd_ctxt_t</a> *&#160;</td>
          <td class="paramname"><em>pUsbdCtxt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>pSpeedSupp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get Speed supported from Super speed descriptor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pUsbdCtxt</td><td>USBD layer context pointer.</td></tr>
    <tr><td class="paramname">pSpeedSupp</td><td>speed information is stored here.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CY_USBD_STATUS_SUCCESS if operation is successful. CY_USBD_STATUS_CTXT_NULL if usbd context is NULL. CY_USBD_STATUS_PTR_NULL if BOS descriptor is not registered OR pAttribute is NULL. CY_USBD_STATUS_FAILURE in all other cases. </dd></dl>

</div>
</div>
<a id="ga4b9f2c7fe1f9153344ef7a5adde069a4" name="ga4b9f2c7fe1f9153344ef7a5adde069a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4b9f2c7fe1f9153344ef7a5adde069a4">&#9670;&nbsp;</a></span>Cy_USBD_GetU1U2ExitLatBosSS()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#gae84a77ef84aee90fcb7773ad13acab34">cy_en_usbd_ret_code_t</a> Cy_USBD_GetU1U2ExitLatBosSS </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__usbd__ctxt__t">cy_stc_usb_usbd_ctxt_t</a> *&#160;</td>
          <td class="paramname"><em>pUsbdCtxt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>pU1ExitLat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t *&#160;</td>
          <td class="paramname"><em>pU2ExitLat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get U1 and U2 exit latency from Super speed BoS descriptor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pUsbdCtxt</td><td>USBD layer context pointer.</td></tr>
    <tr><td class="paramname">pU1ExitLat</td><td>U1 exit latency will be stored here.</td></tr>
    <tr><td class="paramname">pU2ExitLat</td><td>U2 exit latency will be stored here.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CY_USBD_STATUS_SUCCESS if operation is successful. CY_USBD_STATUS_CTXT_NULL if usbd context is NULL. CY_USBD_STATUS_PTR_NULL if BOS descriptor is not registered OR pAttribute is NULL. CY_USBD_STATUS_FAILURE in all other cases. </dd></dl>

</div>
</div>
<a id="ga9201b4bcf9999d3bb01e137dd648c9d6" name="ga9201b4bcf9999d3bb01e137dd648c9d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9201b4bcf9999d3bb01e137dd648c9d6">&#9670;&nbsp;</a></span>Cy_USBD_GetAttributeBosSSP()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#gae84a77ef84aee90fcb7773ad13acab34">cy_en_usbd_ret_code_t</a> Cy_USBD_GetAttributeBosSSP </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__usbd__ctxt__t">cy_stc_usb_usbd_ctxt_t</a> *&#160;</td>
          <td class="paramname"><em>pUsbdCtxt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>pAttribute</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get attribute from Super speed plus descriptor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pUsbdCtxt</td><td>USBD layer context pointer.</td></tr>
    <tr><td class="paramname">pAttribute</td><td>attribute will be store here.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CY_USBD_STATUS_SUCCESS if operation is successful. CY_USBD_STATUS_CTXT_NULL if usbd context is NULL. CY_USBD_STATUS_PTR_NULL if BOS descriptor is not registered. CY_USBD_STATUS_FAILURE in all other cases. </dd></dl>

</div>
</div>
<a id="ga930c19b3fb60589b8e5cd471c8048a28" name="ga930c19b3fb60589b8e5cd471c8048a28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga930c19b3fb60589b8e5cd471c8048a28">&#9670;&nbsp;</a></span>Cy_USBD_GetFunctSupportBosSSP()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#gae84a77ef84aee90fcb7773ad13acab34">cy_en_usbd_ret_code_t</a> Cy_USBD_GetFunctSupportBosSSP </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__usbd__ctxt__t">cy_stc_usb_usbd_ctxt_t</a> *&#160;</td>
          <td class="paramname"><em>pUsbdCtxt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>pFuncSupp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get functionality supported from Super speed plus descriptor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pUsbdCtxt</td><td>USBD layer context pointer.</td></tr>
    <tr><td class="paramname">pFuncSupp</td><td>Information about functionality supported is stored here.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CY_USBD_STATUS_SUCCESS if operation is successful. CY_USBD_STATUS_CTXT_NULL if usbd context is NULL. CY_USBD_STATUS_PTR_NULL if BOS descriptor is not registered. CY_USBD_STATUS_FAILURE in all other cases. </dd></dl>

</div>
</div>
<a id="ga593ef17222bff4f6b8d4315b488fdbb5" name="ga593ef17222bff4f6b8d4315b488fdbb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga593ef17222bff4f6b8d4315b488fdbb5">&#9670;&nbsp;</a></span>Cy_USBD_isCfgValid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Cy_USBD_isCfgValid </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>cfgNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>pCfgDscr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function checks validity of given configuration. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cfgNum</td><td>Configuration Number.</td></tr>
    <tr><td class="paramname">pCfgDscr</td><td>pointer to configuration descriptor.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if config is valid. FALSE if config is not valid. </dd></dl>

</div>
</div>
<a id="gae00d4cf55d463b39e38711a24fb0ec41" name="gae00d4cf55d463b39e38711a24fb0ec41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae00d4cf55d463b39e38711a24fb0ec41">&#9670;&nbsp;</a></span>Cy_USB_USBD_GetActiveCfgNum()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#gae84a77ef84aee90fcb7773ad13acab34">cy_en_usbd_ret_code_t</a> Cy_USB_USBD_GetActiveCfgNum </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__usbd__ctxt__t">cy_stc_usb_usbd_ctxt_t</a> *&#160;</td>
          <td class="paramname"><em>pUsbdCtxt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>pCfgNum</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API called by application to know active configuration number. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pUsbdCtxt</td><td>USBD layer context pointer.</td></tr>
    <tr><td class="paramname">pCfgNum</td><td>config number will be stored here.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CY_USBD_STATUS_SUCCESS if operation is successful. CY_USBD_STATUS_CTXT_NULL if usbd context is NULL. </dd></dl>

</div>
</div>
<a id="gad988c9830f6031995a7186195dda9ffb" name="gad988c9830f6031995a7186195dda9ffb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad988c9830f6031995a7186195dda9ffb">&#9670;&nbsp;</a></span>Cy_USB_USBD_GetActiveCfgDscr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t * Cy_USB_USBD_GetActiveCfgDscr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__usbd__ctxt__t">cy_stc_usb_usbd_ctxt_t</a> *&#160;</td>
          <td class="paramname"><em>pUsbdCtxt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API called by application to get active configuration descriptor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pUsbdCtxt</td><td>USBD layer context pointer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to active configuration descriptor. </dd></dl>

</div>
</div>
<a id="gac502fe8d6a40cf3c4808bf7ba54e6dac" name="gac502fe8d6a40cf3c4808bf7ba54e6dac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac502fe8d6a40cf3c4808bf7ba54e6dac">&#9670;&nbsp;</a></span>Cy_USBD_FindNumOfIntf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t Cy_USBD_FindNumOfIntf </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>pCfgDscr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function finds number of interface supported in given configation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pCfgDscr</td><td>pointer to configuration descriptor.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0x00 if Configuration descriptor is NULL. Number of interface supported by configuration. </dd></dl>

</div>
</div>
<a id="gaef5256f41663a524a551ef0586b5070a" name="gaef5256f41663a524a551ef0586b5070a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaef5256f41663a524a551ef0586b5070a">&#9670;&nbsp;</a></span>Cy_USBD_FindSelfPower()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Cy_USBD_FindSelfPower </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>pCfgDscr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function finds device supports Self power or BUS power. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pCfgDscr</td><td>pointer to configuration descriptor.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if device supports self power. FALSE if device supports only BUS power. </dd></dl>

</div>
</div>
<a id="ga2a55dc757997ab0c846776f59c386a4e" name="ga2a55dc757997ab0c846776f59c386a4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2a55dc757997ab0c846776f59c386a4e">&#9670;&nbsp;</a></span>Cy_USBD_FindRemoteWakeupAbility()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Cy_USBD_FindRemoteWakeupAbility </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>pCfgDscr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function finds device supports remote wakeup or not. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pCfgDscr</td><td>pointer to configuration descriptor.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if device supports remote wakeup. FALSE if device does not support remote wakeup. </dd></dl>

</div>
</div>
<a id="ga2160e5a9cddb1b4eb4a7191e57e8e59a" name="ga2160e5a9cddb1b4eb4a7191e57e8e59a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2160e5a9cddb1b4eb4a7191e57e8e59a">&#9670;&nbsp;</a></span>Cy_USBD_GetRemoteWakeupStatus()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Cy_USBD_GetRemoteWakeupStatus </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__usbd__ctxt__t">cy_stc_usb_usbd_ctxt_t</a> *&#160;</td>
          <td class="paramname"><em>pUsbdCtxt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function checks L2 remote wakeup status and return information. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pUsbdCtxt</td><td>USBD layer context pointer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if remote wakeup enabled in HW register. FALSE if remote wakeup disabled in HW register. </dd></dl>

</div>
</div>
<a id="ga4991ac9c1d2f156fbfa00aec50e1711f" name="ga4991ac9c1d2f156fbfa00aec50e1711f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4991ac9c1d2f156fbfa00aec50e1711f">&#9670;&nbsp;</a></span>Cy_USBD_SignalRemoteWakeup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cy_USBD_SignalRemoteWakeup </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__usbd__ctxt__t">cy_stc_usb_usbd_ctxt_t</a> *&#160;</td>
          <td class="paramname"><em>pUsbdCtxt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>startEnd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function triggers HW to start/end remotewakeup signaling. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pUsbdCtxt</td><td>USBD layer context pointer.</td></tr>
    <tr><td class="paramname">startEnd</td><td>True to start signaling and false to end signaling. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga90da5cda2e1aa5ef41fba534270a8dad" name="ga90da5cda2e1aa5ef41fba534270a8dad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga90da5cda2e1aa5ef41fba534270a8dad">&#9670;&nbsp;</a></span>Cy_USBD_GetIntfDscr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t * Cy_USBD_GetIntfDscr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__usbd__ctxt__t">cy_stc_usb_usbd_ctxt_t</a> *&#160;</td>
          <td class="paramname"><em>pUsbdCtxt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>intfNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>altSetting</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function called by application to get interface descriptor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pUsbdCtxt</td><td>USBD layer context pointer.</td></tr>
    <tr><td class="paramname">intfNum</td><td>Interface number.</td></tr>
    <tr><td class="paramname">altSetting</td><td>Alternate setting number.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NULL if USBD context pointer is NULL. pointer to Interface descriptor. </dd></dl>

</div>
</div>
<a id="ga4ca85038a7418ef62f6b1bdc1df65a84" name="ga4ca85038a7418ef62f6b1bdc1df65a84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4ca85038a7418ef62f6b1bdc1df65a84">&#9670;&nbsp;</a></span>Cy_USBD_isIntfValid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Cy_USBD_isIntfValid </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>intf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>pCfgDscr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function checks given interface is part of configuration descriptor or not. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">intf</td><td>Interface number.</td></tr>
    <tr><td class="paramname">pCfgDscr</td><td>pointer to configuration descriptor.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if given interfae number is part of configuration descriptor. FALSEif given interface is not part of configuration descriptor. </dd></dl>

</div>
</div>
<a id="ga40ac2f7b5ff37fdd621b2b5b6caa96c9" name="ga40ac2f7b5ff37fdd621b2b5b6caa96c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga40ac2f7b5ff37fdd621b2b5b6caa96c9">&#9670;&nbsp;</a></span>Cy_USBD_FindNumOfEndp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t Cy_USBD_FindNumOfEndp </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>pIntfDscr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function gives number of Endpoints supported by given interface. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pIntfDscr</td><td>pointer to interface descriptor.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0x00 if interface descriptor is NULL. Number of endpoints. </dd></dl>

</div>
</div>
<a id="ga1a7df92a3bc3fb0fb097bc56efb29711" name="ga1a7df92a3bc3fb0fb097bc56efb29711"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1a7df92a3bc3fb0fb097bc56efb29711">&#9670;&nbsp;</a></span>Cy_USBD_GetEndpDscr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t * Cy_USBD_GetEndpDscr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__usbd__ctxt__t">cy_stc_usb_usbd_ctxt_t</a> *&#160;</td>
          <td class="paramname"><em>pUsbdCtxt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>pIntfDscr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function to fetch endpoint descriptor for a given interface descriptor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pUsbdCtxt</td><td>USBD layer context pointer.</td></tr>
    <tr><td class="paramname">pIntfDscr</td><td>pointer to interface descriptor.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NULL if any of the parameter is NULL. Pointer to endpoint descriptors. </dd></dl>

</div>
</div>
<a id="gafc517870de13bda5fe23540253903db8" name="gafc517870de13bda5fe23540253903db8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafc517870de13bda5fe23540253903db8">&#9670;&nbsp;</a></span>Cy_USBD_GetSsEndpCompDscr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t * Cy_USBD_GetSsEndpCompDscr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__usbd__ctxt__t">cy_stc_usb_usbd_ctxt_t</a> *&#160;</td>
          <td class="paramname"><em>pUsbdCtxt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>pEndpDscr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function to fetch super speed endpoint companion descriptor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pUsbdCtxt</td><td>USBD layer context pointer.</td></tr>
    <tr><td class="paramname">pEndpDscr</td><td>pointer to endpoint descriptor.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NULL if any of the parameter is NULL. Pointer to endpoint companion descriptors. </dd></dl>

</div>
</div>
<a id="ga54ead8b2424e1d1d74b7dc391ec32e45" name="ga54ead8b2424e1d1d74b7dc391ec32e45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga54ead8b2424e1d1d74b7dc391ec32e45">&#9670;&nbsp;</a></span>Cy_USBD_GetSspIsoCompDscr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t * Cy_USBD_GetSspIsoCompDscr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__usbd__ctxt__t">cy_stc_usb_usbd_ctxt_t</a> *&#160;</td>
          <td class="paramname"><em>pUsbdCtxt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>pCompDscr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function to fetch super speed plus Iso endpoint companion descriptor from given companion descriptor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pUsbdCtxt</td><td>USBD layer context pointer.</td></tr>
    <tr><td class="paramname">pCompDscr</td><td>pointer to endpoint companion descriptor.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NULL if any of the parameter is NULL. Pointer to Iso endpoint companion descriptors. </dd></dl>

</div>
</div>
<a id="ga7e7dc77a42c929abd75fb8421749adfc" name="ga7e7dc77a42c929abd75fb8421749adfc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7e7dc77a42c929abd75fb8421749adfc">&#9670;&nbsp;</a></span>Cy_USBD_GetSspIsoEndpCompDscr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t * Cy_USBD_GetSspIsoEndpCompDscr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__usbd__ctxt__t">cy_stc_usb_usbd_ctxt_t</a> *&#160;</td>
          <td class="paramname"><em>pUsbdCtxt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>pEndpDscr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function to fetch super speed plus Iso endpoint companion descriptor from given endpoint descriptor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pUsbdCtxt</td><td>USBD layer context pointer.</td></tr>
    <tr><td class="paramname">pEndpDscr</td><td>pointer to endpoint descriptor.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NULL if any of the parameter is NULL. Pointer to super speed plus Iso endpoint companion descriptors. </dd></dl>

</div>
</div>
<a id="ga4da87a7c1473dc412193aedb67548a2e" name="ga4da87a7c1473dc412193aedb67548a2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4da87a7c1473dc412193aedb67548a2e">&#9670;&nbsp;</a></span>Cy_USB_USBD_GetActiveAltSetting()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#gae84a77ef84aee90fcb7773ad13acab34">cy_en_usbd_ret_code_t</a> Cy_USB_USBD_GetActiveAltSetting </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__usbd__ctxt__t">cy_stc_usb_usbd_ctxt_t</a> *&#160;</td>
          <td class="paramname"><em>pUsbdCtxt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>intfNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>pAltSetting</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function called by application to know active altSetting for a given interface. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pUsbdCtxt</td><td>USBD layer context pointer.</td></tr>
    <tr><td class="paramname">intfNum</td><td>interface number.</td></tr>
    <tr><td class="paramname">pAltSetting</td><td>required alt setting pointer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CY_USBD_STATUS_CTXT_NULL when context is null. CY_USBD_STATUS_FAILURE when active config descriptor is null. CY_USBD_STATUS_SUCCESS whem able to fetch altsetting number. </dd></dl>

</div>
</div>
<a id="ga9dc7b6c55e7d8994296d068f87390837" name="ga9dc7b6c55e7d8994296d068f87390837"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9dc7b6c55e7d8994296d068f87390837">&#9670;&nbsp;</a></span>Cy_USBD_FindAltSetting()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t Cy_USBD_FindAltSetting </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>pIntfDscr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API gives information about alt setting supported by given interface. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pIntfDscr</td><td>pointer to interface descriptor.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of alt setting supported by an interface. </dd></dl>

</div>
</div>
<a id="ga82cbe8a76c66eb49dc65b7de44516f97" name="ga82cbe8a76c66eb49dc65b7de44516f97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga82cbe8a76c66eb49dc65b7de44516f97">&#9670;&nbsp;</a></span>Cy_USBD_GetNumOfAltSetting()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t Cy_USBD_GetNumOfAltSetting </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__usbd__ctxt__t">cy_stc_usb_usbd_ctxt_t</a> *&#160;</td>
          <td class="paramname"><em>pUsbdCtxt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>intfNum</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API gets number of alt setting in an interface from USBD context data structure. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pUsbdCtxt</td><td>USBD layer context pointer.</td></tr>
    <tr><td class="paramname">intfNum</td><td>interface number.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of alt setting supported by interface. </dd></dl>

</div>
</div>
<a id="gaa70e13191f5c98bec363426d05a25bd8" name="gaa70e13191f5c98bec363426d05a25bd8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa70e13191f5c98bec363426d05a25bd8">&#9670;&nbsp;</a></span>Cy_USBD_UpdateNumOfAltSetting()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t Cy_USBD_UpdateNumOfAltSetting </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__usbd__ctxt__t">cy_stc_usb_usbd_ctxt_t</a> *&#160;</td>
          <td class="paramname"><em>pUsbdCtxt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>intfNum</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API gets number of alt setting in an interface. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pUsbdCtxt</td><td>USBD layer context pointer.</td></tr>
    <tr><td class="paramname">intfNum</td><td>interface number.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of alt setting supported by interface. </dd></dl>

</div>
</div>
<a id="ga9e27d81be73ad39dec30145aa85340cc" name="ga9e27d81be73ad39dec30145aa85340cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9e27d81be73ad39dec30145aa85340cc">&#9670;&nbsp;</a></span>Cy_USBD_EndpDscrValid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Cy_USBD_EndpDscrValid </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>pEndpDscr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API confirms given descriptor is endpoint descriptor or not. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pEndpDscr</td><td>pointer to endpoint descriptor.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if given descriptor is endpoint descriptor. FALSE if given descriptor is not endpoint descriptor. </dd></dl>

</div>
</div>
<a id="gaf1381bad137c8cd9563f163ec214f040" name="gaf1381bad137c8cd9563f163ec214f040"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf1381bad137c8cd9563f163ec214f040">&#9670;&nbsp;</a></span>Cy_USBD_GetEndpNumMaxPktDir()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#gae84a77ef84aee90fcb7773ad13acab34">cy_en_usbd_ret_code_t</a> Cy_USBD_GetEndpNumMaxPktDir </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>pEndpDscr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>pEndpNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t *&#160;</td>
          <td class="paramname"><em>pMaxPktSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>pDir</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function fetches endpoint number, maxPktSize and direction from endpoint descriptor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pEndpDscr</td><td>pointer to endpoint descriptor.</td></tr>
    <tr><td class="paramname">pEndpNum</td><td>endpoint number will be stored here.</td></tr>
    <tr><td class="paramname">pMaxPktSize</td><td>max packet size of endpoint will be stored here.</td></tr>
    <tr><td class="paramname">pDir</td><td>Direction of endpoint will be stored here.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CY_USBD_STATUS_SUCCESS if operation is successful. CY_USBD_STATUS_BAD_PARAM if endpoint descriptor is NULL. CY_USBD_STATUS_PTR_NULL if any of the parameter is NULL. </dd></dl>

</div>
</div>
<a id="ga297593e06cb260f79ebb583d444fbdb5" name="ga297593e06cb260f79ebb583d444fbdb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga297593e06cb260f79ebb583d444fbdb5">&#9670;&nbsp;</a></span>Cy_USBD_GetEndpMaxPktSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#gae84a77ef84aee90fcb7773ad13acab34">cy_en_usbd_ret_code_t</a> Cy_USBD_GetEndpMaxPktSize </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>pEndpDscr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t *&#160;</td>
          <td class="paramname"><em>pMaxPktSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function fetches maxPktSize from endpoint descriptor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pEndpDscr</td><td>pointer to endpoint descriptor.</td></tr>
    <tr><td class="paramname">pMaxPktSize</td><td>max packet size of endpoint will be stored here.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CY_USBD_STATUS_SUCCESS if operation is successful. CY_USBD_STATUS_BAD_PARAM if endpoint descriptor is NULL. </dd></dl>

</div>
</div>
<a id="ga13e75fcb80a5ef2b1a88d1790375f223" name="ga13e75fcb80a5ef2b1a88d1790375f223"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga13e75fcb80a5ef2b1a88d1790375f223">&#9670;&nbsp;</a></span>Cy_USBD_GetIsoBytesPerIntvl()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#gae84a77ef84aee90fcb7773ad13acab34">cy_en_usbd_ret_code_t</a> Cy_USBD_GetIsoBytesPerIntvl </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>pIsoCompDscr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>pBytesPerIntvl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function fetches max bytes per interval for Iso endpoint from iso companion endpoint descriptor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pIsoCompDscr</td><td>pointer to Iso endpoint companion descriptor.</td></tr>
    <tr><td class="paramname">pBytesPerIntvl</td><td>Bytes per interval field from the descriptor will be stored here.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CY_USBD_STATUS_SUCCESS if operation is successful. CY_USBD_STATUS_BAD_PARAM if ompanion descriptor is NULL. </dd></dl>

</div>
</div>
<a id="ga7f03738269bc15e0918ae2c2ca84f329" name="ga7f03738269bc15e0918ae2c2ca84f329"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7f03738269bc15e0918ae2c2ca84f329">&#9670;&nbsp;</a></span>Cy_USBD_GetEndpAttribute()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#gae84a77ef84aee90fcb7773ad13acab34">cy_en_usbd_ret_code_t</a> Cy_USBD_GetEndpAttribute </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>pEndpDscr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>pAttribute</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function fetches endpoint attribute from endpoint descriptor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pEndpDscr</td><td>pointer to endpoint descriptor.</td></tr>
    <tr><td class="paramname">pAttribute</td><td>atrribute of endpoint will be stored here.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CY_USBD_STATUS_SUCCESS if operation is successful. CY_USBD_STATUS_BAD_PARAM if endpoint descriptor is NULL. </dd></dl>

</div>
</div>
<a id="gae7268a6280238958eb27a1a5e6491657" name="gae7268a6280238958eb27a1a5e6491657"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae7268a6280238958eb27a1a5e6491657">&#9670;&nbsp;</a></span>Cy_USBD_GetEndpType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#gae84a77ef84aee90fcb7773ad13acab34">cy_en_usbd_ret_code_t</a> Cy_USBD_GetEndpType </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>pEndpDscr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>pEndpType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function fetches endpoint type from endpoint descriptor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pEndpDscr</td><td>pointer to endpoint descriptor.</td></tr>
    <tr><td class="paramname">pEndpType</td><td>endpoint type is stored here.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CY_USBD_STATUS_SUCCESS if operation is successful. CY_USBD_STATUS_BAD_PARAM if endpoint descriptor is NULL. CY_USBD_STATUS_BAD_PARAM if pointer to endpoint type is NULL. </dd></dl>

</div>
</div>
<a id="gaa3210c25334204266540479f8f45445e" name="gaa3210c25334204266540479f8f45445e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa3210c25334204266540479f8f45445e">&#9670;&nbsp;</a></span>Cy_USBD_GetEndpInterval()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#gae84a77ef84aee90fcb7773ad13acab34">cy_en_usbd_ret_code_t</a> Cy_USBD_GetEndpInterval </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>pEndpDscr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>pInterval</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function fetches bInterval from endpoint descriptor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pEndpDscr</td><td>Pointer to endpoint descriptor.</td></tr>
    <tr><td class="paramname">pInterval</td><td>Endpoint polling interval is stored here.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CY_USBD_STATUS_SUCCESS if operation is successful. CY_USBD_STATUS_BAD_PARAM if endpoint descriptor is NULL. CY_USBD_STATUS_BAD_PARAM if pointer to interval is NULL. </dd></dl>

</div>
</div>
<a id="gaf22af5687aca024286ecebbc68a60a4c" name="gaf22af5687aca024286ecebbc68a60a4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf22af5687aca024286ecebbc68a60a4c">&#9670;&nbsp;</a></span>Cy_USBD_GetEndpCompnMaxburst()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#gae84a77ef84aee90fcb7773ad13acab34">cy_en_usbd_ret_code_t</a> Cy_USBD_GetEndpCompnMaxburst </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>pEndpCompnDscr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>pMaxBust</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function fetches bMaxBurst from endpoint companion descriptor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pEndpCompnDscr</td><td>pointer to endpoint companion descriptor.</td></tr>
    <tr><td class="paramname">pMaxBust</td><td>max burst information will be stored here.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CY_USBD_STATUS_SUCCESS if operation is successful. CY_USBD_STATUS_BAD_PARAM if endpoint companion descriptor is NULL. CY_USBD_STATUS_BAD_PARAM if pMaxBurst is NULL. </dd></dl>

</div>
</div>
<a id="gaa039c4b45b8a18cdf6958859304fbbc5" name="gaa039c4b45b8a18cdf6958859304fbbc5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa039c4b45b8a18cdf6958859304fbbc5">&#9670;&nbsp;</a></span>Cy_USBD_GetEndpCompnMaxStream()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#gae84a77ef84aee90fcb7773ad13acab34">cy_en_usbd_ret_code_t</a> Cy_USBD_GetEndpCompnMaxStream </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>pEndpCompnDscr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>pMaxStream</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function fetches bMaxStream from endpoint companion descriptor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pEndpCompnDscr</td><td>pointer to endpoint companion descriptor.</td></tr>
    <tr><td class="paramname">pMaxStream</td><td>max stream information will be stored here.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CY_USBD_STATUS_SUCCESS if operation is successful. CY_USBD_STATUS_BAD_PARAM if endpoint companion descriptor is NULL. CY_USBD_STATUS_BAD_PARAM if pMaxStream is NULL. </dd></dl>

</div>
</div>
<a id="gadc45ae4f9a67057f46829a8c440513a2" name="gadc45ae4f9a67057f46829a8c440513a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadc45ae4f9a67057f46829a8c440513a2">&#9670;&nbsp;</a></span>Cy_USBD_GetEndpCompnAttribute()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#gae84a77ef84aee90fcb7773ad13acab34">cy_en_usbd_ret_code_t</a> Cy_USBD_GetEndpCompnAttribute </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>pEndpCompnDscr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>pAttribute</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function fetches attribute from endpoint companion descriptor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pEndpCompnDscr</td><td>pointer to endpoint companion descriptor.</td></tr>
    <tr><td class="paramname">pAttribute</td><td>attribute information will be stored here.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CY_USBD_STATUS_SUCCESS if operation is successful. CY_USBD_STATUS_BAD_PARAM if endpoint companion descriptor is NULL. CY_USBD_STATUS_BAD_PARAM if pAttribute is NULL. </dd></dl>

</div>
</div>
<a id="ga90ad5ed53545dd1607c99541de26ad4e" name="ga90ad5ed53545dd1607c99541de26ad4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga90ad5ed53545dd1607c99541de26ad4e">&#9670;&nbsp;</a></span>Cy_USBD_GetEndpCompnBytePerInterval()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#gae84a77ef84aee90fcb7773ad13acab34">cy_en_usbd_ret_code_t</a> Cy_USBD_GetEndpCompnBytePerInterval </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>pEndpCompnDscr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t *&#160;</td>
          <td class="paramname"><em>pBytePerInterval</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function fetches bytePerInterval from endpoint companion descriptor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pEndpCompnDscr</td><td>pointer to endpoint companion descriptor.</td></tr>
    <tr><td class="paramname">pBytePerInterval</td><td>Byte per interval information will be stored here.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CY_USBD_STATUS_SUCCESS if operation is successful. CY_USBD_STATUS_BAD_PARAM if endpoint companion descriptor is NULL. CY_USBD_STATUS_BAD_PARAM if pBytePerInterval is NULL. </dd></dl>

</div>
</div>
<a id="gaba62d87aea3874c9265d83cae762c4f0" name="gaba62d87aea3874c9265d83cae762c4f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaba62d87aea3874c9265d83cae762c4f0">&#9670;&nbsp;</a></span>Cy_USBD_GetEndpSspIsoCompnBytePerInterval()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#gae84a77ef84aee90fcb7773ad13acab34">cy_en_usbd_ret_code_t</a> Cy_USBD_GetEndpSspIsoCompnBytePerInterval </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>pSspIsoEndpCompnDscr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>pBytePerInterval</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function fetches bytePerInterval from endpoint SS Iso companion descriptor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pSspIsoEndpCompnDscr</td><td>pointer to super speed Iso endpoint companion descriptor.</td></tr>
    <tr><td class="paramname">pBytePerInterval</td><td>Bytes per interval information will be stored here.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CY_USBD_STATUS_SUCCESS if operation is successful. CY_USBD_STATUS_BAD_PARAM if endpoint companion descriptor is NULL. CY_USBD_STATUS_PTR_NULL if pBytePerInterval is NULL. </dd></dl>

</div>
</div>
<a id="ga7d124ac8af24c2cbe80b5563986c2e47" name="ga7d124ac8af24c2cbe80b5563986c2e47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7d124ac8af24c2cbe80b5563986c2e47">&#9670;&nbsp;</a></span>Cy_USBD_EnableEndp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#gae84a77ef84aee90fcb7773ad13acab34">cy_en_usbd_ret_code_t</a> Cy_USBD_EnableEndp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__usbd__ctxt__t">cy_stc_usb_usbd_ctxt_t</a> *&#160;</td>
          <td class="paramname"><em>pUsbdCtxt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>endpNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#gaaebdfe5d46401ad52420b00ca401e6f8">cy_en_usb_endp_dir_t</a>&#160;</td>
          <td class="paramname"><em>endpDir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function enable/disable endpoint. </p>
<p >Based on speed, this function will call appropriate HW function to enable/disable endpoint.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pUsbdCtxt</td><td>USBD layer context pointer.</td></tr>
    <tr><td class="paramname">endpNum</td><td>endpoint number.</td></tr>
    <tr><td class="paramname">endpDir</td><td>endpoint direction.</td></tr>
    <tr><td class="paramname">enable</td><td>true for enabling endpoint and false for disabling endpoint.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CY_USBD_STATUS_SUCCESS if operation is successful. CY_USBD_STATUS_CTXT_NULL if usbd context is NULL. CY_USBD_STATUS_FAILURE in other cases. </dd></dl>

</div>
</div>
<a id="ga1be91a2a4ec8a7a364fddf195eb88425" name="ga1be91a2a4ec8a7a364fddf195eb88425"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1be91a2a4ec8a7a364fddf195eb88425">&#9670;&nbsp;</a></span>Cy_USBD_SetEpBurstMode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#gae84a77ef84aee90fcb7773ad13acab34">cy_en_usbd_ret_code_t</a> Cy_USBD_SetEpBurstMode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__usbd__ctxt__t">cy_stc_usb_usbd_ctxt_t</a> *&#160;</td>
          <td class="paramname"><em>pUsbdCtxt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>endpNumber</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#gaaebdfe5d46401ad52420b00ca401e6f8">cy_en_usb_endp_dir_t</a>&#160;</td>
          <td class="paramname"><em>endpDirection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function enables/disables the MULT (allow burst across multiple DMA buffers) feature for the specified USB endpoints. </p>
<p >Enabling the feature can improve the data transfer throughput on the respective endpoints. The settings need to be updated in the USB IP as well as at the DMA socket level.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pUsbdCtxt</td><td>USBD layer context pointer.</td></tr>
    <tr><td class="paramname">endpNumber</td><td>endpoint number.</td></tr>
    <tr><td class="paramname">endpDirection</td><td>endpoint direction.</td></tr>
    <tr><td class="paramname">enable</td><td>true for enabling burst mode and false for disabling burst mode.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CY_USBD_STATUS_SUCCESS if operation is successful. CY_USBD_STATUS_CTXT_NULL if usbd context is NULL. CY_USBD_STATUS_FAILURE in other cases. </dd></dl>

</div>
</div>
<a id="gacaba98384a734cd4182f89160fd2a646" name="gacaba98384a734cd4182f89160fd2a646"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacaba98384a734cd4182f89160fd2a646">&#9670;&nbsp;</a></span>Cy_USB_USBD_EndpConfig()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#gae84a77ef84aee90fcb7773ad13acab34">cy_en_usbd_ret_code_t</a> Cy_USB_USBD_EndpConfig </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__usbd__ctxt__t">cy_stc_usb_usbd_ctxt_t</a> *&#160;</td>
          <td class="paramname"><em>pUsbdCtxt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__endp__config__t">cy_stc_usb_endp_config_t</a>&#160;</td>
          <td class="paramname"><em>endpConfig</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function configures endpoint based on user requirement. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pUsbdCtxt</td><td>USBD layer context pointer.</td></tr>
    <tr><td class="paramname">endpConfig</td><td>configuration parameters passed by user.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CY_USBD_STATUS_SUCCESS if operation is successful. CY_USBD_STATUS_CTXT_NULL if usbd context is NULL. CY_USBD_STATUS_ENDP_CONFIG_INVALID_PARAM if any of the configuration parameter invalid. CY_USBD_STATUS_FAILURE in other cases. </dd></dl>

</div>
</div>
<a id="gaf1da79bc3a477cbdfdb95c982bb41a04" name="gaf1da79bc3a477cbdfdb95c982bb41a04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf1da79bc3a477cbdfdb95c982bb41a04">&#9670;&nbsp;</a></span>Cy_USB_USBD_EndpSetClearStall()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#gae84a77ef84aee90fcb7773ad13acab34">cy_en_usbd_ret_code_t</a> Cy_USB_USBD_EndpSetClearStall </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__usbd__ctxt__t">cy_stc_usb_usbd_ctxt_t</a> *&#160;</td>
          <td class="paramname"><em>pUsbdCtxt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>endpNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#gaaebdfe5d46401ad52420b00ca401e6f8">cy_en_usb_endp_dir_t</a>&#160;</td>
          <td class="paramname"><em>endpDir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>setClear</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function enable or disable STALL condition for the endpoint. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pUsbdCtxt</td><td>USBD layer context pointer.</td></tr>
    <tr><td class="paramname">endpNum</td><td>endpoint number.</td></tr>
    <tr><td class="paramname">endpDir</td><td>endpoint direction.</td></tr>
    <tr><td class="paramname">setClear</td><td>true for set and false for clear stall condition.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CY_USBD_STATUS_SUCCESS if operation is successful. CY_USBD_STATUS_CTXT_NULL if usbd context is NULL. CY_USBD_STATUS_FAILURE in other cases. </dd></dl>

</div>
</div>
<a id="ga6cfb5f60971661d85a8e59665a0b6d9d" name="ga6cfb5f60971661d85a8e59665a0b6d9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6cfb5f60971661d85a8e59665a0b6d9d">&#9670;&nbsp;</a></span>Cy_USB_USBD_EndpSetClearNakNrdy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#gae84a77ef84aee90fcb7773ad13acab34">cy_en_usbd_ret_code_t</a> Cy_USB_USBD_EndpSetClearNakNrdy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__usbd__ctxt__t">cy_stc_usb_usbd_ctxt_t</a> *&#160;</td>
          <td class="paramname"><em>pUsbdCtxt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>endpNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#gaaebdfe5d46401ad52420b00ca401e6f8">cy_en_usb_endp_dir_t</a>&#160;</td>
          <td class="paramname"><em>endpDir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>setClear</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function enable or disable NAK/NRDY condition for the endpoint. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pUsbdCtxt</td><td>USBD layer context pointer.</td></tr>
    <tr><td class="paramname">endpNum</td><td>endpoint number.</td></tr>
    <tr><td class="paramname">endpDir</td><td>endpoint direction.</td></tr>
    <tr><td class="paramname">setClear</td><td>true for set and false for clear NAK condition.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CY_USBD_STATUS_SUCCESS if operation is successful. CY_USBD_STATUS_CTXT_NULL if usbd context is NULL. CY_USBD_STATUS_FAILURE in other cases. </dd></dl>

</div>
</div>
<a id="gad2a5a168671e1484edd2e484bf94022d" name="gad2a5a168671e1484edd2e484bf94022d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad2a5a168671e1484edd2e484bf94022d">&#9670;&nbsp;</a></span>Cy_USBD_ResetEndp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cy_USBD_ResetEndp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__usbd__ctxt__t">cy_stc_usb_usbd_ctxt_t</a> *&#160;</td>
          <td class="paramname"><em>pUsbdCtxt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>endpNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#gaaebdfe5d46401ad52420b00ca401e6f8">cy_en_usb_endp_dir_t</a>&#160;</td>
          <td class="paramname"><em>endpDir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>preserveSeqNo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function resets endpoint related paramters by calling appropriate function at HW level. </p>
<p >This clears sticky bits e.g retry bit, flowcontrol bit.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pUsbdCtxt</td><td>USBD layer context pointer.</td></tr>
    <tr><td class="paramname">endpNum</td><td>endpoint number.</td></tr>
    <tr><td class="paramname">endpDir</td><td>endpoint direction.</td></tr>
    <tr><td class="paramname">preserveSeqNo</td><td>true to preserve sequence number and false to reset sequence number. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaa6d80ec6a7c1feccef3b932bf52bb1a3" name="gaa6d80ec6a7c1feccef3b932bf52bb1a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa6d80ec6a7c1feccef3b932bf52bb1a3">&#9670;&nbsp;</a></span>Cy_USBD_FlushEndp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cy_USBD_FlushEndp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__usbd__ctxt__t">cy_stc_usb_usbd_ctxt_t</a> *&#160;</td>
          <td class="paramname"><em>pUsbdCtxt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>endpNumber</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#gaaebdfe5d46401ad52420b00ca401e6f8">cy_en_usb_endp_dir_t</a>&#160;</td>
          <td class="paramname"><em>endpDirection</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function flush endpoint data present in EPM. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pUsbdCtxt</td><td>USBD layer context pointer.</td></tr>
    <tr><td class="paramname">endpNumber</td><td>endpoint number.</td></tr>
    <tr><td class="paramname">endpDirection</td><td>endpoint direction. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga0e6ecbf5bf4f42b416a4446f6398fac4" name="ga0e6ecbf5bf4f42b416a4446f6398fac4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0e6ecbf5bf4f42b416a4446f6398fac4">&#9670;&nbsp;</a></span>Cy_USBD_FlushEndpAll()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cy_USBD_FlushEndpAll </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__usbd__ctxt__t">cy_stc_usb_usbd_ctxt_t</a> *&#160;</td>
          <td class="paramname"><em>pUsbdCtxt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#gaaebdfe5d46401ad52420b00ca401e6f8">cy_en_usb_endp_dir_t</a>&#160;</td>
          <td class="paramname"><em>endpDir</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function flush all endpoints data endpoint data present in EPM. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pUsbdCtxt</td><td>USBD layer context pointer.</td></tr>
    <tr><td class="paramname">endpDir</td><td>Parameter is unused. Both IN and OUT endpoints will be flushed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga821a7397799e73dd3d243abc7514d544" name="ga821a7397799e73dd3d243abc7514d544"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga821a7397799e73dd3d243abc7514d544">&#9670;&nbsp;</a></span>Cy_USBD_FlushResetEndpAll()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cy_USBD_FlushResetEndpAll </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__usbd__ctxt__t">cy_stc_usb_usbd_ctxt_t</a> *&#160;</td>
          <td class="paramname"><em>pUsbdCtxt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#gaaebdfe5d46401ad52420b00ca401e6f8">cy_en_usb_endp_dir_t</a>&#160;</td>
          <td class="paramname"><em>endpDirection</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function flush/reset all endpoint with perticular direction based on speed of device controller. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pUsbdCtxt</td><td>USBD layer context pointer.</td></tr>
    <tr><td class="paramname">endpDirection</td><td>endpoint direction. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga9f46fffd95cb649f1f5b64f9a9533af2" name="ga9f46fffd95cb649f1f5b64f9a9533af2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9f46fffd95cb649f1f5b64f9a9533af2">&#9670;&nbsp;</a></span>Cy_USB_USBD_EndpSetClearNakNrdyAll()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#gae84a77ef84aee90fcb7773ad13acab34">cy_en_usbd_ret_code_t</a> Cy_USB_USBD_EndpSetClearNakNrdyAll </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__usbd__ctxt__t">cy_stc_usb_usbd_ctxt_t</a> *&#160;</td>
          <td class="paramname"><em>pUsbdCtxt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>setClear</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function enable or disable NAK/NRDY condition on all endpoints based on speed of device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pUsbdCtxt</td><td>USBD layer context pointer.</td></tr>
    <tr><td class="paramname">setClear</td><td>set ie true to enable NAK/NRDY and clear ie false to disable NAK/NRDY.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CY_USBD_STATUS_SUCCESS if operation is successful. CY_USBD_STATUS_CTXT_NULL if usbd context is NULL. CY_USBD_STATUS_FAILURE in other cases. </dd></dl>

</div>
</div>
<a id="ga1ccf7faf1524a69aa0648ab24ab4670b" name="ga1ccf7faf1524a69aa0648ab24ab4670b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1ccf7faf1524a69aa0648ab24ab4670b">&#9670;&nbsp;</a></span>Cy_USBD_EndpIsNakNrdySet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Cy_USBD_EndpIsNakNrdySet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__usbd__ctxt__t">cy_stc_usb_usbd_ctxt_t</a> *&#160;</td>
          <td class="paramname"><em>pUsbdCtxt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>endpNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#gaaebdfe5d46401ad52420b00ca401e6f8">cy_en_usb_endp_dir_t</a>&#160;</td>
          <td class="paramname"><em>endpDir</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function checks whether the specified endpoint currently has the NAK/NRDY bit set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pUsbdCtxt</td><td>USBD layer context pointer.</td></tr>
    <tr><td class="paramname">endpNum</td><td>endpoint number.</td></tr>
    <tr><td class="paramname">endpDir</td><td>endpoint direction.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if NAK/NRDY bit is set FALSE if NAK/NRDY bit is reset </dd></dl>

</div>
</div>
<a id="ga62f120f49c6537697cbe1337055121e6" name="ga62f120f49c6537697cbe1337055121e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga62f120f49c6537697cbe1337055121e6">&#9670;&nbsp;</a></span>Cy_USBD_EndpIsStallSet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Cy_USBD_EndpIsStallSet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__usbd__ctxt__t">cy_stc_usb_usbd_ctxt_t</a> *&#160;</td>
          <td class="paramname"><em>pUsbdCtxt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>endpNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#gaaebdfe5d46401ad52420b00ca401e6f8">cy_en_usb_endp_dir_t</a>&#160;</td>
          <td class="paramname"><em>endpDirection</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function checks whether the specified endpoint currently has the STALL bit set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pUsbdCtxt</td><td>USBD layer context pointer.</td></tr>
    <tr><td class="paramname">endpNum</td><td>endpoint number.</td></tr>
    <tr><td class="paramname">endpDirection</td><td>endpoint direction.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if STALL bit is set FALSE if STALL bit is reset </dd></dl>

</div>
</div>
<a id="gaf747d68e5657ff171802bb908aade694" name="gaf747d68e5657ff171802bb908aade694"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf747d68e5657ff171802bb908aade694">&#9670;&nbsp;</a></span>Cy_USBD_EndpMapStream()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#gae84a77ef84aee90fcb7773ad13acab34">cy_en_usbd_ret_code_t</a> Cy_USBD_EndpMapStream </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__usbd__ctxt__t">cy_stc_usb_usbd_ctxt_t</a> *&#160;</td>
          <td class="paramname"><em>pUsbdCtxt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>endpNumber</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#gaaebdfe5d46401ad52420b00ca401e6f8">cy_en_usb_endp_dir_t</a>&#160;</td>
          <td class="paramname"><em>endpDirection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>streamId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>socketNum</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function maps an unused USB Ingress/Egress socket to the specified stream associated with a bulk endpoint. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pUsbdCtxt</td><td>USBD layer context pointer.</td></tr>
    <tr><td class="paramname">endpNumber</td><td>endpoint number.</td></tr>
    <tr><td class="paramname">endpDirection</td><td>endpoint direction.</td></tr>
    <tr><td class="paramname">streamId</td><td>stream number.</td></tr>
    <tr><td class="paramname">socketNum</td><td>socket number to be mapped.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CY_USBD_STATUS_SUCCESS if operation is successful. CY_USBD_STATUS_CTXT_NULL if usbd context is NULL. CY_USBD_STATUS_FAILURE if function is called for FS/HS device. CY_USBD_STATUS_BAD_PARAM if HW call fails due to any parameter. </dd></dl>

</div>
</div>
<a id="gada92726f1df0b27c5fd06cc65a9390e7" name="gada92726f1df0b27c5fd06cc65a9390e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gada92726f1df0b27c5fd06cc65a9390e7">&#9670;&nbsp;</a></span>Cy_USBD_EndpUnmapStream()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#gae84a77ef84aee90fcb7773ad13acab34">cy_en_usbd_ret_code_t</a> Cy_USBD_EndpUnmapStream </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__usbd__ctxt__t">cy_stc_usb_usbd_ctxt_t</a> *&#160;</td>
          <td class="paramname"><em>pUsbdCtxt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>endpNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#gaaebdfe5d46401ad52420b00ca401e6f8">cy_en_usb_endp_dir_t</a>&#160;</td>
          <td class="paramname"><em>endpDir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>socketNum</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function unmaps the USB ingress/egress socket to bulk stream mapping for a bulk endpoint and socket. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pUsbdCtxt</td><td>USBD layer context pointer.</td></tr>
    <tr><td class="paramname">endpNum</td><td>endpoint number.</td></tr>
    <tr><td class="paramname">endpDir</td><td>endpoint direction.</td></tr>
    <tr><td class="paramname">socketNum</td><td>socket number to be mapped.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CY_USBD_STATUS_SUCCESS if operation is successful. CY_USBD_STATUS_CTXT_NULL if usbd context is NULL. CY_USBD_STATUS_FAILURE if function is called for FS/HS device. CY_USBD_STATUS_BAD_PARAM if HW call fails due to any parameter. </dd></dl>

</div>
</div>
<a id="ga333d4fe7dbfd5b6670ae9fa441421dcd" name="ga333d4fe7dbfd5b6670ae9fa441421dcd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga333d4fe7dbfd5b6670ae9fa441421dcd">&#9670;&nbsp;</a></span>Cy_USBD_EndpSetPktsPerBuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#gae84a77ef84aee90fcb7773ad13acab34">cy_en_usbd_ret_code_t</a> Cy_USBD_EndpSetPktsPerBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__usbd__ctxt__t">cy_stc_usb_usbd_ctxt_t</a> *&#160;</td>
          <td class="paramname"><em>pUsbdCtxt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>endpNumber</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>pktsPerBuffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function is used to update the USB block with the number of max. </p>
<p >sized packets received on a SuperSpeed OUT endpoint that can fit into one DMA buffer. Setting this value is required for proper operation in cases where the maximum packet size of the endpoint is not a power of 2.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pUsbdCtxt</td><td>USBD layer context pointer.</td></tr>
    <tr><td class="paramname">endpNumber</td><td>endpoint number.</td></tr>
    <tr><td class="paramname">pktsPerBuffer</td><td>Number of packets that can fit in one DMA buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CY_USBD_STATUS_SUCCESS if operation is successful. CY_USBD_STATUS_CTXT_NULL if usbd context is NULL. CY_USBD_STATUS_FAILURE if function is called for FS/HS device. CY_USBD_STATUS_BAD_PARAM if HW call fails due to any parameter. </dd></dl>

</div>
</div>
<a id="ga5d33e619cb094cfe4bb25e79bd2938fc" name="ga5d33e619cb094cfe4bb25e79bd2938fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5d33e619cb094cfe4bb25e79bd2938fc">&#9670;&nbsp;</a></span>Cy_USBD_UpdateXferCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cy_USBD_UpdateXferCount </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__usbd__ctxt__t">cy_stc_usb_usbd_ctxt_t</a> *&#160;</td>
          <td class="paramname"><em>pUsbdCtxt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>endpNumber</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#gaaebdfe5d46401ad52420b00ca401e6f8">cy_en_usb_endp_dir_t</a>&#160;</td>
          <td class="paramname"><em>endpDirection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>bufferSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function will update xfer count based on speed of device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pUsbdCtxt</td><td>USBD layer context pointer.</td></tr>
    <tr><td class="paramname">endpNumber</td><td>endpoint number.</td></tr>
    <tr><td class="paramname">endpDirection</td><td>endpoint direction.</td></tr>
    <tr><td class="paramname">bufferSize</td><td>buffer size. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad9596e9f61e4d474c5d8ceab50b29e77" name="gad9596e9f61e4d474c5d8ceab50b29e77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad9596e9f61e4d474c5d8ceab50b29e77">&#9670;&nbsp;</a></span>Cy_USBD_CtrlEndp0DataOutAck()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cy_USBD_CtrlEndp0DataOutAck </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__usbd__ctxt__t">cy_stc_usb_usbd_ctxt_t</a> *&#160;</td>
          <td class="paramname"><em>pUsbdCtxt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>setClear</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Data stage ACK for endpoint0 is controlled by this function. </p>
<p >In USBHS, when "CONT_TO_DATA" bit is set then controller won't send ACK till data is validated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pUsbdCtxt</td><td>USBD layer context pointer.</td></tr>
    <tr><td class="paramname">setClear</td><td>true for set and false for clear. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gacc3236b5d736d112c5b9954195a9d07f" name="gacc3236b5d736d112c5b9954195a9d07f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacc3236b5d736d112c5b9954195a9d07f">&#9670;&nbsp;</a></span>Cy_USBD_EnableStatusCtrl()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#gae84a77ef84aee90fcb7773ad13acab34">cy_en_usbd_ret_code_t</a> Cy_USBD_EnableStatusCtrl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__usbd__ctxt__t">cy_stc_usb_usbd_ctxt_t</a> *&#160;</td>
          <td class="paramname"><em>pUsbdCtxt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function enable/disable status control feature which is part of SS controller. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pUsbdCtxt</td><td>USBD layer context pointer.</td></tr>
    <tr><td class="paramname">enable</td><td>true for enable and false for disable.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CY_USBD_STATUS_SUCCESS if operation is successful. CY_USBD_STATUS_CTXT_NULL if usbd context is NULL. CY_USBD_STATUS_FAILURE if function is called for FS/HS device. </dd></dl>

</div>
</div>
<a id="gacc22f450097f8a120f15547f2f5d9263" name="gacc22f450097f8a120f15547f2f5d9263"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacc22f450097f8a120f15547f2f5d9263">&#9670;&nbsp;</a></span>Cy_USBD_ClearStatusClrBusy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#gae84a77ef84aee90fcb7773ad13acab34">cy_en_usbd_ret_code_t</a> Cy_USBD_ClearStatusClrBusy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__usbd__ctxt__t">cy_stc_usb_usbd_ctxt_t</a> *&#160;</td>
          <td class="paramname"><em>pUsbdCtxt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function write "1" to STATUS_CLR_BUSY which clears the bit to initiate STATUS response. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pUsbdCtxt</td><td>USBD layer context pointer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CY_USBD_STATUS_SUCCESS if operation is successful. CY_USBD_STATUS_CTXT_NULL if usbd context is NULL. CY_USBD_STATUS_FAILURE if function is called for FS/HS device. </dd></dl>

</div>
</div>
<a id="gabcff797df0b1123869324c7e71dbfd01" name="gabcff797df0b1123869324c7e71dbfd01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabcff797df0b1123869324c7e71dbfd01">&#9670;&nbsp;</a></span>Cy_USBD_SendAckSetupDataStatusStage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cy_USBD_SendAckSetupDataStatusStage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__usbd__ctxt__t">cy_stc_usb_usbd_ctxt_t</a> *&#160;</td>
          <td class="paramname"><em>pUsbdCtxt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allow chipset to send ACK to complete control transfer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pUsbdCtxt</td><td>USBD layer context pointer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga82df864bb290c377687c5aa9ddffab36" name="ga82df864bb290c377687c5aa9ddffab36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga82df864bb290c377687c5aa9ddffab36">&#9670;&nbsp;</a></span>Cy_USB_USBD_SendEndp0Data()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#gae84a77ef84aee90fcb7773ad13acab34">cy_en_usbd_ret_code_t</a> Cy_USB_USBD_SendEndp0Data </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__usbd__ctxt__t">cy_stc_usb_usbd_ctxt_t</a> *&#160;</td>
          <td class="paramname"><em>pUsbdCtxt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>pBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>bufferSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function sends data overthe DMA for endpoint 0. </p>
<p >Based on speed of device, SS or HS function will be invoked.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pUsbdCtxt</td><td>USBD layer context pointer.</td></tr>
    <tr><td class="paramname">pBuffer</td><td>pointer to buffer where data is available.</td></tr>
    <tr><td class="paramname">bufferSize</td><td>Buffer Size.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CY_USBD_STATUS_SUCCESS if operation is successful. CY_USBD_STATUS_FAILURE if operation is unsuccessful. </dd></dl>

</div>
</div>
<a id="gaba857ca0447aebe351c7f802fc758907" name="gaba857ca0447aebe351c7f802fc758907"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaba857ca0447aebe351c7f802fc758907">&#9670;&nbsp;</a></span>Cy_USB_USBD_SendEndp0DataSs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#gae84a77ef84aee90fcb7773ad13acab34">cy_en_usbd_ret_code_t</a> Cy_USB_USBD_SendEndp0DataSs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__usbd__ctxt__t">cy_stc_usb_usbd_ctxt_t</a> *&#160;</td>
          <td class="paramname"><em>pUsbdCtxt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>pBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>bufferSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function sends data overthe DMA for endpoint 0 of SS device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pUsbdCtxt</td><td>USBD layer context pointer.</td></tr>
    <tr><td class="paramname">pBuffer</td><td>pointer to buffer where data is available.</td></tr>
    <tr><td class="paramname">bufferSize</td><td>Buffer Size.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CY_USBD_STATUS_SUCCESS if operation is successful. CY_USBD_STATUS_CTXT_NULL if usbd context is NULL. CY_USBD_STATUS_BAD_PARAM if pBuffer NULL or bufferSize 0x00. CY_USBD_STATUS_FAILURE if operation is unsuccessful. </dd></dl>

</div>
</div>
<a id="gae9974adc807741dbb090c1595b6786a1" name="gae9974adc807741dbb090c1595b6786a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae9974adc807741dbb090c1595b6786a1">&#9670;&nbsp;</a></span>Cy_USB_USBD_SendEndp0DataHs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#gae84a77ef84aee90fcb7773ad13acab34">cy_en_usbd_ret_code_t</a> Cy_USB_USBD_SendEndp0DataHs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__usbd__ctxt__t">cy_stc_usb_usbd_ctxt_t</a> *&#160;</td>
          <td class="paramname"><em>pUsbdCtxt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>pBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>bufferSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function sends data overthe DMA for endpoint 0 of HS device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pUsbdCtxt</td><td>USBD layer context pointer.</td></tr>
    <tr><td class="paramname">pBuffer</td><td>pointer to buffer where data is available.</td></tr>
    <tr><td class="paramname">bufferSize</td><td>Buffer Size.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CY_USBD_STATUS_SUCCESS if operation is successful. CY_USBD_STATUS_CTXT_NULL if usbd context is NULL. CY_USBD_STATUS_BAD_PARAM if pBuffer NULL or bufferSize 0x00. CY_USBD_STATUS_FAILURE if operation is unsuccessful. </dd></dl>

</div>
</div>
<a id="ga29e295da7e895b010412c44d23691270" name="ga29e295da7e895b010412c44d23691270"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga29e295da7e895b010412c44d23691270">&#9670;&nbsp;</a></span>Cy_USB_USBD_RecvEndp0Data()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#gae84a77ef84aee90fcb7773ad13acab34">cy_en_usbd_ret_code_t</a> Cy_USB_USBD_RecvEndp0Data </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__usbd__ctxt__t">cy_stc_usb_usbd_ctxt_t</a> *&#160;</td>
          <td class="paramname"><em>pUsbdCtxt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>pBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>bufferSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function receives data overthe DMA for endpoint 0. </p>
<p >Based on speed of device, SS or HS function will be invoked.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pUsbdCtxt</td><td>USBD layer context pointer.</td></tr>
    <tr><td class="paramname">pBuffer</td><td>pointer to buffer where received data will be stored.</td></tr>
    <tr><td class="paramname">bufferSize</td><td>Buffer Size.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CY_USBD_STATUS_SUCCESS if operation is successful. CY_USBD_STATUS_FAILURE if operation is unsuccessful. </dd></dl>

</div>
</div>
<a id="ga42306ad5763a5ef88985afab49f0efef" name="ga42306ad5763a5ef88985afab49f0efef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga42306ad5763a5ef88985afab49f0efef">&#9670;&nbsp;</a></span>Cy_USB_USBD_RecvEndp0DataSs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#gae84a77ef84aee90fcb7773ad13acab34">cy_en_usbd_ret_code_t</a> Cy_USB_USBD_RecvEndp0DataSs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__usbd__ctxt__t">cy_stc_usb_usbd_ctxt_t</a> *&#160;</td>
          <td class="paramname"><em>pUsbdCtxt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>pBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>bufferSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function to recieve data for endpoint 0 through DMA for SS. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pUsbdCtxt</td><td>USBD layer context pointer.</td></tr>
    <tr><td class="paramname">pBuffer</td><td>pointer to buffer where received data will be stored.</td></tr>
    <tr><td class="paramname">bufferSize</td><td>Buffer Size.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CY_USBD_STATUS_SUCCESS if operation is successful. CY_USBD_STATUS_CTXT_NULL if usbd context is NULL. CY_USBD_STATUS_BAD_PARAM if pBuffer NULL or bufferSize 0x00. CY_USBD_STATUS_FAILURE if operation is unsuccessful. </dd></dl>

</div>
</div>
<a id="gac76c23b3433d3eb1ec9cd79f1f419d4e" name="gac76c23b3433d3eb1ec9cd79f1f419d4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac76c23b3433d3eb1ec9cd79f1f419d4e">&#9670;&nbsp;</a></span>Cy_USB_USBD_RecvEndp0DataHs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#gae84a77ef84aee90fcb7773ad13acab34">cy_en_usbd_ret_code_t</a> Cy_USB_USBD_RecvEndp0DataHs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__usbd__ctxt__t">cy_stc_usb_usbd_ctxt_t</a> *&#160;</td>
          <td class="paramname"><em>pUsbdCtxt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>pBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>bufferSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function to recieve data for endpoint 0 through DMA for HS. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pUsbdCtxt</td><td>USBD layer context pointer.</td></tr>
    <tr><td class="paramname">pBuffer</td><td>pointer to buffer where received data will be stored.</td></tr>
    <tr><td class="paramname">bufferSize</td><td>Buffer Size.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CY_USBD_STATUS_SUCCESS if operation is successful. CY_USBD_STATUS_CTXT_NULL if usbd context is NULL. CY_USBD_STATUS_BAD_PARAM if pBuffer NULL or bufferSize 0x00. </dd></dl>

</div>
</div>
<a id="ga8d2023c823502a6cc5bdc5fb1351c4c6" name="ga8d2023c823502a6cc5bdc5fb1351c4c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8d2023c823502a6cc5bdc5fb1351c4c6">&#9670;&nbsp;</a></span>Cy_USBD_IsEp0ReceiveDone()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Cy_USBD_IsEp0ReceiveDone </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__usbd__ctxt__t">cy_stc_usb_usbd_ctxt_t</a> *&#160;</td>
          <td class="paramname"><em>pUsbdCtxt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function checks whether a EP0 data receive operation is pending. </p>
<p >Please note that the function will return true to indicate transfer done if there was no pending transfer in the first place.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pUsbdCtxt</td><td>USBD layer context pointer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if there is no pending EP0 OUT data transfer. false if there is a pending EP0 OUT data transfer. </dd></dl>

</div>
</div>
<a id="ga494034c62022f805d3714dc3a51fa7a5" name="ga494034c62022f805d3714dc3a51fa7a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga494034c62022f805d3714dc3a51fa7a5">&#9670;&nbsp;</a></span>Cy_USBD_HandleGetDscr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#gae84a77ef84aee90fcb7773ad13acab34">cy_en_usbd_ret_code_t</a> Cy_USBD_HandleGetDscr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__usbd__ctxt__t">cy_stc_usb_usbd_ctxt_t</a> *&#160;</td>
          <td class="paramname"><em>pUsbdCtxt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__setup__req__t">cy_stc_usb_setup_req_t</a>&#160;</td>
          <td class="paramname"><em>setupReq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__cal__msg__t">cy_stc_usb_cal_msg_t</a> *&#160;</td>
          <td class="paramname"><em>pMsg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function handles all get descriptor command coming from host. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pUsbdCtxt</td><td>USBD layer context pointer.</td></tr>
    <tr><td class="paramname">setupReq</td><td>setup request which came from host.</td></tr>
    <tr><td class="paramname">pMsg</td><td>pointer to message sent by bottom layer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CY_USBD_STATUS_SUCCESS if operation is successful. CY_USBD_STATUS_CTXT_NULL if usbd context is NULL. </dd></dl>

</div>
</div>
<a id="ga58d0bcd2149941c51a7df4bf400391b5" name="ga58d0bcd2149941c51a7df4bf400391b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga58d0bcd2149941c51a7df4bf400391b5">&#9670;&nbsp;</a></span>Cy_USBD_HandleGetStatus()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#gae84a77ef84aee90fcb7773ad13acab34">cy_en_usbd_ret_code_t</a> Cy_USBD_HandleGetStatus </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__usbd__ctxt__t">cy_stc_usb_usbd_ctxt_t</a> *&#160;</td>
          <td class="paramname"><em>pUsbdCtxt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__setup__req__t">cy_stc_usb_setup_req_t</a>&#160;</td>
          <td class="paramname"><em>setupReq</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function handles get status request coming from host. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pUsbdCtxt</td><td>USBD layer context pointer.</td></tr>
    <tr><td class="paramname">setupReq</td><td>setup request which came from host.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CY_USBD_STATUS_SUCCESS if operation is successful. CY_USBD_STATUS_CTXT_NULL if usbd context is NULL. </dd></dl>

</div>
</div>
<a id="ga3a71db97feb765576de168d1249e4a75" name="ga3a71db97feb765576de168d1249e4a75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3a71db97feb765576de168d1249e4a75">&#9670;&nbsp;</a></span>Cy_USBD_HandleSetFeature()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#gae84a77ef84aee90fcb7773ad13acab34">cy_en_usbd_ret_code_t</a> Cy_USBD_HandleSetFeature </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__usbd__ctxt__t">cy_stc_usb_usbd_ctxt_t</a> *&#160;</td>
          <td class="paramname"><em>pUsbdCtxt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__setup__req__t">cy_stc_usb_setup_req_t</a>&#160;</td>
          <td class="paramname"><em>setupReq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__cal__msg__t">cy_stc_usb_cal_msg_t</a> *&#160;</td>
          <td class="paramname"><em>pMsg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function handles set-feature request came from host. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pUsbdCtxt</td><td>USBD layer context pointer.</td></tr>
    <tr><td class="paramname">setupReq</td><td>setup request which came from host.</td></tr>
    <tr><td class="paramname">pMsg</td><td>pointer to message sent by bottom layer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CY_USBD_STATUS_SUCCESS if operation is successful. CY_USBD_STATUS_CTXT_NULL if usbd context is NULL. CY_USBD_STATUS_FAILURE in all other failure case. </dd></dl>

</div>
</div>
<a id="ga4f5e69968bee67460a97de7bf1daa8db" name="ga4f5e69968bee67460a97de7bf1daa8db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4f5e69968bee67460a97de7bf1daa8db">&#9670;&nbsp;</a></span>Cy_USBD_HandleClearFeature()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#gae84a77ef84aee90fcb7773ad13acab34">cy_en_usbd_ret_code_t</a> Cy_USBD_HandleClearFeature </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__usbd__ctxt__t">cy_stc_usb_usbd_ctxt_t</a> *&#160;</td>
          <td class="paramname"><em>pUsbdCtxt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__setup__req__t">cy_stc_usb_setup_req_t</a>&#160;</td>
          <td class="paramname"><em>setupReq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__cal__msg__t">cy_stc_usb_cal_msg_t</a> *&#160;</td>
          <td class="paramname"><em>pMsg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function handles clear-feature request came from host. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pUsbdCtxt</td><td>USBD layer context pointer.</td></tr>
    <tr><td class="paramname">setupReq</td><td>setup request which came from host.</td></tr>
    <tr><td class="paramname">pMsg</td><td>pointer to message sent by bottom layer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CY_USBD_STATUS_SUCCESS if operation is successful. CY_USBD_STATUS_CTXT_NULL if usbd context is NULL. CY_USBD_STATUS_FAILURE in all other failure case. </dd></dl>

</div>
</div>
<a id="gac40e09702c31355f20bc92512f51a7f4" name="gac40e09702c31355f20bc92512f51a7f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac40e09702c31355f20bc92512f51a7f4">&#9670;&nbsp;</a></span>Cy_USBD_HandleSetConfiguration()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#gae84a77ef84aee90fcb7773ad13acab34">cy_en_usbd_ret_code_t</a> Cy_USBD_HandleSetConfiguration </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__usbd__ctxt__t">cy_stc_usb_usbd_ctxt_t</a> *&#160;</td>
          <td class="paramname"><em>pUsbdCtxt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__setup__req__t">cy_stc_usb_setup_req_t</a>&#160;</td>
          <td class="paramname"><em>setupReq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__cal__msg__t">cy_stc_usb_cal_msg_t</a> *&#160;</td>
          <td class="paramname"><em>pMsg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function handles set configuration request came from host. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pUsbdCtxt</td><td>USBD layer context pointer.</td></tr>
    <tr><td class="paramname">setupReq</td><td>setup request which came from host.</td></tr>
    <tr><td class="paramname">pMsg</td><td>pointer to message sent by bottom layer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CY_USBD_STATUS_SUCCESS if operation is successful. CY_USBD_STATUS_CTXT_NULL if usbd context is NULL. CY_USBD_STATUS_FAILURE in all other failure case. </dd></dl>

</div>
</div>
<a id="ga2fe891abc5be2f67cefb5fb78302a306" name="ga2fe891abc5be2f67cefb5fb78302a306"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2fe891abc5be2f67cefb5fb78302a306">&#9670;&nbsp;</a></span>Cy_USBD_HandleGetConfiguration()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#gae84a77ef84aee90fcb7773ad13acab34">cy_en_usbd_ret_code_t</a> Cy_USBD_HandleGetConfiguration </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__usbd__ctxt__t">cy_stc_usb_usbd_ctxt_t</a> *&#160;</td>
          <td class="paramname"><em>pUsbdCtxt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__setup__req__t">cy_stc_usb_setup_req_t</a>&#160;</td>
          <td class="paramname"><em>setupReq</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function handles get configuration request came from host. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pUsbdCtxt</td><td>USBD layer context pointer.</td></tr>
    <tr><td class="paramname">setupReq</td><td>setup request which came from host.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CY_USBD_STATUS_SUCCESS if operation is successful. CY_USBD_STATUS_FAILURE in all other failure case. </dd></dl>

</div>
</div>
<a id="ga6d85d4f4520580f23d317650d1e0f973" name="ga6d85d4f4520580f23d317650d1e0f973"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6d85d4f4520580f23d317650d1e0f973">&#9670;&nbsp;</a></span>Cy_USBD_HandleSetInterface()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#gae84a77ef84aee90fcb7773ad13acab34">cy_en_usbd_ret_code_t</a> Cy_USBD_HandleSetInterface </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__usbd__ctxt__t">cy_stc_usb_usbd_ctxt_t</a> *&#160;</td>
          <td class="paramname"><em>pUsbdCtxt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__setup__req__t">cy_stc_usb_setup_req_t</a>&#160;</td>
          <td class="paramname"><em>setupReq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__cal__msg__t">cy_stc_usb_cal_msg_t</a> *&#160;</td>
          <td class="paramname"><em>pMsg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function handles set interface request came from host. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pUsbdCtxt</td><td>USBD layer context pointer.</td></tr>
    <tr><td class="paramname">setupReq</td><td>setup request which came from host.</td></tr>
    <tr><td class="paramname">pMsg</td><td>pointer to message sent by bottom layer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CY_USBD_STATUS_SUCCESS if operation is successful. CY_USBD_STATUS_FAILURE in all other failure case. </dd></dl>

</div>
</div>
<a id="gab879bc0466d224eeb8ffa0e2b9b763b5" name="gab879bc0466d224eeb8ffa0e2b9b763b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab879bc0466d224eeb8ffa0e2b9b763b5">&#9670;&nbsp;</a></span>Cy_USBD_HandleGetInterface()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#gae84a77ef84aee90fcb7773ad13acab34">cy_en_usbd_ret_code_t</a> Cy_USBD_HandleGetInterface </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__usbd__ctxt__t">cy_stc_usb_usbd_ctxt_t</a> *&#160;</td>
          <td class="paramname"><em>pUsbdCtxt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__setup__req__t">cy_stc_usb_setup_req_t</a>&#160;</td>
          <td class="paramname"><em>setupReq</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function handles get interface request came from host. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pUsbdCtxt</td><td>USBD layer context pointer.</td></tr>
    <tr><td class="paramname">setupReq</td><td>setup request which came from host.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CY_USBD_STATUS_SUCCESS if operation is successful. CY_USBD_STATUS_FAILURE in all other failure case. </dd></dl>

</div>
</div>
<a id="ga2b3edfc749fc256626f8be6d95a6b244" name="ga2b3edfc749fc256626f8be6d95a6b244"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2b3edfc749fc256626f8be6d95a6b244">&#9670;&nbsp;</a></span>Cy_USBD_HandleReset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#gae84a77ef84aee90fcb7773ad13acab34">cy_en_usbd_ret_code_t</a> Cy_USBD_HandleReset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__usbd__ctxt__t">cy_stc_usb_usbd_ctxt_t</a> *&#160;</td>
          <td class="paramname"><em>pUsbdCtxt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__cal__msg__t">cy_stc_usb_cal_msg_t</a> *&#160;</td>
          <td class="paramname"><em>pMsg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function handles bus reset. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pUsbdCtxt</td><td>USBD layer context pointer.</td></tr>
    <tr><td class="paramname">pMsg</td><td>pointer to message sent by bottom layer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CY_USBD_STATUS_SUCCESS if operation is successful. CY_USBD_STATUS_FAILURE in all other failure case. </dd></dl>

</div>
</div>
<a id="gacece834783f030a04ae1bbca325de05f" name="gacece834783f030a04ae1bbca325de05f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacece834783f030a04ae1bbca325de05f">&#9670;&nbsp;</a></span>Cy_USBD_HandleRxFailure()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cy_USBD_HandleRxFailure </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__usbd__ctxt__t">cy_stc_usb_usbd_ctxt_t</a> *&#160;</td>
          <td class="paramname"><em>pUsbdCtxt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>retry_cnt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enables USB stack level work-around to attempt Gen2 connection start-up multiple times in case of training failure in Polling.Active or Polling.Config states. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pUsbdCtxt</td><td>USBD layer context pointer.</td></tr>
    <tr><td class="paramname">enable</td><td>Whether work-around is to be enabled.</td></tr>
    <tr><td class="paramname">retry_cnt</td><td>Number of connection attempts to be made in case of Gen2 training failure. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga550e2adb4828075fd3610a71b1324eff" name="ga550e2adb4828075fd3610a71b1324eff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga550e2adb4828075fd3610a71b1324eff">&#9670;&nbsp;</a></span>Cy_USBD_HandleSsReset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#gae84a77ef84aee90fcb7773ad13acab34">cy_en_usbd_ret_code_t</a> Cy_USBD_HandleSsReset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__usbd__ctxt__t">cy_stc_usb_usbd_ctxt_t</a> *&#160;</td>
          <td class="paramname"><em>pUsbdCtxt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__cal__msg__t">cy_stc_usb_cal_msg_t</a> *&#160;</td>
          <td class="paramname"><em>pMsg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function handles reset in SS mode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pUsbdCtxt</td><td>USBD layer context pointer.</td></tr>
    <tr><td class="paramname">pMsg</td><td>pointer to message sent by bottom layer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CY_USBD_STATUS_SUCCESS if operation is successful. CY_USBD_STATUS_FAILURE in all other failure case. </dd></dl>

</div>
</div>
<a id="gaf79e574239e6758e42d1fc73fa558aec" name="gaf79e574239e6758e42d1fc73fa558aec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf79e574239e6758e42d1fc73fa558aec">&#9670;&nbsp;</a></span>Cy_USBD_HandleHsGrant()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#gae84a77ef84aee90fcb7773ad13acab34">cy_en_usbd_ret_code_t</a> Cy_USBD_HandleHsGrant </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__usbd__ctxt__t">cy_stc_usb_usbd_ctxt_t</a> *&#160;</td>
          <td class="paramname"><em>pUsbdCtxt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__cal__msg__t">cy_stc_usb_cal_msg_t</a> *&#160;</td>
          <td class="paramname"><em>pMsg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>High speed related switching is handled here. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pUsbdCtxt</td><td>USBD layer context pointer.</td></tr>
    <tr><td class="paramname">pMsg</td><td>pointer to message sent by bottom layer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CY_USBD_STATUS_SUCCESS if operation is successful. CY_USBD_STATUS_CTXT_NULL if usbd context is NULL. </dd></dl>

</div>
</div>
<a id="ga3f4d47836a876ce053a8f42033d207e7" name="ga3f4d47836a876ce053a8f42033d207e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3f4d47836a876ce053a8f42033d207e7">&#9670;&nbsp;</a></span>Cy_USBD_HandleResetDone()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#gae84a77ef84aee90fcb7773ad13acab34">cy_en_usbd_ret_code_t</a> Cy_USBD_HandleResetDone </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__usbd__ctxt__t">cy_stc_usb_usbd_ctxt_t</a> *&#160;</td>
          <td class="paramname"><em>pUsbdCtxt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__cal__msg__t">cy_stc_usb_cal_msg_t</a> *&#160;</td>
          <td class="paramname"><em>pMsg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function handles reset-done message. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pUsbdCtxt</td><td>USBD layer context pointer.</td></tr>
    <tr><td class="paramname">pMsg</td><td>pointer to message sent by bottom layer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CY_USBD_STATUS_SUCCESS if operation is successful. CY_USBD_STATUS_CTXT_NULL if usbd context is NULL. CY_USBD_STATUS_FAILURE in all other failure case. </dd></dl>

</div>
</div>
<a id="ga5137686978a925ec779f272c5a0183a7" name="ga5137686978a925ec779f272c5a0183a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5137686978a925ec779f272c5a0183a7">&#9670;&nbsp;</a></span>Cy_USBD_HandleCtrlXfrSetupStage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#gae84a77ef84aee90fcb7773ad13acab34">cy_en_usbd_ret_code_t</a> Cy_USBD_HandleCtrlXfrSetupStage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__usbd__ctxt__t">cy_stc_usb_usbd_ctxt_t</a> *&#160;</td>
          <td class="paramname"><em>pUsbdCtxt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__cal__msg__t">cy_stc_usb_cal_msg_t</a> *&#160;</td>
          <td class="paramname"><em>pMsg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function handles setup stage of control transfer. </p>
<p >It also prepare for data/ack stage based on request.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pUsbdCtxt</td><td>USBD layer context pointer.</td></tr>
    <tr><td class="paramname">pMsg</td><td>pointer to message sent by bottom layer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CY_USBD_STATUS_SUCCESS if operation is successful. CY_USBD_STATUS_FAILURE in all other failure case. </dd></dl>

</div>
</div>
<a id="ga95f2024779831f22798134ea81a8a74f" name="ga95f2024779831f22798134ea81a8a74f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga95f2024779831f22798134ea81a8a74f">&#9670;&nbsp;</a></span>Cy_USBD_HandleStatusStage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#gae84a77ef84aee90fcb7773ad13acab34">cy_en_usbd_ret_code_t</a> Cy_USBD_HandleStatusStage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__usbd__ctxt__t">cy_stc_usb_usbd_ctxt_t</a> *&#160;</td>
          <td class="paramname"><em>pUsbdCtxt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__cal__msg__t">cy_stc_usb_cal_msg_t</a> *&#160;</td>
          <td class="paramname"><em>pMsg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function handles status stage of control transfer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pUsbdCtxt</td><td>USBD layer context pointer.</td></tr>
    <tr><td class="paramname">pMsg</td><td>pointer to message sent by bottom layer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CY_USBD_STATUS_SUCCESS if operation is successful. CY_USBD_STATUS_CTXT_NULL if usbd context is NULL. CY_USBD_STATUS_FAILURE in all other failure case. </dd></dl>

</div>
</div>
<a id="ga6fcbc825324f0109aa266131f87e1daf" name="ga6fcbc825324f0109aa266131f87e1daf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6fcbc825324f0109aa266131f87e1daf">&#9670;&nbsp;</a></span>Cy_USBD_HandleSuspend()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#gae84a77ef84aee90fcb7773ad13acab34">cy_en_usbd_ret_code_t</a> Cy_USBD_HandleSuspend </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__usbd__ctxt__t">cy_stc_usb_usbd_ctxt_t</a> *&#160;</td>
          <td class="paramname"><em>pUsbdCtxt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__cal__msg__t">cy_stc_usb_cal_msg_t</a> *&#160;</td>
          <td class="paramname"><em>pMsg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function handles suspend functionality. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pUsbdCtxt</td><td>USBD layer context pointer.</td></tr>
    <tr><td class="paramname">pMsg</td><td>pointer to message sent by bottom layer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CY_USBD_STATUS_SUCCESS if operation is successful. CY_USBD_STATUS_CTXT_NULL if usbd context is NULL. </dd></dl>

</div>
</div>
<a id="ga93abdaba6a1c545a26516f5aea024c89" name="ga93abdaba6a1c545a26516f5aea024c89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga93abdaba6a1c545a26516f5aea024c89">&#9670;&nbsp;</a></span>Cy_USBD_HandleResume()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#gae84a77ef84aee90fcb7773ad13acab34">cy_en_usbd_ret_code_t</a> Cy_USBD_HandleResume </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__usbd__ctxt__t">cy_stc_usb_usbd_ctxt_t</a> *&#160;</td>
          <td class="paramname"><em>pUsbdCtxt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__cal__msg__t">cy_stc_usb_cal_msg_t</a> *&#160;</td>
          <td class="paramname"><em>pMsg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function handles resume functionality. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pUsbdCtxt</td><td>USBD layer context pointer.</td></tr>
    <tr><td class="paramname">pMsg</td><td>pointer to message sent by bottom layer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CY_USBD_STATUS_SUCCESS if operation is successful. CY_USBD_STATUS_CTXT_NULL if usbd context is NULL. </dd></dl>

</div>
</div>
<a id="gab655f02a1b553ceea53401a2974c34cc" name="gab655f02a1b553ceea53401a2974c34cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab655f02a1b553ceea53401a2974c34cc">&#9670;&nbsp;</a></span>Cy_USBD_HandleL1Sleep()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#gae84a77ef84aee90fcb7773ad13acab34">cy_en_usbd_ret_code_t</a> Cy_USBD_HandleL1Sleep </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__usbd__ctxt__t">cy_stc_usb_usbd_ctxt_t</a> *&#160;</td>
          <td class="paramname"><em>pUsbdCtxt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__cal__msg__t">cy_stc_usb_cal_msg_t</a> *&#160;</td>
          <td class="paramname"><em>pMsg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function handles L1-Sleep functionality. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pUsbdCtxt</td><td>USBD layer context pointer.</td></tr>
    <tr><td class="paramname">pMsg</td><td>pointer to message sent by bottom layer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CY_USBD_STATUS_SUCCESS if operation is successful. CY_USBD_STATUS_CTXT_NULL if usbd context is NULL. </dd></dl>

</div>
</div>
<a id="ga67523878eb2b163f65cbd127720f3e5a" name="ga67523878eb2b163f65cbd127720f3e5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga67523878eb2b163f65cbd127720f3e5a">&#9670;&nbsp;</a></span>Cy_USBD_HandleL1Resume()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#gae84a77ef84aee90fcb7773ad13acab34">cy_en_usbd_ret_code_t</a> Cy_USBD_HandleL1Resume </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__usbd__ctxt__t">cy_stc_usb_usbd_ctxt_t</a> *&#160;</td>
          <td class="paramname"><em>pUsbdCtxt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__cal__msg__t">cy_stc_usb_cal_msg_t</a> *&#160;</td>
          <td class="paramname"><em>pMsg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function handles L1-Resume functionality. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pUsbdCtxt</td><td>USBD layer context pointer.</td></tr>
    <tr><td class="paramname">pMsg</td><td>pointer to message sent by bottom layer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CY_USBD_STATUS_SUCCESS if operation is successful. </dd></dl>

</div>
</div>
<a id="ga827a7b13b1cab4ba28f70a5bee33701d" name="ga827a7b13b1cab4ba28f70a5bee33701d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga827a7b13b1cab4ba28f70a5bee33701d">&#9670;&nbsp;</a></span>Cy_USBD_HandleZlp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#gae84a77ef84aee90fcb7773ad13acab34">cy_en_usbd_ret_code_t</a> Cy_USBD_HandleZlp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__usbd__ctxt__t">cy_stc_usb_usbd_ctxt_t</a> *&#160;</td>
          <td class="paramname"><em>pUsbdCtxt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__cal__msg__t">cy_stc_usb_cal_msg_t</a> *&#160;</td>
          <td class="paramname"><em>pMsg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function handles Zero-Length-Packet. </p>
<p >This functionality applicable to HS controller.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pUsbdCtxt</td><td>USBD layer context pointer.</td></tr>
    <tr><td class="paramname">pMsg</td><td>pointer to message sent by bottom layer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CY_USBD_STATUS_SUCCESS if operation is successful. CY_USBD_STATUS_CTXT_NULL if usbd context is NULL. </dd></dl>

</div>
</div>
<a id="gaf311aceab08016ebaf211f4df1226385" name="gaf311aceab08016ebaf211f4df1226385"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf311aceab08016ebaf211f4df1226385">&#9670;&nbsp;</a></span>Cy_USBD_HandleDone()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#gae84a77ef84aee90fcb7773ad13acab34">cy_en_usbd_ret_code_t</a> Cy_USBD_HandleDone </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__usbd__ctxt__t">cy_stc_usb_usbd_ctxt_t</a> *&#160;</td>
          <td class="paramname"><em>pUsbdCtxt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__cal__msg__t">cy_stc_usb_cal_msg_t</a> *&#160;</td>
          <td class="paramname"><em>pMsg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function handles done interrupt for an endpoint. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pUsbdCtxt</td><td>USBD layer context pointer.</td></tr>
    <tr><td class="paramname">pMsg</td><td>pointer to message sent by bottom layer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CY_USBD_STATUS_SUCCESS if operation is successful. CY_USBD_STATUS_CTXT_NULL if usbd context is NULL. </dd></dl>

</div>
</div>
<a id="gadf1e3adb3e04d0cdcfe6a871d250e53e" name="gadf1e3adb3e04d0cdcfe6a871d250e53e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadf1e3adb3e04d0cdcfe6a871d250e53e">&#9670;&nbsp;</a></span>Cy_USBD_HandleRateChange()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#gae84a77ef84aee90fcb7773ad13acab34">cy_en_usbd_ret_code_t</a> Cy_USBD_HandleRateChange </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__usbd__ctxt__t">cy_stc_usb_usbd_ctxt_t</a> *&#160;</td>
          <td class="paramname"><em>pUsbdCtxt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__cal__msg__t">cy_stc_usb_cal_msg_t</a> *&#160;</td>
          <td class="paramname"><em>pMsg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function handles rate change. </p>
<p >This functionality is applicable to USB3 controller only.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pUsbdCtxt</td><td>USBD layer context pointer.</td></tr>
    <tr><td class="paramname">pMsg</td><td>pointer to message sent by bottom layer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CY_USBD_STATUS_SUCCESS if operation is successful. CY_USBD_STATUS_CTXT_NULL if usbd context is NULL. </dd></dl>

</div>
</div>
<a id="gafebe7d0add100f8fb32d3ff44b0e825d" name="gafebe7d0add100f8fb32d3ff44b0e825d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafebe7d0add100f8fb32d3ff44b0e825d">&#9670;&nbsp;</a></span>Cy_USBD_HandleSlp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#gae84a77ef84aee90fcb7773ad13acab34">cy_en_usbd_ret_code_t</a> Cy_USBD_HandleSlp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__usbd__ctxt__t">cy_stc_usb_usbd_ctxt_t</a> *&#160;</td>
          <td class="paramname"><em>pUsbdCtxt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__cal__msg__t">cy_stc_usb_cal_msg_t</a> *&#160;</td>
          <td class="paramname"><em>pMsg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function handles short length packet functionality. </p>
<p >This functionality is applicable to HS controller only.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pUsbdCtxt</td><td>USBD layer context pointer.</td></tr>
    <tr><td class="paramname">pMsg</td><td>pointer to message sent by bottom layer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CY_USBD_STATUS_SUCCESS if operation is successful. CY_USBD_STATUS_CTXT_NULL if usbd context is NULL. </dd></dl>

</div>
</div>
<a id="ga5223516b6ac49a76d31b99d0aa6f9928" name="ga5223516b6ac49a76d31b99d0aa6f9928"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5223516b6ac49a76d31b99d0aa6f9928">&#9670;&nbsp;</a></span>Cy_USBD_HandleSsDisconnect()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#gae84a77ef84aee90fcb7773ad13acab34">cy_en_usbd_ret_code_t</a> Cy_USBD_HandleSsDisconnect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__usbd__ctxt__t">cy_stc_usb_usbd_ctxt_t</a> *&#160;</td>
          <td class="paramname"><em>pUsbdCtxt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__cal__msg__t">cy_stc_usb_cal_msg_t</a> *&#160;</td>
          <td class="paramname"><em>pMsg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function handles disconnect event/message came from bottom layer. </p>
<p >Applicable to SS controller only.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pUsbdCtxt</td><td>USBD layer context pointer.</td></tr>
    <tr><td class="paramname">pMsg</td><td>pointer to message sent by bottom layer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CY_USBD_STATUS_SUCCESS if operation is successful. </dd></dl>

</div>
</div>
<a id="ga32b62782b26309ed4d23171293dded2e" name="ga32b62782b26309ed4d23171293dded2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga32b62782b26309ed4d23171293dded2e">&#9670;&nbsp;</a></span>Cy_USBD_HandleMsg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#gae84a77ef84aee90fcb7773ad13acab34">cy_en_usbd_ret_code_t</a> Cy_USBD_HandleMsg </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__usbd__ctxt__t">cy_stc_usb_usbd_ctxt_t</a> *&#160;</td>
          <td class="paramname"><em>pUsbdCtxt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__cal__msg__t">cy_stc_usb_cal_msg_t</a> *&#160;</td>
          <td class="paramname"><em>pMsg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function handles all messages comes from bottom layer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pUsbdCtxt</td><td>USBD layer context pointer.</td></tr>
    <tr><td class="paramname">pMsg</td><td>pointer to message sent by bottom layer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CY_USBD_STATUS_SUCCESS if operation is successful. CY_USBD_STATUS_CTXT_NULL if usbd context is NULL. </dd></dl>

</div>
</div>
<a id="gad326897e3fefec5263bcd4cdb9eaef10" name="gad326897e3fefec5263bcd4cdb9eaef10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad326897e3fefec5263bcd4cdb9eaef10">&#9670;&nbsp;</a></span>Cy_USBD_InitUsbDscrPtrs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cy_USBD_InitUsbDscrPtrs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__set__dscr__ptrs__t">cy_stc_usb_set_dscr_ptrs_t</a> *&#160;</td>
          <td class="paramname"><em>pDscr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function initializes all descriptor pointers to NULL. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pDscr</td><td>pointer to data structure where all descriptors are stored. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga420c764f5baa114d17721fd13a88f360" name="ga420c764f5baa114d17721fd13a88f360"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga420c764f5baa114d17721fd13a88f360">&#9670;&nbsp;</a></span>Cy_USBD_ConnectHsDevice()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cy_USBD_ConnectHsDevice </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__usbd__ctxt__t">cy_stc_usb_usbd_ctxt_t</a> *&#160;</td>
          <td class="paramname"><em>pUsbdCtxt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This functions connects HS device to BUS and make it visible to host. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pUsbdCtxt</td><td>USBD layer context pointer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga05b97a72fd09dee078bb40268f5f7a05" name="ga05b97a72fd09dee078bb40268f5f7a05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga05b97a72fd09dee078bb40268f5f7a05">&#9670;&nbsp;</a></span>Cy_USBD_ConnectSsDevice()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cy_USBD_ConnectSsDevice </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__usbd__ctxt__t">cy_stc_usb_usbd_ctxt_t</a> *&#160;</td>
          <td class="paramname"><em>pUsbdCtxt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This functions connects SS device to BUS and make it visible to host. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pUsbdCtxt</td><td>USBD layer context pointer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga7efde427e45f7e6259d44841ae04ec60" name="ga7efde427e45f7e6259d44841ae04ec60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7efde427e45f7e6259d44841ae04ec60">&#9670;&nbsp;</a></span>Cy_USBD_ConnectDevice()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cy_USBD_ConnectDevice </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__usbd__ctxt__t">cy_stc_usb_usbd_ctxt_t</a> *&#160;</td>
          <td class="paramname"><em>pUsbdCtxt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#ga0355d30a754a1ef18fec29f288f59880">cy_en_usb_speed_t</a>&#160;</td>
          <td class="paramname"><em>usbSpeed</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This functions connects USB device with given speed and make it visible on BUS. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pUsbdCtxt</td><td>USBD layer context pointer.</td></tr>
    <tr><td class="paramname">usbSpeed</td><td>usb device speed which need to be configured in controller HW. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga03dc549d3e78e8de9f50c1c56f509aee" name="ga03dc549d3e78e8de9f50c1c56f509aee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga03dc549d3e78e8de9f50c1c56f509aee">&#9670;&nbsp;</a></span>Cy_USBD_ResetUsbdCommonDs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cy_USBD_ResetUsbdCommonDs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__usbd__ctxt__t">cy_stc_usb_usbd_ctxt_t</a> *&#160;</td>
          <td class="paramname"><em>pUsbdCtxt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This functions reset all USBD common data structure. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pUsbdCtxt</td><td>USBD layer context pointer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga7354164ae4f00f64a4faab8afc55ea1d" name="ga7354164ae4f00f64a4faab8afc55ea1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7354164ae4f00f64a4faab8afc55ea1d">&#9670;&nbsp;</a></span>Cy_USBD_DisconnectHsDevice()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cy_USBD_DisconnectHsDevice </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__usbd__ctxt__t">cy_stc_usb_usbd_ctxt_t</a> *&#160;</td>
          <td class="paramname"><em>pUsbdCtxt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This functions dis-connects HS device from BUS and make it invisible to host. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pUsbdCtxt</td><td>USBD layer context pointer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaf1cc4cd8e7c2d90f8d781c0963a9492c" name="gaf1cc4cd8e7c2d90f8d781c0963a9492c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf1cc4cd8e7c2d90f8d781c0963a9492c">&#9670;&nbsp;</a></span>Cy_USBD_DisconnectSsDevice()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cy_USBD_DisconnectSsDevice </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__usbd__ctxt__t">cy_stc_usb_usbd_ctxt_t</a> *&#160;</td>
          <td class="paramname"><em>pUsbdCtxt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This functions dis-connects SS device from BUS and make it invisible to host. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pUsbdCtxt</td><td>USBD layer context pointer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gae5a37b29b528f0f3bf7bb399009c928f" name="gae5a37b29b528f0f3bf7bb399009c928f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae5a37b29b528f0f3bf7bb399009c928f">&#9670;&nbsp;</a></span>Cy_USBD_DisconnectDevice()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cy_USBD_DisconnectDevice </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__usbd__ctxt__t">cy_stc_usb_usbd_ctxt_t</a> *&#160;</td>
          <td class="paramname"><em>pUsbdCtxt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disconnect device from BUS. </p>
<p >This function should be called by module/layer who detects vbus insertion/removal.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pUsbdCtxt</td><td>USBD layer context pointer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga8dbb776b31f61a3ddf8a5efc7a23a60e" name="ga8dbb776b31f61a3ddf8a5efc7a23a60e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8dbb776b31f61a3ddf8a5efc7a23a60e">&#9670;&nbsp;</a></span>Cy_USB_USBD_InitEndp0InCpuDmaDscrConfig()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cy_USB_USBD_InitEndp0InCpuDmaDscrConfig </td>
          <td>(</td>
          <td class="paramtype">cy_stc_usbd_dma_descr_conf_t *&#160;</td>
          <td class="paramname"><em>pEndp0InCpuDmaDscrConfig</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>first</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>It initializes DMA descriptor for endpoint 0 IN transfer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pEndp0InCpuDmaDscrConfig</td><td>dma descriptor configuration.</td></tr>
    <tr><td class="paramname">first</td><td>first or other descriptor. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga474d6d8014027b257f437bbab2e499aa" name="ga474d6d8014027b257f437bbab2e499aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga474d6d8014027b257f437bbab2e499aa">&#9670;&nbsp;</a></span>Cy_USB_USBD_InitEndp0OutCpuDmaDscrConfig()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cy_USB_USBD_InitEndp0OutCpuDmaDscrConfig </td>
          <td>(</td>
          <td class="paramtype">cy_stc_usbd_dma_descr_conf_t *&#160;</td>
          <td class="paramname"><em>pEndp0OutdscrConfig</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>first</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>It initializes DMA descriptor for EP0-OUT transfers. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pEndp0OutdscrConfig</td><td>dma descriptor configuration.</td></tr>
    <tr><td class="paramname">first</td><td>first or other descriptor. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga2f21cb330a6041dda91d9f6bf613cf1a" name="ga2f21cb330a6041dda91d9f6bf613cf1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2f21cb330a6041dda91d9f6bf613cf1a">&#9670;&nbsp;</a></span>Cy_USB_USBD_InitCpuDmaChannelCfg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cy_USB_USBD_InitCpuDmaChannelCfg </td>
          <td>(</td>
          <td class="paramtype">cy_stc_usbd_dma_chn_conf_t *&#160;</td>
          <td class="paramname"><em>pDmaChCfg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cy_stc_usbd_dma_descr_t *&#160;</td>
          <td class="paramname"><em>pDmaDscr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>It initializes DMA channel config. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pDmaChCfg</td><td>dma channel configuration.</td></tr>
    <tr><td class="paramname">pDmaDscr</td><td>pointer to DMA descriptor. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga6b1a4edc99d170c691a20628850f4cff" name="ga6b1a4edc99d170c691a20628850f4cff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6b1a4edc99d170c691a20628850f4cff">&#9670;&nbsp;</a></span>Cy_USB_USBD_cpuDmaInit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#gae84a77ef84aee90fcb7773ad13acab34">cy_en_usbd_ret_code_t</a> Cy_USB_USBD_cpuDmaInit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__usbd__ctxt__t">cy_stc_usb_usbd_ctxt_t</a> *&#160;</td>
          <td class="paramname"><em>pUsbdCtxt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>It initializes Cpu DMA functionality. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pUsbdCtxt</td><td>USBD layer context pointer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CY_USBD_STATUS_SUCCESS if operation is successful. </dd></dl>

</div>
</div>
<a id="ga8c0f7cea82a43cb3c8a85b78e832a16d" name="ga8c0f7cea82a43cb3c8a85b78e832a16d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8c0f7cea82a43cb3c8a85b78e832a16d">&#9670;&nbsp;</a></span>Cy_USB_USBD_EndpInit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#gae84a77ef84aee90fcb7773ad13acab34">cy_en_usbd_ret_code_t</a> Cy_USB_USBD_EndpInit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__usbd__ctxt__t">cy_stc_usb_usbd_ctxt_t</a> *&#160;</td>
          <td class="paramname"><em>pUsbdCtxt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function initializes endpoint 0 and other endpoints for HS and SS controller. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pUsbdCtxt</td><td>USBD layer context pointer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CY_USBD_STATUS_SUCCESS if operation is successful. CY_USBD_STATUS_FAILURE in all other case. </dd></dl>

</div>
</div>
<a id="ga9e36a9d8b7ed2bfc6f511a75f04e4a9d" name="ga9e36a9d8b7ed2bfc6f511a75f04e4a9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9e36a9d8b7ed2bfc6f511a75f04e4a9d">&#9670;&nbsp;</a></span>Cy_USB_USBD_DisableHsDevice()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cy_USB_USBD_DisableHsDevice </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__usbd__ctxt__t">cy_stc_usb_usbd_ctxt_t</a> *&#160;</td>
          <td class="paramname"><em>pUsbdCtxt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function disable all HS device interrupt and make device invisible on BUS. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pUsbdCtxt</td><td>USBD layer context pointer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga711f5357e15324953d602f82b2dd5352" name="ga711f5357e15324953d602f82b2dd5352"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga711f5357e15324953d602f82b2dd5352">&#9670;&nbsp;</a></span>Cy_USB_USBD_EnableHsDevice()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cy_USB_USBD_EnableHsDevice </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__usbd__ctxt__t">cy_stc_usb_usbd_ctxt_t</a> *&#160;</td>
          <td class="paramname"><em>pUsbdCtxt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function enable HS device and make it visible on BUS. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pUsbdCtxt</td><td>USBD layer context pointer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga25f65d5819842984443338e3e1e53589" name="ga25f65d5819842984443338e3e1e53589"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga25f65d5819842984443338e3e1e53589">&#9670;&nbsp;</a></span>Cy_USBD_CtrlHSEnableOnCompliance()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cy_USBD_CtrlHSEnableOnCompliance </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__usbd__ctxt__t">cy_stc_usb_usbd_ctxt_t</a> *&#160;</td>
          <td class="paramname"><em>pUsbdCtxt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>hsEnable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function used to enable/disable switch to USB-HS (2.0) mode on entry into the USB 3.x Compliance LTSSM state. </p>
<p >This transition is left enabled on start-up and can be enabled through this API when device configurations that do not support USB-HS are being used.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pUsbdCtxt</td><td>USBD layer context pointer.</td></tr>
    <tr><td class="paramname">hsEnable</td><td>Whether transition into USB-HS is enabled. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gabdad35eff0a5a0edfafefd7e20dc04ee" name="gabdad35eff0a5a0edfafefd7e20dc04ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabdad35eff0a5a0edfafefd7e20dc04ee">&#9670;&nbsp;</a></span>Cy_USBD_TaskHandler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cy_USBD_TaskHandler </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pTaskParam</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function handles msg coming from CAL layer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pTaskParam</td><td>void pointer given to task handler. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga07d325da8e54e8406d237acb1a438fa3" name="ga07d325da8e54e8406d237acb1a438fa3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga07d325da8e54e8406d237acb1a438fa3">&#9670;&nbsp;</a></span>Cy_USBD_ProcessMsg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Cy_USBD_ProcessMsg </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pUsbd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pCalMgs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function sends msg to USBD thread. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pUsbd</td><td>void pointer carry USBD context.</td></tr>
    <tr><td class="paramname">pCalMgs</td><td>message prepared by CAL layer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether context switch is required at the end of the ISR which generated the message. </dd></dl>

</div>
</div>
<a id="gaead01314010be5d6a4d2e4ef9d8843ee" name="gaead01314010be5d6a4d2e4ef9d8843ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaead01314010be5d6a4d2e4ef9d8843ee">&#9670;&nbsp;</a></span>Cy_USBD_SendEgressZLP()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#gae84a77ef84aee90fcb7773ad13acab34">cy_en_usbd_ret_code_t</a> Cy_USBD_SendEgressZLP </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__usbd__ctxt__t">cy_stc_usb_usbd_ctxt_t</a> *&#160;</td>
          <td class="paramname"><em>pUsbdCtxt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>endpNumber</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function sends ZLP for given endpoint. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pUsbdCtxt</td><td>USBD layer context pointer.</td></tr>
    <tr><td class="paramname">endpNumber</td><td>endpoint number.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CY_USBD_STATUS_SUCCESS if operation is successful. CY_USBD_STATUS_CTXT_NULL if usbd context is NULL. CY_USBD_STATUS_FAILURE if function is called for FS/HS device. </dd></dl>

</div>
</div>
<a id="gaa8932a5f32ae3ffbd2d70ddc73795dae" name="gaa8932a5f32ae3ffbd2d70ddc73795dae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa8932a5f32ae3ffbd2d70ddc73795dae">&#9670;&nbsp;</a></span>Cy_USBD_ClearZlpSlpIntrEnableMask()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#gae84a77ef84aee90fcb7773ad13acab34">cy_en_usbd_ret_code_t</a> Cy_USBD_ClearZlpSlpIntrEnableMask </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__usbd__ctxt__t">cy_stc_usb_usbd_ctxt_t</a> *&#160;</td>
          <td class="paramname"><em>pUsbdCtxt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>endpNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#gaaebdfe5d46401ad52420b00ca401e6f8">cy_en_usb_endp_dir_t</a>&#160;</td>
          <td class="paramname"><em>endpDir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>zlpSlp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function clears endpoint interrupt for ingrress and egresss and enables respective mask register. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pUsbdCtxt</td><td>USBD layer context pointer.</td></tr>
    <tr><td class="paramname">endpNum</td><td>endpoint number.</td></tr>
    <tr><td class="paramname">endpDir</td><td>endpoint direction.</td></tr>
    <tr><td class="paramname">zlpSlp</td><td>true for zlp and false for slp.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CY_USBD_STATUS_SUCCESS if operation is successful. CY_USBD_STATUS_CTXT_NULL if usbd context is NULL. CY_USBD_STATUS_FAILURE if function is called for FS/HS device. </dd></dl>

</div>
</div>
<a id="gabd14f162a950f462d349632ca07d527a" name="gabd14f162a950f462d349632ca07d527a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabd14f162a950f462d349632ca07d527a">&#9670;&nbsp;</a></span>Cy_USB_LpmSetClearNYET()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#gae84a77ef84aee90fcb7773ad13acab34">cy_en_usbd_ret_code_t</a> Cy_USB_LpmSetClearNYET </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__usbd__ctxt__t">cy_stc_usb_usbd_ctxt_t</a> *&#160;</td>
          <td class="paramname"><em>pUsbdCtxt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>setClear</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is a stack internal function used to enable/disable LPM support. </p>
<p >Applications should always use Cy_USBD_LpmEnable and Cy_USBD_LpmDisable for this purpose.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pUsbdCtxt</td><td>USBD layer context pointer.</td></tr>
    <tr><td class="paramname">setClear</td><td>true for set and false for clear.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CY_USBD_STATUS_SUCCESS if operation is successful. CY_USBD_STATUS_FAILURE if status update failed. </dd></dl>

</div>
</div>
<a id="gaeabb052fbdb02fe439c1b225d605c8cc" name="gaeabb052fbdb02fe439c1b225d605c8cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaeabb052fbdb02fe439c1b225d605c8cc">&#9670;&nbsp;</a></span>Cy_USBD_GetUSBLinkActive()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#gae84a77ef84aee90fcb7773ad13acab34">cy_en_usbd_ret_code_t</a> Cy_USBD_GetUSBLinkActive </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__usbd__ctxt__t">cy_stc_usb_usbd_ctxt_t</a> *&#160;</td>
          <td class="paramname"><em>pUsbdCtxt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function ensures that the USB link is brought into the L0 (USB2) or U0 (USB3) state when the respective low power states. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pUsbdCtxt</td><td>USBD layer context pointer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CY_USBD_STATUS_SUCCESS if operation is successful. CY_USBD_STATUS_FAILURE if function is called for FS/HS device. </dd></dl>

</div>
</div>
<a id="gaa17017e98b5c349540a72d60c4d2f49b" name="gaa17017e98b5c349540a72d60c4d2f49b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa17017e98b5c349540a72d60c4d2f49b">&#9670;&nbsp;</a></span>Cy_USBD_LpmDisable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#gae84a77ef84aee90fcb7773ad13acab34">cy_en_usbd_ret_code_t</a> Cy_USBD_LpmDisable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__usbd__ctxt__t">cy_stc_usb_usbd_ctxt_t</a> *&#160;</td>
          <td class="paramname"><em>pUsbdCtxt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function disables all further transitions into a USB low power (U1, U2, or L1) state. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pUsbdCtxt</td><td>USBD layer context pointer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CY_USBD_STATUS_SUCCESS if operation is successful. CY_USBD_STATUS_CTXT_NULL if usbd context is NULL. CY_USBD_STATUS_FAILURE if function is called for FS/HS device. </dd></dl>

</div>
</div>
<a id="gaa97f804cfdf6b4f89626a82c558ba4ff" name="gaa97f804cfdf6b4f89626a82c558ba4ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa97f804cfdf6b4f89626a82c558ba4ff">&#9670;&nbsp;</a></span>Cy_USBD_LpmEnable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#gae84a77ef84aee90fcb7773ad13acab34">cy_en_usbd_ret_code_t</a> Cy_USBD_LpmEnable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__usbd__ctxt__t">cy_stc_usb_usbd_ctxt_t</a> *&#160;</td>
          <td class="paramname"><em>pUsbdCtxt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function re-enables state based transitions into USB low power (U1, U2 and L1) modes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pUsbdCtxt</td><td>USBD layer context pointer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CY_USBD_STATUS_SUCCESS if operation is successful. CY_USBD_STATUS_CTXT_NULL if usbd context is NULL. CY_USBD_STATUS_FAILURE if function is called for FS/HS device. </dd></dl>

</div>
</div>
<a id="ga4451fd6aadc9f43fc818a6511b5d745b" name="ga4451fd6aadc9f43fc818a6511b5d745b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4451fd6aadc9f43fc818a6511b5d745b">&#9670;&nbsp;</a></span>Cy_USB_USBD_RetireRecvEndp0DataSs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cy_USB_USBD_RetireRecvEndp0DataSs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__usbd__ctxt__t">cy_stc_usb_usbd_ctxt_t</a> *&#160;</td>
          <td class="paramname"><em>pUsbdCtxt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function will disable dma channel for SS which was submitted to recieve data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pUsbdCtxt</td><td>USBD layer context pointer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga5b92166b8c837f55481aa500b5261271" name="ga5b92166b8c837f55481aa500b5261271"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5b92166b8c837f55481aa500b5261271">&#9670;&nbsp;</a></span>Cy_USB_USBD_RetireRecvEndp0DataHs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cy_USB_USBD_RetireRecvEndp0DataHs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__usbd__ctxt__t">cy_stc_usb_usbd_ctxt_t</a> *&#160;</td>
          <td class="paramname"><em>pUsbdCtxt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function will disable dma channel for HS which was submitted to recieve data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pUsbdCtxt</td><td>Type of notification to be sent. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga5edcd886c977e547c5ca31c7b460c347" name="ga5edcd886c977e547c5ca31c7b460c347"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5edcd886c977e547c5ca31c7b460c347">&#9670;&nbsp;</a></span>Cy_USB_USBD_RetireRecvEndp0Data()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#gae84a77ef84aee90fcb7773ad13acab34">cy_en_usbd_ret_code_t</a> Cy_USB_USBD_RetireRecvEndp0Data </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__usbd__ctxt__t">cy_stc_usb_usbd_ctxt_t</a> *&#160;</td>
          <td class="paramname"><em>pUsbdCtxt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function will disable dma channel which was submitted to recieve data. </p>
<p >Common function for HS and SS.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pUsbdCtxt</td><td>Type of notification to be sent.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CY_USBD_STATUS_SUCCESS if operation is successful. CY_USBD_STATUS_CTXT_NULL if usbd context is NULL. </dd></dl>

</div>
</div>
<a id="ga24ba3ab096cd4feef6b1c288b690899e" name="ga24ba3ab096cd4feef6b1c288b690899e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga24ba3ab096cd4feef6b1c288b690899e">&#9670;&nbsp;</a></span>Cy_USBD_SendSSDeviceNotification()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#gae84a77ef84aee90fcb7773ad13acab34">cy_en_usbd_ret_code_t</a> Cy_USBD_SendSSDeviceNotification </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__usbd__ctxt__t">cy_stc_usb_usbd_ctxt_t</a> *&#160;</td>
          <td class="paramname"><em>pUsbdCtxt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#ga046dd04402c38ba57a541948326bea7b">cy_en_usbd_notification_type_t</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>param0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>param1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function sends a Device Notification Transaction Packet to the host controller on a USB 3.2 link. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pUsbdCtxt</td><td>Type of notification to be sent.</td></tr>
    <tr><td class="paramname">type</td><td>type of notification.</td></tr>
    <tr><td class="paramname">param0</td><td>24-bits of data to be added in DWORD1 of the TP.</td></tr>
    <tr><td class="paramname">param1</td><td>Data to be added in DWORD2 of the TP.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CY_USBD_STATUS_SUCCESS if operation is successful. CY_USBD_STATUS_CTXT_NULL if usbd context is NULL. CY_USBD_STATUS_FAILURE if function is called for FS/HS device. CY_USBD_STATUS_BAD_PARAM if type is not valid. </dd></dl>

</div>
</div>
<a id="ga5988904fa2be63f450f4ab76ec659b45" name="ga5988904fa2be63f450f4ab76ec659b45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5988904fa2be63f450f4ab76ec659b45">&#9670;&nbsp;</a></span>Cy_USBD_InitEventLog()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#gae84a77ef84aee90fcb7773ad13acab34">cy_en_usbd_ret_code_t</a> Cy_USBD_InitEventLog </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__usbd__ctxt__t">cy_stc_usb_usbd_ctxt_t</a> *&#160;</td>
          <td class="paramname"><em>pUsbdCtxt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>pEvtLogBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>evtLogSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enables capture of USB HS/SS driver events and state changes into RAM buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pUsbdCtxt</td><td>The pointer to the USBD context structure <a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__usbd__ctxt__t">cy_stc_usb_usbd_ctxt_t</a> allocated by the user.</td></tr>
    <tr><td class="paramname">pEvtLogBuf</td><td>RAM buffer pointer to log the data into. Can be NULL if logging is to be disabled.</td></tr>
    <tr><td class="paramname">evtLogSize</td><td>Size of RAM buffer in 32-bit words.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The status code of the function execution <a class="el" href="group__group__usbfxstack__usb__common__enums.html#gae84a77ef84aee90fcb7773ad13acab34">cy_en_usbd_ret_code_t</a>. </dd></dl>

</div>
</div>
<a id="ga51f51a314156345c4f9961a6dc74eaaa" name="ga51f51a314156345c4f9961a6dc74eaaa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga51f51a314156345c4f9961a6dc74eaaa">&#9670;&nbsp;</a></span>Cy_USBD_AddEvtToLog()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cy_USBD_AddEvtToLog </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__usbd__ctxt__t">cy_stc_usb_usbd_ctxt_t</a> *&#160;</td>
          <td class="paramname"><em>pUsbdCtxt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>evtId</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add USB event/state to the RAM log buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pUsbdCtxt</td><td>The pointer to the USBSS context structure <a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__usbd__ctxt__t">cy_stc_usb_usbd_ctxt_t</a>.</td></tr>
    <tr><td class="paramname">evtId</td><td>Event ID to be logged. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga1a7b6b16e9a08a83872cd309b3181b51" name="ga1a7b6b16e9a08a83872cd309b3181b51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1a7b6b16e9a08a83872cd309b3181b51">&#9670;&nbsp;</a></span>Cy_USBD_GetEvtLogIndex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t Cy_USBD_GetEvtLogIndex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__usbd__ctxt__t">cy_stc_usb_usbd_ctxt_t</a> *&#160;</td>
          <td class="paramname"><em>pUsbdCtxt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the current USB driver event log index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pUsbdCtxt</td><td>The pointer to the USBSS context structure <a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__usbd__ctxt__t">cy_stc_usb_usbd_ctxt_t</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Current event log index. </dd></dl>

</div>
</div>
<a id="gafb68a32a78e83c910476683bfb126fa2" name="gafb68a32a78e83c910476683bfb126fa2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafb68a32a78e83c910476683bfb126fa2">&#9670;&nbsp;</a></span>Cy_USBD_TickIncrement()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cy_USBD_TickIncrement </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__usbd__ctxt__t">cy_stc_usb_usbd_ctxt_t</a> *&#160;</td>
          <td class="paramname"><em>pUsbdCtxt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Increment the timer tick variable used to timestamp the USB event logs. </p>
<p >Should be called from SysTick interrupt handler.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pUsbdCtxt</td><td>The pointer to the USBSS context structure <a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__usbd__ctxt__t">cy_stc_usb_usbd_ctxt_t</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad5858b0970f3af6ceffbdb684a412bbb" name="gad5858b0970f3af6ceffbdb684a412bbb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad5858b0970f3af6ceffbdb684a412bbb">&#9670;&nbsp;</a></span>Cy_USBD_GetTimerTick()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t Cy_USBD_GetTimerTick </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve the current value of the timer tick. </p>
<dl class="section return"><dt>Returns</dt><dd>Current value of timestamp variable. </dd></dl>

</div>
</div>
<a id="gaab2f099dae9ad338dc39e6f0ca4683f6" name="gaab2f099dae9ad338dc39e6f0ca4683f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaab2f099dae9ad338dc39e6f0ca4683f6">&#9670;&nbsp;</a></span>Cy_USBD_EP0OutDma_IntrHandler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cy_USBD_EP0OutDma_IntrHandler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__usbd__ctxt__t">cy_stc_usb_usbd_ctxt_t</a> *&#160;</td>
          <td class="paramname"><em>pUsbdCtxt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Handler for interrupt associated with EP0-OUT DMA transfer in USB 2.x modes. </p>
<p >Should be called from the ISR registered for DMAC channel 1 which is used for EP0-OUT transfers.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pUsbdCtxt</td><td>USB stack context pointer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gab5dab22f472ba69a6aee8d29464e29f6" name="gab5dab22f472ba69a6aee8d29464e29f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab5dab22f472ba69a6aee8d29464e29f6">&#9670;&nbsp;</a></span>Cy_USBD_SetDmaClkFreq()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#gae84a77ef84aee90fcb7773ad13acab34">cy_en_usbd_ret_code_t</a> Cy_USBD_SetDmaClkFreq </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__usbd__ctxt__t">cy_stc_usb_usbd_ctxt_t</a> *&#160;</td>
          <td class="paramname"><em>pUsbdCtxt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__hb__dma__enums.html#gaf07a15620aa6ac9a13b4fffef4cf6a8c">cy_en_hbdma_clk_freq_t</a>&#160;</td>
          <td class="paramname"><em>dmaFreq</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function which sets the desired DMA clock frequency during USB 3.x operation on the FX3G2 device. </p>
<p >This function should be called before USB connection is enabled. The default clock selected is 240 MHz derived from USB2 PLL.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pUsbdCtxt</td><td>USB stack context pointer.</td></tr>
    <tr><td class="paramname">dmaFreq</td><td>Desired DMA clock frequency.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status code </dd></dl>

</div>
</div>
<a id="ga9b7af7161a52cf93c822dfa3d89f7f28" name="ga9b7af7161a52cf93c822dfa3d89f7f28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9b7af7161a52cf93c822dfa3d89f7f28">&#9670;&nbsp;</a></span>Cy_USBD_DisableLPMDeviceExit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cy_USBD_DisableLPMDeviceExit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__usbd__ctxt__t">cy_stc_usb_usbd_ctxt_t</a> *&#160;</td>
          <td class="paramname"><em>pUsbdCtxt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>devExitDisable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to disable support for device initiated exit from USB 3.x low power modes completely. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pUsbdCtxt</td><td>USB stack context pointer.</td></tr>
    <tr><td class="paramname">devExitDisable</td><td>true to disable device initiated exit from LPM states. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga9bc22556f358fd830746ff3305be8226" name="ga9bc22556f358fd830746ff3305be8226"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9bc22556f358fd830746ff3305be8226">&#9670;&nbsp;</a></span>Cy_USBHS_Cal_Init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cy_USBHS_Cal_Init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__cal__ctxt__t">cy_stc_usb_cal_ctxt_t</a> *&#160;</td>
          <td class="paramname"><em>pCalCtxt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pUsbdCtxt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__typedefs.html#gaeb0c3502dfb024979701c241f98ef8b6">cy_usb_cal_msg_callback_t</a>&#160;</td>
          <td class="paramname"><em>callBackFunc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes the HS controller ie CAL layer and PHY. </p>
<p >It also stores callback function and USBD layer context.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pCalCtxt</td><td>CAL layer context pointer.</td></tr>
    <tr><td class="paramname">pUsbdCtxt</td><td>USBd layer context pointer.</td></tr>
    <tr><td class="paramname">callBackFunc</td><td>Callback function provied by Upper layer ie USBD layer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga7c1c86e72768878c411c653324beca1b" name="ga7c1c86e72768878c411c653324beca1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7c1c86e72768878c411c653324beca1b">&#9670;&nbsp;</a></span>Cy_USBHS_Cal_FsHsModePhyInit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cy_USBHS_Cal_FsHsModePhyInit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__cal__ctxt__t">cy_stc_usb_cal_ctxt_t</a> *&#160;</td>
          <td class="paramname"><em>pCalCtxt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes high speed PHY. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pCalCtxt</td><td>CAL layer context pointer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga1b24e1816f2cd2217932da1146205bd9" name="ga1b24e1816f2cd2217932da1146205bd9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1b24e1816f2cd2217932da1146205bd9">&#9670;&nbsp;</a></span>Cy_USBHS_Cal_PhyCommonInit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cy_USBHS_Cal_PhyCommonInit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__cal__ctxt__t">cy_stc_usb_cal_ctxt_t</a> *&#160;</td>
          <td class="paramname"><em>pCalCtxt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes registers common to full and high speed PHY configuration. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pCalCtxt</td><td>CAL layer context pointer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga939724090c913bfed8c3c326e5d057c7" name="ga939724090c913bfed8c3c326e5d057c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga939724090c913bfed8c3c326e5d057c7">&#9670;&nbsp;</a></span>Cy_USBHS_Cal_HandleReset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#ga0d79c3063de7043b78fe79bae1e9278a">cy_en_usb_cal_ret_code_t</a> Cy_USBHS_Cal_HandleReset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__cal__ctxt__t">cy_stc_usb_cal_ctxt_t</a> *&#160;</td>
          <td class="paramname"><em>pCalCtxt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>During reset controller updates. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pCalCtxt</td><td>CAL layer context pointer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CY_USB_CAL_STATUS_SUCCESS if the operation is successful. CY_USB_CAL_STATUS_CAL_BASE_NULL if register base pointer is NULL. </dd></dl>

</div>
</div>
<a id="gad370055b2e98592aeb8f820671a4d3fc" name="gad370055b2e98592aeb8f820671a4d3fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad370055b2e98592aeb8f820671a4d3fc">&#9670;&nbsp;</a></span>Cy_USBHS_Cal_ConnUsbPins()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#ga0d79c3063de7043b78fe79bae1e9278a">cy_en_usb_cal_ret_code_t</a> Cy_USBHS_Cal_ConnUsbPins </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__cal__ctxt__t">cy_stc_usb_cal_ctxt_t</a> *&#160;</td>
          <td class="paramname"><em>pCalCtxt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Update USB device controller register to make USB device visible on Bus. </p>
<p >Once device is visible, host will start reset and Enumeration.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pCalCtxt</td><td>CAL layer context pointer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CY_USB_CAL_STATUS_SUCCESS if the operation is successful. CY_USB_CAL_STATUS_CAL_BASE_NULL if register base pointer is NULL. </dd></dl>

</div>
</div>
<a id="ga28c6f1e60a0fe051f775cb5f7d0e7845" name="ga28c6f1e60a0fe051f775cb5f7d0e7845"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga28c6f1e60a0fe051f775cb5f7d0e7845">&#9670;&nbsp;</a></span>Cy_USBHS_Cal_DisconUsbPins()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#ga0d79c3063de7043b78fe79bae1e9278a">cy_en_usb_cal_ret_code_t</a> Cy_USBHS_Cal_DisconUsbPins </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__cal__ctxt__t">cy_stc_usb_cal_ctxt_t</a> *&#160;</td>
          <td class="paramname"><em>pCalCtxt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Update Controller register to make USB device invisible on Bus. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pCalCtxt</td><td>CAL layer context pointer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CY_USB_CAL_STATUS_SUCCESS if the operation is successful. CY_USB_CAL_STATUS_CAL_BASE_NULL if register base pointer is NULL. </dd></dl>

</div>
</div>
<a id="gae64853fb68bd6e88ed6716cb790a8ed2" name="gae64853fb68bd6e88ed6716cb790a8ed2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae64853fb68bd6e88ed6716cb790a8ed2">&#9670;&nbsp;</a></span>Cy_USBHS_Cal_HsHandleL1Sleep()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cy_USBHS_Cal_HsHandleL1Sleep </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__cal__ctxt__t">cy_stc_usb_cal_ctxt_t</a> *&#160;</td>
          <td class="paramname"><em>pCalCtxt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>L1-SLEEP request during device in high speed mode will be handled here. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pCalCtxt</td><td>CAL layer context pointer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaa83e7606e372f52ea2049e98e974f795" name="gaa83e7606e372f52ea2049e98e974f795"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa83e7606e372f52ea2049e98e974f795">&#9670;&nbsp;</a></span>Cy_USBHS_Cal_HsHandleL1WakeupCommon()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cy_USBHS_Cal_HsHandleL1WakeupCommon </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__cal__ctxt__t">cy_stc_usb_cal_ctxt_t</a> *&#160;</td>
          <td class="paramname"><em>pCalCtxt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>L1-Wakeup request during device in high speed mode will be handled here. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pCalCtxt</td><td>CAL layer context pointer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga3393a803361af47e4965421f0cb1ad6e" name="ga3393a803361af47e4965421f0cb1ad6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3393a803361af47e4965421f0cb1ad6e">&#9670;&nbsp;</a></span>Cy_USBHS_Cal_DevInitiatedL1Exit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cy_USBHS_Cal_DevInitiatedL1Exit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__cal__ctxt__t">cy_stc_usb_cal_ctxt_t</a> *&#160;</td>
          <td class="paramname"><em>pCalCtxt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>duration</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function helps device to initiate resume from L1 SleepDevice. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pCalCtxt</td><td>CAL layer context pointer.</td></tr>
    <tr><td class="paramname">duration</td><td>LPM timing parameter as per Specification. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga5f5a1080209e357636ea9dab3a4d8e52" name="ga5f5a1080209e357636ea9dab3a4d8e52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5f5a1080209e357636ea9dab3a4d8e52">&#9670;&nbsp;</a></span>Cy_USBHS_Cal_DevInitiatedResumeL2Sleep()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cy_USBHS_Cal_DevInitiatedResumeL2Sleep </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__cal__ctxt__t">cy_stc_usb_cal_ctxt_t</a> *&#160;</td>
          <td class="paramname"><em>pCalCtxt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>duration</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function helps device to initiate resume from L2 SleepDevice. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pCalCtxt</td><td>CAL layer context pointer.</td></tr>
    <tr><td class="paramname">duration</td><td>LPM timing parameter as per Specification. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaa30aa365f558a6cf06db26e0e8f1cd6c" name="gaa30aa365f558a6cf06db26e0e8f1cd6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa30aa365f558a6cf06db26e0e8f1cd6c">&#9670;&nbsp;</a></span>Cy_USBHS_Cal_HsHandleL2SuspendEntry()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cy_USBHS_Cal_HsHandleL2SuspendEntry </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__cal__ctxt__t">cy_stc_usb_cal_ctxt_t</a> *&#160;</td>
          <td class="paramname"><em>pCalCtxt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>keepPllOn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function Handles Suspend at CAL layer in High speed mode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pCalCtxt</td><td>CAL layer context pointer.</td></tr>
    <tr><td class="paramname">keepPllOn</td><td>Whether to keep the PLL and references in the PHY ON. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaedcb2a6b720948390f1a4ef1ea5dde4a" name="gaedcb2a6b720948390f1a4ef1ea5dde4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaedcb2a6b720948390f1a4ef1ea5dde4a">&#9670;&nbsp;</a></span>Cy_USBHS_Cal_FsHandleSuspend()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cy_USBHS_Cal_FsHandleSuspend </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__cal__ctxt__t">cy_stc_usb_cal_ctxt_t</a> *&#160;</td>
          <td class="paramname"><em>pCalCtxt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function Handles Suspend at CAL layer in Full speed mode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pCalCtxt</td><td>CAL layer context pointer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga5cc027ca378a7158337cda401a891222" name="ga5cc027ca378a7158337cda401a891222"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5cc027ca378a7158337cda401a891222">&#9670;&nbsp;</a></span>Cy_USBHS_Cal_HsHandleL2Resume()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cy_USBHS_Cal_HsHandleL2Resume </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__cal__ctxt__t">cy_stc_usb_cal_ctxt_t</a> *&#160;</td>
          <td class="paramname"><em>pCalCtxt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function Handles resume at CAL layer in high speed mode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pCalCtxt</td><td>CAL layer context pointer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga36cfe1c678e7866932b900b034512a2d" name="ga36cfe1c678e7866932b900b034512a2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga36cfe1c678e7866932b900b034512a2d">&#9670;&nbsp;</a></span>Cy_USBHS_Cal_FsHandleResume()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cy_USBHS_Cal_FsHandleResume </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__cal__ctxt__t">cy_stc_usb_cal_ctxt_t</a> *&#160;</td>
          <td class="paramname"><em>pCalCtxt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function Handles resume at CAL layer in full speed mode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pCalCtxt</td><td>CAL layer context pointer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gabe11d33d22055e48992d5dc9df7af128" name="gabe11d33d22055e48992d5dc9df7af128"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabe11d33d22055e48992d5dc9df7af128">&#9670;&nbsp;</a></span>Cy_USBHS_Cal_IntrHandler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Cy_USBHS_Cal_IntrHandler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__cal__ctxt__t">cy_stc_usb_cal_ctxt_t</a> *&#160;</td>
          <td class="paramname"><em>pCalCtxt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function Handles All interrupt related to controller. </p>
<p >Based on interrupt required function will be invoked.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pCalCtxt</td><td>CAL layer context pointer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if yield is pending when the ISR returns, false otherwise. </dd></dl>

</div>
</div>
<a id="ga3947d7a658aaba60cd80df1bc6344056" name="ga3947d7a658aaba60cd80df1bc6344056"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3947d7a658aaba60cd80df1bc6344056">&#9670;&nbsp;</a></span>Cy_USBHS_Cal_EnableReqDevCtrlIntr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#ga0d79c3063de7043b78fe79bae1e9278a">cy_en_usb_cal_ret_code_t</a> Cy_USBHS_Cal_EnableReqDevCtrlIntr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__cal__ctxt__t">cy_stc_usb_cal_ctxt_t</a> *&#160;</td>
          <td class="paramname"><em>pCalCtxt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function will enable required interrupt under device ctrl reister. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pCalCtxt</td><td>CAL layer context pointer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CY_USB_CAL_STATUS_SUCCESS if the operation is successful. CY_USB_CAL_STATUS_CAL_BASE_NULL if register base pointer is NULL. </dd></dl>

</div>
</div>
<a id="gac23f4abaf8758644d41db48a92a1b7bd" name="gac23f4abaf8758644d41db48a92a1b7bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac23f4abaf8758644d41db48a92a1b7bd">&#9670;&nbsp;</a></span>Cy_USBHS_Cal_DisableAllDevCtrlIntr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#ga0d79c3063de7043b78fe79bae1e9278a">cy_en_usb_cal_ret_code_t</a> Cy_USBHS_Cal_DisableAllDevCtrlIntr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__cal__ctxt__t">cy_stc_usb_cal_ctxt_t</a> *&#160;</td>
          <td class="paramname"><em>pCalCtxt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function will disable all possible interrupt generated by USB device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pCalCtxt</td><td>CAL layer context pointer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CY_USB_CAL_STATUS_SUCCESS if the operation is successful. CY_USB_CAL_STATUS_CAL_BASE_NULL if register base pointer is NULL. </dd></dl>

</div>
</div>
<a id="ga366eea9bc1dbb3165ec248f73fc49b59" name="ga366eea9bc1dbb3165ec248f73fc49b59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga366eea9bc1dbb3165ec248f73fc49b59">&#9670;&nbsp;</a></span>Cy_USBHS_Cal_ClearAllDevCtrlIntr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#ga0d79c3063de7043b78fe79bae1e9278a">cy_en_usb_cal_ret_code_t</a> Cy_USBHS_Cal_ClearAllDevCtrlIntr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__cal__ctxt__t">cy_stc_usb_cal_ctxt_t</a> *&#160;</td>
          <td class="paramname"><em>pCalCtxt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function will clear all interrupt bit in device ctrl register. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pCalCtxt</td><td>CAL layer context pointer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CY_USB_CAL_STATUS_SUCCESS if the operation is successful. CY_USB_CAL_STATUS_CAL_BASE_NULL if register base pointer is NULL. </dd></dl>

</div>
</div>
<a id="ga8b996e4089a6b771b1a498701995512c" name="ga8b996e4089a6b771b1a498701995512c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8b996e4089a6b771b1a498701995512c">&#9670;&nbsp;</a></span>Cy_USBHS_Cal_UpdateEpIntrMask()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#ga0d79c3063de7043b78fe79bae1e9278a">cy_en_usb_cal_ret_code_t</a> Cy_USBHS_Cal_UpdateEpIntrMask </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__cal__ctxt__t">cy_stc_usb_cal_ctxt_t</a> *&#160;</td>
          <td class="paramname"><em>pCalCtxt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>endpNumber</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#gaaebdfe5d46401ad52420b00ca401e6f8">cy_en_usb_endp_dir_t</a>&#160;</td>
          <td class="paramname"><em>endpDirection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>epIntrMask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>setClear</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function updates the interrupt mask for an endpoint with the desired values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pCalCtxt</td><td>CAL layer context pointer.</td></tr>
    <tr><td class="paramname">endpNumber</td><td>Endpoint number.</td></tr>
    <tr><td class="paramname">endpDirection</td><td>Endpoint direction.</td></tr>
    <tr><td class="paramname">epIntrMask</td><td>Endpoint interrupt mask.</td></tr>
    <tr><td class="paramname">setClear</td><td>Interrupt Mask bits to be set or cleared.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CY_USB_CAL_STATUS_SUCCESS if the operation is successful. CY_USB_CAL_STATUS_CAL_BASE_NULL if register base pointer is NULL. </dd></dl>

</div>
</div>
<a id="ga7841011690ec5ad8dbe841829d20306b" name="ga7841011690ec5ad8dbe841829d20306b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7841011690ec5ad8dbe841829d20306b">&#9670;&nbsp;</a></span>Cy_USBHS_Cal_ClearZlpSlpIntrEnableMask()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#ga0d79c3063de7043b78fe79bae1e9278a">cy_en_usb_cal_ret_code_t</a> Cy_USBHS_Cal_ClearZlpSlpIntrEnableMask </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__cal__ctxt__t">cy_stc_usb_cal_ctxt_t</a> *&#160;</td>
          <td class="paramname"><em>pCalCtxt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>endpNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#gaaebdfe5d46401ad52420b00ca401e6f8">cy_en_usb_endp_dir_t</a>&#160;</td>
          <td class="paramname"><em>endpDir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>zlpSlp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function clears endpoint interrupt for ingress and egress intrrupt and enables respective mask register. </p>
<p >Writing 1 in intr register will clear the interrupt. writting 1 in mask register will enable that register.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pCalCtxt</td><td>CAL layer context pointer.</td></tr>
    <tr><td class="paramname">endpNum</td><td>Endpoint number.</td></tr>
    <tr><td class="paramname">endpDir</td><td>Endpoint direction.</td></tr>
    <tr><td class="paramname">zlpSlp</td><td>1 for ZLP and 0 for SLP.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CY_USB_CAL_STATUS_SUCCESS if the operation is successful. CY_USB_CAL_STATUS_CAL_BASE_NULL if register base pointer is NULL. </dd></dl>

</div>
</div>
<a id="gaf44e50a3135ee8273ce087d82c2c91fa" name="gaf44e50a3135ee8273ce087d82c2c91fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf44e50a3135ee8273ce087d82c2c91fa">&#9670;&nbsp;</a></span>Cy_USBHS_Cal_EnableCtrlSlpIntr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#ga0d79c3063de7043b78fe79bae1e9278a">cy_en_usb_cal_ret_code_t</a> Cy_USBHS_Cal_EnableCtrlSlpIntr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__cal__ctxt__t">cy_stc_usb_cal_ctxt_t</a> *&#160;</td>
          <td class="paramname"><em>pCalCtxt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function enables the SLP_RCVD interrupt for EP0-OUT. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pCalCtxt</td><td>CAL layer context pointer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CY_USB_CAL_STATUS_SUCCESS if the operation is successful. CY_USB_CAL_STATUS_CAL_BASE_NULL if register base pointer is NULL. </dd></dl>

</div>
</div>
<a id="ga4b36a9828cf153c27c8af3b4a07a09a2" name="ga4b36a9828cf153c27c8af3b4a07a09a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4b36a9828cf153c27c8af3b4a07a09a2">&#9670;&nbsp;</a></span>Cy_USBHS_Cal_DisableCtrlSlpIntr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#ga0d79c3063de7043b78fe79bae1e9278a">cy_en_usb_cal_ret_code_t</a> Cy_USBHS_Cal_DisableCtrlSlpIntr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__cal__ctxt__t">cy_stc_usb_cal_ctxt_t</a> *&#160;</td>
          <td class="paramname"><em>pCalCtxt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function disable the SLP_RCVD interrupt for EP0-OUT. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pCalCtxt</td><td>CAL layer context pointer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CY_USB_CAL_STATUS_SUCCESS if the operation is successful. CY_USB_CAL_STATUS_CAL_BASE_NULL if register base pointer is NULL. </dd></dl>

</div>
</div>
<a id="ga61ef4a767f73fb590c763f4dc215c6e0" name="ga61ef4a767f73fb590c763f4dc215c6e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga61ef4a767f73fb590c763f4dc215c6e0">&#9670;&nbsp;</a></span>Cy_USBHS_Cal_EnableEndp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#ga0d79c3063de7043b78fe79bae1e9278a">cy_en_usb_cal_ret_code_t</a> Cy_USBHS_Cal_EnableEndp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__cal__ctxt__t">cy_stc_usb_cal_ctxt_t</a> *&#160;</td>
          <td class="paramname"><em>pCalCtxt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>endpNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#gaaebdfe5d46401ad52420b00ca401e6f8">cy_en_usb_endp_dir_t</a>&#160;</td>
          <td class="paramname"><em>endpDir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function enables/disable endpoint and set/reset respective interrupt. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pCalCtxt</td><td>CAL layer context pointer.</td></tr>
    <tr><td class="paramname">endpNum</td><td>Endpoint number.</td></tr>
    <tr><td class="paramname">endpDir</td><td>Endpoint direction.</td></tr>
    <tr><td class="paramname">enable</td><td>1 for enable and 0 for disable.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CY_USB_CAL_STATUS_SUCCESS if the operation is successful. CY_USB_CAL_STATUS_BAD_PARAM if direction and endpoint number invalid. CY_USB_CAL_STATUS_CAL_BASE_NULL if register base pointer is NULL. </dd></dl>

</div>
</div>
<a id="ga318e82f99894d49e4ee5b2719826d9b2" name="ga318e82f99894d49e4ee5b2719826d9b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga318e82f99894d49e4ee5b2719826d9b2">&#9670;&nbsp;</a></span>Cy_USBHS_Cal_EndpConfig()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#ga0d79c3063de7043b78fe79bae1e9278a">cy_en_usb_cal_ret_code_t</a> Cy_USBHS_Cal_EndpConfig </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__cal__ctxt__t">cy_stc_usb_cal_ctxt_t</a> *&#160;</td>
          <td class="paramname"><em>pCalCtxt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__endp__config__t">cy_stc_usb_endp_config_t</a>&#160;</td>
          <td class="paramname"><em>configParam</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function handles configuration of endpoint. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pCalCtxt</td><td>CAL layer context pointer.</td></tr>
    <tr><td class="paramname">configParam</td><td>Contains all config parameters.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CY_USB_CAL_STATUS_SUCCESS if the operation is successful. CY_USB_CAL_STATUS_BAD_PARAM if direction and endpoint number invalid. CY_USB_CAL_STATUS_CAL_BASE_NULL if register base pointer is NULL. </dd></dl>

</div>
</div>
<a id="ga4ae38bbb375b4b928690a4b1a0fc0d58" name="ga4ae38bbb375b4b928690a4b1a0fc0d58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4ae38bbb375b4b928690a4b1a0fc0d58">&#9670;&nbsp;</a></span>Cy_USBHS_Cal_UpdateXferCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#ga0d79c3063de7043b78fe79bae1e9278a">cy_en_usb_cal_ret_code_t</a> Cy_USBHS_Cal_UpdateXferCount </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__cal__ctxt__t">cy_stc_usb_cal_ctxt_t</a> *&#160;</td>
          <td class="paramname"><em>pCalCtxt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>endpNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#gaaebdfe5d46401ad52420b00ca401e6f8">cy_en_usb_endp_dir_t</a>&#160;</td>
          <td class="paramname"><em>endpDir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>xferCount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function updates register with transfer count. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pCalCtxt</td><td>CAL layer context pointer.</td></tr>
    <tr><td class="paramname">endpNum</td><td>Endpoint number.</td></tr>
    <tr><td class="paramname">endpDir</td><td>Endpoint direction.</td></tr>
    <tr><td class="paramname">xferCount</td><td>transfer count.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CY_USB_CAL_STATUS_SUCCESS if the operation is successful. CY_USB_CAL_STATUS_BAD_PARAM if direction and endpoint number invalid. CY_USB_CAL_STATUS_CAL_BASE_NULL if register base pointer is NULL. </dd></dl>

</div>
</div>
<a id="ga58d868ff6ae4dcd0678a1f87bf3b9a3b" name="ga58d868ff6ae4dcd0678a1f87bf3b9a3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga58d868ff6ae4dcd0678a1f87bf3b9a3b">&#9670;&nbsp;</a></span>Cy_USBHS_Cal_EndpSetClearNak()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#ga0d79c3063de7043b78fe79bae1e9278a">cy_en_usb_cal_ret_code_t</a> Cy_USBHS_Cal_EndpSetClearNak </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__cal__ctxt__t">cy_stc_usb_cal_ctxt_t</a> *&#160;</td>
          <td class="paramname"><em>pCalCtxt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>endpNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#gaaebdfe5d46401ad52420b00ca401e6f8">cy_en_usb_endp_dir_t</a>&#160;</td>
          <td class="paramname"><em>endpDir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>setClear</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function enable or disable NAK condition in hw. </p>
<p >By setting NAK bit, endpoint will keep sending NAK till NAK bit is cleared.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pCalCtxt</td><td>CAL layer context pointer.</td></tr>
    <tr><td class="paramname">endpNum</td><td>Endpoint number.</td></tr>
    <tr><td class="paramname">endpDir</td><td>Endpoint direction.</td></tr>
    <tr><td class="paramname">setClear</td><td>1 for set and 0 for clear.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CY_USB_CAL_STATUS_SUCCESS if the operation is successful. CY_USB_CAL_STATUS_BAD_PARAM if direction and endpoint number invalid. CY_USB_CAL_STATUS_CAL_BASE_NULL if register base pointer is NULL. </dd></dl>

</div>
</div>
<a id="gafbf101b9a4b4dc1fe7b273471e3afda3" name="gafbf101b9a4b4dc1fe7b273471e3afda3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafbf101b9a4b4dc1fe7b273471e3afda3">&#9670;&nbsp;</a></span>Cy_USBHS_Cal_SetClearNakAll()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#ga0d79c3063de7043b78fe79bae1e9278a">cy_en_usb_cal_ret_code_t</a> Cy_USBHS_Cal_SetClearNakAll </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__cal__ctxt__t">cy_stc_usb_cal_ctxt_t</a> *&#160;</td>
          <td class="paramname"><em>pCalCtxt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>setClear</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function either set or clear NAK for all endpoint. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pCalCtxt</td><td>CAL layer context pointer.</td></tr>
    <tr><td class="paramname">setClear</td><td>1 for set and 0 for clear.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CY_USB_CAL_STATUS_SUCCESS if the operation is successful. CY_USB_CAL_STATUS_CAL_BASE_NULL if register base pointer is NULL. </dd></dl>

</div>
</div>
<a id="ga705fc19fa8352f83d859478975c307d3" name="ga705fc19fa8352f83d859478975c307d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga705fc19fa8352f83d859478975c307d3">&#9670;&nbsp;</a></span>Cy_USBHS_Cal_EndpIsNakNrdySet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Cy_USBHS_Cal_EndpIsNakNrdySet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__cal__ctxt__t">cy_stc_usb_cal_ctxt_t</a> *&#160;</td>
          <td class="paramname"><em>pCalCtxt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>endpNumber</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#gaaebdfe5d46401ad52420b00ca401e6f8">cy_en_usb_endp_dir_t</a>&#160;</td>
          <td class="paramname"><em>endpDirection</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function checks endpoint's status related to NAK bit is set or reset. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pCalCtxt</td><td>CAL layer context pointer.</td></tr>
    <tr><td class="paramname">endpNumber</td><td>Endpoint number.</td></tr>
    <tr><td class="paramname">endpDirection</td><td>Endpoint direction.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if NAK bit is set. 0 if NAK bit is reset. </dd></dl>

</div>
</div>
<a id="ga368c6a300743075228663db03a804c37" name="ga368c6a300743075228663db03a804c37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga368c6a300743075228663db03a804c37">&#9670;&nbsp;</a></span>Cy_USBHS_Cal_EndpSetClearStall()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#ga0d79c3063de7043b78fe79bae1e9278a">cy_en_usb_cal_ret_code_t</a> Cy_USBHS_Cal_EndpSetClearStall </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__cal__ctxt__t">cy_stc_usb_cal_ctxt_t</a> *&#160;</td>
          <td class="paramname"><em>pCalCtxt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>endpNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#gaaebdfe5d46401ad52420b00ca401e6f8">cy_en_usb_endp_dir_t</a>&#160;</td>
          <td class="paramname"><em>endpDir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>setClear</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function enable or disable STALL condition in hw. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pCalCtxt</td><td>CAL layer context pointer.</td></tr>
    <tr><td class="paramname">endpNum</td><td>Endpoint number.</td></tr>
    <tr><td class="paramname">endpDir</td><td>Endpoint direction.</td></tr>
    <tr><td class="paramname">setClear</td><td>1 for set and 0 for clear.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CY_USB_CAL_STATUS_SUCCESS if the operation is successful. CY_USB_CAL_STATUS_BAD_PARAM if direction and endpoint number invalid. CY_USB_CAL_STATUS_CAL_BASE_NULL if register base pointer is NULL. </dd></dl>

</div>
</div>
<a id="gaab7605784f1b0db0700a92566fd11cda" name="gaab7605784f1b0db0700a92566fd11cda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaab7605784f1b0db0700a92566fd11cda">&#9670;&nbsp;</a></span>Cy_USBHS_Cal_EndpIsStallSet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Cy_USBHS_Cal_EndpIsStallSet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__cal__ctxt__t">cy_stc_usb_cal_ctxt_t</a> *&#160;</td>
          <td class="paramname"><em>pCalCtxt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>endpNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#gaaebdfe5d46401ad52420b00ca401e6f8">cy_en_usb_endp_dir_t</a>&#160;</td>
          <td class="paramname"><em>endpDir</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function checks whether the specified endpoint is currently in the STALLed state. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pCalCtxt</td><td>CAL layer context pointer.</td></tr>
    <tr><td class="paramname">endpNum</td><td>Endpoint number.</td></tr>
    <tr><td class="paramname">endpDir</td><td>Endpoint direction.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if NAK bit is set. 0 if NAK bit is reset. </dd></dl>

</div>
</div>
<a id="ga29778c9bc2fb8e75b5dcb9648bd15dcf" name="ga29778c9bc2fb8e75b5dcb9648bd15dcf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga29778c9bc2fb8e75b5dcb9648bd15dcf">&#9670;&nbsp;</a></span>Cy_USBHS_Cal_FlushEndp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#ga0d79c3063de7043b78fe79bae1e9278a">cy_en_usb_cal_ret_code_t</a> Cy_USBHS_Cal_FlushEndp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__cal__ctxt__t">cy_stc_usb_cal_ctxt_t</a> *&#160;</td>
          <td class="paramname"><em>pCalCtxt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>endpNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#gaaebdfe5d46401ad52420b00ca401e6f8">cy_en_usb_endp_dir_t</a>&#160;</td>
          <td class="paramname"><em>endpDir</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function will flush data available in perticular endpoint FIFO. </p>
<p >High speed USB IP supports flush functionality only for IN endpoint.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pCalCtxt</td><td>CAL layer context pointer.</td></tr>
    <tr><td class="paramname">endpNum</td><td>Endpoint number.</td></tr>
    <tr><td class="paramname">endpDir</td><td>Endpoint direction.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CY_USB_CAL_STATUS_SUCCESS if the operation is successful. CY_USB_CAL_STATUS_BAD_PARAM if direction and endpoint number invalid. CY_USB_CAL_STATUS_CAL_BASE_NULL if register base pointer is NULL. </dd></dl>

</div>
</div>
<a id="ga2ea5a8287848d8da27a9a85f300014a4" name="ga2ea5a8287848d8da27a9a85f300014a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2ea5a8287848d8da27a9a85f300014a4">&#9670;&nbsp;</a></span>Cy_USBHS_Cal_FlushAllEndp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#ga0d79c3063de7043b78fe79bae1e9278a">cy_en_usb_cal_ret_code_t</a> Cy_USBHS_Cal_FlushAllEndp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__cal__ctxt__t">cy_stc_usb_cal_ctxt_t</a> *&#160;</td>
          <td class="paramname"><em>pCalCtxt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function will flush data available in all Ingress and egress endpoint FIFO. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pCalCtxt</td><td>CAL layer context pointer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CY_USB_CAL_STATUS_SUCCESS if the operation is successful. CY_USB_CAL_STATUS_CAL_BASE_NULL if register base pointer is NULL. </dd></dl>

</div>
</div>
<a id="ga3d74512df96ccfb9af7b42560353a3be" name="ga3d74512df96ccfb9af7b42560353a3be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3d74512df96ccfb9af7b42560353a3be">&#9670;&nbsp;</a></span>Cy_USBHS_Cal_SendEgressZLP()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#ga0d79c3063de7043b78fe79bae1e9278a">cy_en_usb_cal_ret_code_t</a> Cy_USBHS_Cal_SendEgressZLP </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__cal__ctxt__t">cy_stc_usb_cal_ctxt_t</a> *&#160;</td>
          <td class="paramname"><em>pCalCtxt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>endpNum</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function triggers sending of a ZLP on an Egress endpoint. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pCalCtxt</td><td>CAL layer context pointer.</td></tr>
    <tr><td class="paramname">endpNum</td><td>Endpoint number.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CY_USB_CAL_STATUS_SUCCESS if the operation is successful. CY_USB_CAL_STATUS_BAD_PARAM if direction and endpoint number invalid. CY_USB_CAL_STATUS_CAL_BASE_NULL if register base pointer is NULL. </dd></dl>

</div>
</div>
<a id="gaa952a9e2d5db22702f1d9824f7f3905e" name="gaa952a9e2d5db22702f1d9824f7f3905e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa952a9e2d5db22702f1d9824f7f3905e">&#9670;&nbsp;</a></span>Cy_USBHS_Cal_HandleCtrlOutSlp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#ga0d79c3063de7043b78fe79bae1e9278a">cy_en_usb_cal_ret_code_t</a> Cy_USBHS_Cal_HandleCtrlOutSlp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__cal__ctxt__t">cy_stc_usb_cal_ctxt_t</a> *&#160;</td>
          <td class="paramname"><em>pCalCtxt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function clears SLP ingress interrupt. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pCalCtxt</td><td>CAL layer context pointer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CY_USB_CAL_STATUS_SUCCESS if the operation is successful. CY_USB_CAL_STATUS_CAL_BASE_NULL if register base pointer is NULL. </dd></dl>

</div>
</div>
<a id="ga9ee6d92fd4206586b0f5a907ff046d77" name="ga9ee6d92fd4206586b0f5a907ff046d77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9ee6d92fd4206586b0f5a907ff046d77">&#9670;&nbsp;</a></span>Cy_USBHS_Cal_CtrlEndp0DataOutAck()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#ga0d79c3063de7043b78fe79bae1e9278a">cy_en_usb_cal_ret_code_t</a> Cy_USBHS_Cal_CtrlEndp0DataOutAck </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__cal__ctxt__t">cy_stc_usb_cal_ctxt_t</a> *&#160;</td>
          <td class="paramname"><em>pCalCtxt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>setClear</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Data stage ACK for endpoint0 is controlled by this function. </p>
<p >In USBHS, when "CONT_TO_DATA" bit is set then controller wont send ACK till data is validated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pCalCtxt</td><td>CAL layer context pointer.</td></tr>
    <tr><td class="paramname">setClear</td><td>1 for set and 0 for clear.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CY_USB_CAL_STATUS_SUCCESS if the operation is successful. CY_USB_CAL_STATUS_CAL_BASE_NULL if register base pointer is NULL. </dd></dl>

</div>
</div>
<a id="gad65e7dc1465ebf8541049a30743c050e" name="gad65e7dc1465ebf8541049a30743c050e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad65e7dc1465ebf8541049a30743c050e">&#9670;&nbsp;</a></span>Cy_USBHS_Cal_SendAckSetupDataStatusStage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#ga0d79c3063de7043b78fe79bae1e9278a">cy_en_usb_cal_ret_code_t</a> Cy_USBHS_Cal_SendAckSetupDataStatusStage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__cal__ctxt__t">cy_stc_usb_cal_ctxt_t</a> *&#160;</td>
          <td class="paramname"><em>pCalCtxt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function update register so that device will send ACK to complete control transfer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pCalCtxt</td><td>CAL layer context pointer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CY_USB_CAL_STATUS_SUCCESS if the operation is successful. CY_USB_CAL_STATUS_CAL_BASE_NULL if register base pointer is NULL. </dd></dl>

</div>
</div>
<a id="gac09e969f050fbcc9997d92f04843ea34" name="gac09e969f050fbcc9997d92f04843ea34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac09e969f050fbcc9997d92f04843ea34">&#9670;&nbsp;</a></span>Cy_USBHS_Cal_GetRemoteWakeupStatus()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Cy_USBHS_Cal_GetRemoteWakeupStatus </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__cal__ctxt__t">cy_stc_usb_cal_ctxt_t</a> *&#160;</td>
          <td class="paramname"><em>pCalCtxt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function returns status of L2 remote wakeup in HW. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pCalCtxt</td><td>CAL layer context pointer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if L2 remote wakeup is enabled. false if L2 remote wakeup is disabled. </dd></dl>

</div>
</div>
<a id="gaedb9ab2fc0b386244b5aa885a115f318" name="gaedb9ab2fc0b386244b5aa885a115f318"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaedb9ab2fc0b386244b5aa885a115f318">&#9670;&nbsp;</a></span>Cy_USBHS_Cal_GetL1RemoteWakeupStatus()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Cy_USBHS_Cal_GetL1RemoteWakeupStatus </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__cal__ctxt__t">cy_stc_usb_cal_ctxt_t</a> *&#160;</td>
          <td class="paramname"><em>pCalCtxt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function returns status of L1 remote wakeup in HW. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pCalCtxt</td><td>CAL layer context pointer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if L1 remote wakeup is enabled. false if L1 remote wakeup is disabled. </dd></dl>

</div>
</div>
<a id="ga7f2fc1ed33c68775286b4b694454edb3" name="ga7f2fc1ed33c68775286b4b694454edb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7f2fc1ed33c68775286b4b694454edb3">&#9670;&nbsp;</a></span>Cy_USBHS_Cal_SignalRemotWakup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#ga0d79c3063de7043b78fe79bae1e9278a">cy_en_usb_cal_ret_code_t</a> Cy_USBHS_Cal_SignalRemotWakup </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__cal__ctxt__t">cy_stc_usb_cal_ctxt_t</a> *&#160;</td>
          <td class="paramname"><em>pCalCtxt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>startEndSignal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function will update register so that device will initiate remote wakeup signaling ie it will try to comeout from L2_SUSPEND. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pCalCtxt</td><td>CAL layer context pointer.</td></tr>
    <tr><td class="paramname">startEndSignal</td><td>Input to tell either start or end signaling.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CY_USB_CAL_STATUS_SUCCESS if the operation is successful. CY_USB_CAL_STATUS_CAL_BASE_NULL if register base pointer is NULL. </dd></dl>

</div>
</div>
<a id="ga5c825bb623438c0a4922e9b7a4426693" name="ga5c825bb623438c0a4922e9b7a4426693"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5c825bb623438c0a4922e9b7a4426693">&#9670;&nbsp;</a></span>Cy_USBHS_Cal_SetTestMode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#ga0d79c3063de7043b78fe79bae1e9278a">cy_en_usb_cal_ret_code_t</a> Cy_USBHS_Cal_SetTestMode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__cal__ctxt__t">cy_stc_usb_cal_ctxt_t</a> *&#160;</td>
          <td class="paramname"><em>pCalCtxt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#gaca7d219d5830d2365bfc9523d1a3cd0e">cy_en_usbhs_cal_test_mode_t</a>&#160;</td>
          <td class="paramname"><em>testMode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function will update register to setup required test mode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pCalCtxt</td><td>CAL layer context pointer.</td></tr>
    <tr><td class="paramname">testMode</td><td>perticular test mode.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CY_USB_CAL_STATUS_SUCCESS if the operation is successful. CY_USB_CAL_STATUS_CAL_BASE_NULL if register base pointer is NULL. </dd></dl>

</div>
</div>
<a id="ga00c6f4e593c4d471b9c4e1ec0bbb9662" name="ga00c6f4e593c4d471b9c4e1ec0bbb9662"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga00c6f4e593c4d471b9c4e1ec0bbb9662">&#9670;&nbsp;</a></span>Cy_USBHS_Cal_LpmSetClearNYET()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#ga0d79c3063de7043b78fe79bae1e9278a">cy_en_usb_cal_ret_code_t</a> Cy_USBHS_Cal_LpmSetClearNYET </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__cal__ctxt__t">cy_stc_usb_cal_ctxt_t</a> *&#160;</td>
          <td class="paramname"><em>pCalCtxt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>setClear</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function either set or clear NYET bit for LPM response. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pCalCtxt</td><td>CAL layer context pointer.</td></tr>
    <tr><td class="paramname">setClear</td><td>1 for set and 0 for clear.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CY_USB_CAL_STATUS_SUCCESS if the operation is successful. CY_USB_CAL_STATUS_CAL_BASE_NULL if register base pointer is NULL. </dd></dl>

</div>
</div>
<a id="ga77ac6f8613e2d12dd94256a80b8f793c" name="ga77ac6f8613e2d12dd94256a80b8f793c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga77ac6f8613e2d12dd94256a80b8f793c">&#9670;&nbsp;</a></span>Cy_USBHS_Cal_SetControllerSpeed()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#ga0d79c3063de7043b78fe79bae1e9278a">cy_en_usb_cal_ret_code_t</a> Cy_USBHS_Cal_SetControllerSpeed </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__cal__ctxt__t">cy_stc_usb_cal_ctxt_t</a> *&#160;</td>
          <td class="paramname"><em>pCalCtxt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#ga0355d30a754a1ef18fec29f288f59880">cy_en_usb_speed_t</a>&#160;</td>
          <td class="paramname"><em>speed</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function set controller speed to FS or HS. </p>
<p >If explicitly FS is not mentioned then function will set speed to HS.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pCalCtxt</td><td>CAL layer context pointer.</td></tr>
    <tr><td class="paramname">speed</td><td>iether HS or FS.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CY_USB_CAL_STATUS_SUCCESS if the operation is successful. CY_USB_CAL_STATUS_CAL_BASE_NULL if register base pointer is NULL. </dd></dl>

</div>
</div>
<a id="ga3e321098fc4ec0f7c57467afbe000847" name="ga3e321098fc4ec0f7c57467afbe000847"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3e321098fc4ec0f7c57467afbe000847">&#9670;&nbsp;</a></span>Cy_USBHS_Cal_GetDevAddress()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#ga0d79c3063de7043b78fe79bae1e9278a">cy_en_usb_cal_ret_code_t</a> Cy_USBHS_Cal_GetDevAddress </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__cal__ctxt__t">cy_stc_usb_cal_ctxt_t</a> *&#160;</td>
          <td class="paramname"><em>pCalCtxt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>pDevAddr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function will get device address assigned by Host. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pCalCtxt</td><td>CAL layer context pointer.</td></tr>
    <tr><td class="paramname">pDevAddr</td><td>Address of device will be stored here.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CY_USB_CAL_STATUS_SUCCESS if the operation is successful. CY_USB_CAL_STATUS_BAD_PARAM if direction and endpoint number invalid. CY_USB_CAL_STATUS_CAL_BASE_NULL if register base pointer is NULL. </dd></dl>

</div>
</div>
<a id="ga0af855ce9d53226ab85b4c3a482a4aed" name="ga0af855ce9d53226ab85b4c3a482a4aed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0af855ce9d53226ab85b4c3a482a4aed">&#9670;&nbsp;</a></span>Cy_USBHS_Cal_GetLinkActive()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#ga0d79c3063de7043b78fe79bae1e9278a">cy_en_usb_cal_ret_code_t</a> Cy_USBHS_Cal_GetLinkActive </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__cal__ctxt__t">cy_stc_usb_cal_ctxt_t</a> *&#160;</td>
          <td class="paramname"><em>pCalCtxt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function makes sure that the USB 2.x link gets into the L0 state if it is in L1. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pCalCtxt</td><td>CAL layer context pointer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CY_USB_CAL_STATUS_SUCCESS if the operation is successful. CY_USB_CAL_STATUS_CAL_BASE_NULL if register base pointer is NULL. </dd></dl>

</div>
</div>
<a id="ga8ac7dc6505e76c005b5bdb05db064bb1" name="ga8ac7dc6505e76c005b5bdb05db064bb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8ac7dc6505e76c005b5bdb05db064bb1">&#9670;&nbsp;</a></span>Cy_USBHS_Cal_SendMsg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Cy_USBHS_Cal_SendMsg </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__cal__ctxt__t">cy_stc_usb_cal_ctxt_t</a> *&#160;</td>
          <td class="paramname"><em>pCalCtxt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pMsg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function send message to upper layer ie USBD layer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pCalCtxt</td><td>CAL layer context pointer.</td></tr>
    <tr><td class="paramname">pMsg</td><td>message will be given to upper layer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether context switch is required at the end of the callback. </dd></dl>

</div>
</div>
<a id="gac6f0a2112cf786e800c8da2e5df81922" name="gac6f0a2112cf786e800c8da2e5df81922"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac6f0a2112cf786e800c8da2e5df81922">&#9670;&nbsp;</a></span>Cy_USBHS_Cal_DeinitPLL()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#ga0d79c3063de7043b78fe79bae1e9278a">cy_en_usb_cal_ret_code_t</a> Cy_USBHS_Cal_DeinitPLL </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__cal__ctxt__t">cy_stc_usb_cal_ctxt_t</a> *&#160;</td>
          <td class="paramname"><em>pCalCtxt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to de-initialize the PLL in the USBHS block. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pCalCtxt</td><td>CAL layer context pointer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CY_USB_CAL_STATUS_SUCCESS in case of success; error code otherwise. </dd></dl>

</div>
</div>
<a id="ga9d790574d6f33073ac8e5ee6e4ee0c37" name="ga9d790574d6f33073ac8e5ee6e4ee0c37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9d790574d6f33073ac8e5ee6e4ee0c37">&#9670;&nbsp;</a></span>Cy_USBHS_Cal_InitPLL()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#ga0d79c3063de7043b78fe79bae1e9278a">cy_en_usb_cal_ret_code_t</a> Cy_USBHS_Cal_InitPLL </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__cal__ctxt__t">cy_stc_usb_cal_ctxt_t</a> *&#160;</td>
          <td class="paramname"><em>pCalCtxt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to initialize the PLL in the USBHS block to generate the 480 MHz clock required by the High BandWidth SubSystem for its operation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pCalCtxt</td><td>CAL layer context pointer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CY_USB_CAL_STATUS_SUCCESS in case of success; error code otherwise. </dd></dl>

</div>
</div>
<a id="ga9f2ce91cc402991e85e6ce7dd503401b" name="ga9f2ce91cc402991e85e6ce7dd503401b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9f2ce91cc402991e85e6ce7dd503401b">&#9670;&nbsp;</a></span>Cy_USBHS_Cal_IsLinkActive()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Cy_USBHS_Cal_IsLinkActive </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__cal__ctxt__t">cy_stc_usb_cal_ctxt_t</a> *&#160;</td>
          <td class="paramname"><em>pCalCtxt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check whether the USB 2.x link is in active (L0) state. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pCalCtxt</td><td>CAL layer context pointer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if link is in L0, false if link is in L1 or L2. </dd></dl>

</div>
</div>
<a id="gad1690cf72af4e895c1423fa15718bd4f" name="gad1690cf72af4e895c1423fa15718bd4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad1690cf72af4e895c1423fa15718bd4f">&#9670;&nbsp;</a></span>Cy_USBHS_Cal_GetXferCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#ga0d79c3063de7043b78fe79bae1e9278a">cy_en_usb_cal_ret_code_t</a> Cy_USBHS_Cal_GetXferCount </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__cal__ctxt__t">cy_stc_usb_cal_ctxt_t</a> *&#160;</td>
          <td class="paramname"><em>pCalCtxt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>endpNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#gaaebdfe5d46401ad52420b00ca401e6f8">cy_en_usb_endp_dir_t</a>&#160;</td>
          <td class="paramname"><em>endpDir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>pCntPending</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve the remaining transfer count on the specified endpoint. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pCalCtxt</td><td>CAL layer context pointer.</td></tr>
    <tr><td class="paramname">endpNum</td><td>Endpoint number.</td></tr>
    <tr><td class="paramname">endpDir</td><td>Endpoint direction.</td></tr>
    <tr><td class="paramname">pCntPending</td><td>Return parameter through which pending count is returned.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CY_USB_CAL_STATUS_SUCCESS if the operation is successful. CY_USB_CAL_STATUS_BAD_PARAM if direction and endpoint number invalid. CY_USB_CAL_STATUS_CAL_BASE_NULL if register base pointer is NULL. </dd></dl>

</div>
</div>
<a id="ga237a999056772a1d593dd9789d9395af" name="ga237a999056772a1d593dd9789d9395af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga237a999056772a1d593dd9789d9395af">&#9670;&nbsp;</a></span>Cy_USBSS_Cal_Init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#ga0d79c3063de7043b78fe79bae1e9278a">cy_en_usb_cal_ret_code_t</a> Cy_USBSS_Cal_Init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usbss__cal__ctxt__t">cy_stc_usbss_cal_ctxt_t</a> *&#160;</td>
          <td class="paramname"><em>pCalCtxt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pUsbdCtxt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__typedefs.html#gaeb0c3502dfb024979701c241f98ef8b6">cy_usb_cal_msg_callback_t</a>&#160;</td>
          <td class="paramname"><em>cb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes the USBSS IP and relevant variables. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pCalCtxt</td><td>The pointer to the USBSS context structure <a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usbss__cal__ctxt__t">cy_stc_usbss_cal_ctxt_t</a> allocated by the user.</td></tr>
    <tr><td class="paramname">pUsbdCtxt</td><td>The pointer to the USBD context structure.</td></tr>
    <tr><td class="paramname">cb</td><td>Callback function registered by the user <a class="el" href="group__group__usbfxstack__usb__common__typedefs.html#gaeb0c3502dfb024979701c241f98ef8b6">cy_usb_cal_msg_callback_t</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The status code of the function execution <a class="el" href="group__group__usbfxstack__usb__common__enums.html#ga0d79c3063de7043b78fe79bae1e9278a">cy_en_usb_cal_ret_code_t</a>. </dd></dl>

</div>
</div>
<a id="ga85efaaa39c0b6bda13218497e80c6979" name="ga85efaaa39c0b6bda13218497e80c6979"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga85efaaa39c0b6bda13218497e80c6979">&#9670;&nbsp;</a></span>Cy_USBSS_Cal_Connect()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#ga0d79c3063de7043b78fe79bae1e9278a">cy_en_usb_cal_ret_code_t</a> Cy_USBSS_Cal_Connect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usbss__cal__ctxt__t">cy_stc_usbss_cal_ctxt_t</a> *&#160;</td>
          <td class="paramname"><em>pCalCtxt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#ga0355d30a754a1ef18fec29f288f59880">cy_en_usb_speed_t</a>&#160;</td>
          <td class="paramname"><em>usbSpeed</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enables the USB3 RX terminations for connecting to the host and enables relevant USB LINK and PROTOCOL interrupts. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pCalCtxt</td><td>The pointer to the USBSS context structure <a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usbss__cal__ctxt__t">cy_stc_usbss_cal_ctxt_t</a> allocated by the user.</td></tr>
    <tr><td class="paramname">usbSpeed</td><td>The desired speed at which the device needs to be connected to the host <a class="el" href="group__group__usbfxstack__usb__common__enums.html#ga0355d30a754a1ef18fec29f288f59880">cy_en_usb_speed_t</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The status code of the function execution <a class="el" href="group__group__usbfxstack__usb__common__enums.html#ga0d79c3063de7043b78fe79bae1e9278a">cy_en_usb_cal_ret_code_t</a>. </dd></dl>

</div>
</div>
<a id="ga367dcac1778131a9ff33202dc3b0a7b5" name="ga367dcac1778131a9ff33202dc3b0a7b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga367dcac1778131a9ff33202dc3b0a7b5">&#9670;&nbsp;</a></span>Cy_USBSS_Cal_SendMsg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Cy_USBSS_Cal_SendMsg </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usbss__cal__ctxt__t">cy_stc_usbss_cal_ctxt_t</a> *&#160;</td>
          <td class="paramname"><em>pCalCtxt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pMsg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sends message to the USBD layer using a callback registered by the user. </p>
<p >This function should call only ISR safe routine.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pCalCtxt</td><td>The pointer to the USBSS context structure <a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usbss__cal__ctxt__t">cy_stc_usbss_cal_ctxt_t</a> allocated by the user.</td></tr>
    <tr><td class="paramname">pMsg</td><td>Message structure pointer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether context switch is required at the end of the ISR. </dd></dl>

</div>
</div>
<a id="gacdebe291880500842ab6abfd62550af9" name="gacdebe291880500842ab6abfd62550af9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacdebe291880500842ab6abfd62550af9">&#9670;&nbsp;</a></span>Cy_USBSS_Cal_IntrHandler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cy_USBSS_Cal_IntrHandler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usbss__cal__ctxt__t">cy_stc_usbss_cal_ctxt_t</a> *&#160;</td>
          <td class="paramname"><em>pCalCtxt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interrupt Handler function for USB3 IP. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pCalCtxt</td><td>The pointer to the USBSS context structure <a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usbss__cal__ctxt__t">cy_stc_usbss_cal_ctxt_t</a> allocated by the user. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaebd1dfaa99f713a76bf2c4a4de9b1d60" name="gaebd1dfaa99f713a76bf2c4a4de9b1d60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaebd1dfaa99f713a76bf2c4a4de9b1d60">&#9670;&nbsp;</a></span>Cy_USBSS_Cal_WakeupIntrHandler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cy_USBSS_Cal_WakeupIntrHandler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usbss__cal__ctxt__t">cy_stc_usbss_cal_ctxt_t</a> *&#160;</td>
          <td class="paramname"><em>pCalCtxt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wakeup Interrupt Handler function for USB3 IP. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pCalCtxt</td><td>The pointer to the USBSS context structure <a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usbss__cal__ctxt__t">cy_stc_usbss_cal_ctxt_t</a> allocated by the user. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga1cfbefb28baeffb6c8e698a57b0e0568" name="ga1cfbefb28baeffb6c8e698a57b0e0568"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1cfbefb28baeffb6c8e698a57b0e0568">&#9670;&nbsp;</a></span>Cy_USBSS_Cal_Get_PtmStatus()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t Cy_USBSS_Cal_Get_PtmStatus </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usbss__cal__ctxt__t">cy_stc_usbss_cal_ctxt_t</a> *&#160;</td>
          <td class="paramname"><em>pCalCtxt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sends the PTM STATUS to the USBD layer to repsond to GET_STATUS request. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pCalCtxt</td><td>The pointer to the USBSS context structure <a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usbss__cal__ctxt__t">cy_stc_usbss_cal_ctxt_t</a> allocated by the user.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>uint32_t The PTM status . </dd></dl>

</div>
</div>
<a id="gaf5a08f8e21ebe384dbc6ed132bfab48c" name="gaf5a08f8e21ebe384dbc6ed132bfab48c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf5a08f8e21ebe384dbc6ed132bfab48c">&#9670;&nbsp;</a></span>Cy_USBSS_Cal_LPMEnable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#ga0d79c3063de7043b78fe79bae1e9278a">cy_en_usb_cal_ret_code_t</a> Cy_USBSS_Cal_LPMEnable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usbss__cal__ctxt__t">cy_stc_usbss_cal_ctxt_t</a> *&#160;</td>
          <td class="paramname"><em>pCalCtxt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isResume</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enables the USB3 Link layer Low Power Mode Handling. </p>
<p >The LINK layer can accept going into U1/U2 upon receiving LGO_U1/LGO_U2.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pCalCtxt</td><td>The pointer to the USBSS context structure <a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usbss__cal__ctxt__t">cy_stc_usbss_cal_ctxt_t</a> allocated by the user. </td></tr>
    <tr><td class="paramname">isResume</td><td>Whether delayed LPM entry is being resumed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The status code of the function execution <a class="el" href="group__group__usbfxstack__usb__common__enums.html#ga0d79c3063de7043b78fe79bae1e9278a">cy_en_usb_cal_ret_code_t</a>. </dd></dl>

</div>
</div>
<a id="gadcfe87ded386bfe5d0b6d58c177cf04b" name="gadcfe87ded386bfe5d0b6d58c177cf04b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadcfe87ded386bfe5d0b6d58c177cf04b">&#9670;&nbsp;</a></span>Cy_USBSS_Cal_ForceLPMAccept()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#ga0d79c3063de7043b78fe79bae1e9278a">cy_en_usb_cal_ret_code_t</a> Cy_USBSS_Cal_ForceLPMAccept </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usbss__cal__ctxt__t">cy_stc_usbss_cal_ctxt_t</a> *&#160;</td>
          <td class="paramname"><em>pCalCtxt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enables the USB3 Link layer to always accept LPM requests going into U1/U2 upon receiving LGO_U1/LGO_U2. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pCalCtxt</td><td>The pointer to the USBSS context structure <a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usbss__cal__ctxt__t">cy_stc_usbss_cal_ctxt_t</a> allocated by the user.</td></tr>
    <tr><td class="paramname">enable</td><td>If true, the device accept LPM requests always. If false, the device may accept or reject LPM requests.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The status code of the function execution <a class="el" href="group__group__usbfxstack__usb__common__enums.html#ga0d79c3063de7043b78fe79bae1e9278a">cy_en_usb_cal_ret_code_t</a>. </dd></dl>

</div>
</div>
<a id="ga80c7c96a002982fe9977e6ab661c5c79" name="ga80c7c96a002982fe9977e6ab661c5c79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga80c7c96a002982fe9977e6ab661c5c79">&#9670;&nbsp;</a></span>Cy_USBSS_Cal_LPMDisable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#ga0d79c3063de7043b78fe79bae1e9278a">cy_en_usb_cal_ret_code_t</a> Cy_USBSS_Cal_LPMDisable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usbss__cal__ctxt__t">cy_stc_usbss_cal_ctxt_t</a> *&#160;</td>
          <td class="paramname"><em>pCalCtxt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enables the USB3 Link layer to disable accepting LPM requests going into U1/U2 upon receiving LGO_U1/LGO_U2. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pCalCtxt</td><td>The pointer to the USBSS context structure <a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usbss__cal__ctxt__t">cy_stc_usbss_cal_ctxt_t</a> allocated by the user.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The status code of the function execution <a class="el" href="group__group__usbfxstack__usb__common__enums.html#ga0d79c3063de7043b78fe79bae1e9278a">cy_en_usb_cal_ret_code_t</a>. </dd></dl>

</div>
</div>
<a id="gace832c13695e8f500d229b4abfb8675b" name="gace832c13695e8f500d229b4abfb8675b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gace832c13695e8f500d229b4abfb8675b">&#9670;&nbsp;</a></span>Cy_USBSS_Cal_SetLinkPowerState()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#ga0d79c3063de7043b78fe79bae1e9278a">cy_en_usb_cal_ret_code_t</a> Cy_USBSS_Cal_SetLinkPowerState </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usbss__cal__ctxt__t">cy_stc_usbss_cal_ctxt_t</a> *&#160;</td>
          <td class="paramname"><em>pCalCtxt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#ga35921cf9e1a183014cfa7f5ca2e705bf">cy_en_usbss_lnk_power_mode_t</a>&#160;</td>
          <td class="paramname"><em>lnkMode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Forces the USB3 Link layer to a particular Link Power State by sending LGO_Ux requests. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pCalCtxt</td><td>The pointer to the USBSS context structure <a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usbss__cal__ctxt__t">cy_stc_usbss_cal_ctxt_t</a> allocated by the user.</td></tr>
    <tr><td class="paramname">lnkMode</td><td>Link Mode that needs to be set from <a class="el" href="group__group__usbfxstack__usb__common__enums.html#ga35921cf9e1a183014cfa7f5ca2e705bf">cy_en_usbss_lnk_power_mode_t</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The status code of the function execution <a class="el" href="group__group__usbfxstack__usb__common__enums.html#ga0d79c3063de7043b78fe79bae1e9278a">cy_en_usb_cal_ret_code_t</a>. </dd></dl>

</div>
</div>
<a id="ga7d17873e1586197d887704f733223f9d" name="ga7d17873e1586197d887704f733223f9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7d17873e1586197d887704f733223f9d">&#9670;&nbsp;</a></span>Cy_USBSS_Cal_GetUsbLinkActive()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cy_USBSS_Cal_GetUsbLinkActive </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usbss__cal__ctxt__t">cy_stc_usbss_cal_ctxt_t</a> *&#160;</td>
          <td class="paramname"><em>pCalCtxt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the USB3 Link layer to U0 State if it is in U1/U2 state. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pCalCtxt</td><td>The pointer to the USBSS context structure <a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usbss__cal__ctxt__t">cy_stc_usbss_cal_ctxt_t</a> allocated by the user. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gab47428ef44f354eed53288ea466ae0b9" name="gab47428ef44f354eed53288ea466ae0b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab47428ef44f354eed53288ea466ae0b9">&#9670;&nbsp;</a></span>Cy_USBSS_Cal_GetLinkPowerState()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#ga0d79c3063de7043b78fe79bae1e9278a">cy_en_usb_cal_ret_code_t</a> Cy_USBSS_Cal_GetLinkPowerState </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usbss__cal__ctxt__t">cy_stc_usbss_cal_ctxt_t</a> *&#160;</td>
          <td class="paramname"><em>pCalCtxt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#ga35921cf9e1a183014cfa7f5ca2e705bf">cy_en_usbss_lnk_power_mode_t</a> *&#160;</td>
          <td class="paramname"><em>pMode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves the Link Power State of the device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pCalCtxt</td><td>The pointer to the USBSS context structure <a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usbss__cal__ctxt__t">cy_stc_usbss_cal_ctxt_t</a> allocated by the user.</td></tr>
    <tr><td class="paramname">*pMode</td><td>Pointer to a memory where the link power state will be stored from <a class="el" href="group__group__usbfxstack__usb__common__enums.html#ga35921cf9e1a183014cfa7f5ca2e705bf">cy_en_usbss_lnk_power_mode_t</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The status code of the function execution <a class="el" href="group__group__usbfxstack__usb__common__enums.html#ga0d79c3063de7043b78fe79bae1e9278a">cy_en_usb_cal_ret_code_t</a>. </dd></dl>

</div>
</div>
<a id="ga741a41ece9b8ae08d929e4677a4b3d55" name="ga741a41ece9b8ae08d929e4677a4b3d55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga741a41ece9b8ae08d929e4677a4b3d55">&#9670;&nbsp;</a></span>Cy_USBSS_Cal_ProtSendTp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cy_USBSS_Cal_ProtSendTp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usbss__cal__ctxt__t">cy_stc_usbss_cal_ctxt_t</a> *&#160;</td>
          <td class="paramname"><em>pCalCtxt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>pTpData</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function will send transaction packet. </p>
<p >It is responsibility of caller to prepare transaction packet and call this function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pCalCtxt</td><td>The pointer to the USBSS context structure <a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usbss__cal__ctxt__t">cy_stc_usbss_cal_ctxt_t</a> allocated by the user.</td></tr>
    <tr><td class="paramname">*pTpData</td><td>Pointer to a memory where transaction packet stored. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga5b33e249e2ef805350b20d616c5659f3" name="ga5b33e249e2ef805350b20d616c5659f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5b33e249e2ef805350b20d616c5659f3">&#9670;&nbsp;</a></span>Cy_USBSS_Cal_ProtSendAckTp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#ga0d79c3063de7043b78fe79bae1e9278a">cy_en_usb_cal_ret_code_t</a> Cy_USBSS_Cal_ProtSendAckTp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usbss__cal__ctxt__t">cy_stc_usbss_cal_ctxt_t</a> *&#160;</td>
          <td class="paramname"><em>pCalCtxt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>endpNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#gaaebdfe5d46401ad52420b00ca401e6f8">cy_en_usb_endp_dir_t</a>&#160;</td>
          <td class="paramname"><em>endpDir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>numP</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>bulkStream</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function prepares and send ACK transaction packet. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pCalCtxt</td><td>The pointer to the USBSS context structure <a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usbss__cal__ctxt__t">cy_stc_usbss_cal_ctxt_t</a> allocated by the user.</td></tr>
    <tr><td class="paramname">endpNum</td><td>Endpoint number.</td></tr>
    <tr><td class="paramname">endpDir</td><td>Endpoint direction.</td></tr>
    <tr><td class="paramname">numP</td><td>Number of Data packet buffer receiever can accept.</td></tr>
    <tr><td class="paramname">bulkStream</td><td>stream ID incase of bulk transfer</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The status code of the function execution <a class="el" href="group__group__usbfxstack__usb__common__enums.html#ga0d79c3063de7043b78fe79bae1e9278a">cy_en_usb_cal_ret_code_t</a>. </dd></dl>

</div>
</div>
<a id="gab19609a513659ac7080319c2934152a8" name="gab19609a513659ac7080319c2934152a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab19609a513659ac7080319c2934152a8">&#9670;&nbsp;</a></span>Cy_USBSS_Cal_ProtSendErdyTp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#ga0d79c3063de7043b78fe79bae1e9278a">cy_en_usb_cal_ret_code_t</a> Cy_USBSS_Cal_ProtSendErdyTp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usbss__cal__ctxt__t">cy_stc_usbss_cal_ctxt_t</a> *&#160;</td>
          <td class="paramname"><em>pCalCtxt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>endpNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#gaaebdfe5d46401ad52420b00ca401e6f8">cy_en_usb_endp_dir_t</a>&#160;</td>
          <td class="paramname"><em>endpDir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>numP</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>bulkStream</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function prepares and send ERDY transaction packet. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pCalCtxt</td><td>The pointer to the USBSS context structure <a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usbss__cal__ctxt__t">cy_stc_usbss_cal_ctxt_t</a> allocated by the user.</td></tr>
    <tr><td class="paramname">endpNum</td><td>Endpoint number.</td></tr>
    <tr><td class="paramname">endpDir</td><td>Endpoint direction.</td></tr>
    <tr><td class="paramname">numP</td><td>Number of Data packet buffer receiever can accept.</td></tr>
    <tr><td class="paramname">bulkStream</td><td>stream ID incase of bulk transfer</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The status code of the function execution <a class="el" href="group__group__usbfxstack__usb__common__enums.html#ga0d79c3063de7043b78fe79bae1e9278a">cy_en_usb_cal_ret_code_t</a>. </dd></dl>

</div>
</div>
<a id="ga6fc94a432de69295249007e974c94345" name="ga6fc94a432de69295249007e974c94345"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6fc94a432de69295249007e974c94345">&#9670;&nbsp;</a></span>Cy_USBSS_Cal_ProtSendZlpTp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#ga0d79c3063de7043b78fe79bae1e9278a">cy_en_usb_cal_ret_code_t</a> Cy_USBSS_Cal_ProtSendZlpTp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usbss__cal__ctxt__t">cy_stc_usbss_cal_ctxt_t</a> *&#160;</td>
          <td class="paramname"><em>pCalCtxt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function prepares and send ZLP transaction packet. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pCalCtxt</td><td>The pointer to the USBSS context structure <a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usbss__cal__ctxt__t">cy_stc_usbss_cal_ctxt_t</a> allocated by the user.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The status code of the function execution <a class="el" href="group__group__usbfxstack__usb__common__enums.html#ga0d79c3063de7043b78fe79bae1e9278a">cy_en_usb_cal_ret_code_t</a>. </dd></dl>

</div>
</div>
<a id="gabb2310786629d43ca74668fbe4a3b506" name="gabb2310786629d43ca74668fbe4a3b506"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabb2310786629d43ca74668fbe4a3b506">&#9670;&nbsp;</a></span>Cy_USBSS_Cal_ProtSendNrdyTp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#ga0d79c3063de7043b78fe79bae1e9278a">cy_en_usb_cal_ret_code_t</a> Cy_USBSS_Cal_ProtSendNrdyTp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usbss__cal__ctxt__t">cy_stc_usbss_cal_ctxt_t</a> *&#160;</td>
          <td class="paramname"><em>pCalCtxt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>endpNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#gaaebdfe5d46401ad52420b00ca401e6f8">cy_en_usb_endp_dir_t</a>&#160;</td>
          <td class="paramname"><em>endpDir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>bulkStream</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function prepares and send NRDY transaction packet. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pCalCtxt</td><td>The pointer to the USBSS context structure <a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usbss__cal__ctxt__t">cy_stc_usbss_cal_ctxt_t</a> allocated by the user.</td></tr>
    <tr><td class="paramname">endpNum</td><td>Endpoint number.</td></tr>
    <tr><td class="paramname">endpDir</td><td>Endpoint direction.</td></tr>
    <tr><td class="paramname">bulkStream</td><td>stream ID incase of bulk transfer</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The status code of the function execution <a class="el" href="group__group__usbfxstack__usb__common__enums.html#ga0d79c3063de7043b78fe79bae1e9278a">cy_en_usb_cal_ret_code_t</a>. </dd></dl>

</div>
</div>
<a id="gac852e995c7c1b9acfcfadc30bbb8c2f9" name="gac852e995c7c1b9acfcfadc30bbb8c2f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac852e995c7c1b9acfcfadc30bbb8c2f9">&#9670;&nbsp;</a></span>Cy_USBSS_Cal_EndpReset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#ga0d79c3063de7043b78fe79bae1e9278a">cy_en_usb_cal_ret_code_t</a> Cy_USBSS_Cal_EndpReset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usbss__cal__ctxt__t">cy_stc_usbss_cal_ctxt_t</a> *&#160;</td>
          <td class="paramname"><em>pCalCtxt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>endpNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#gaaebdfe5d46401ad52420b00ca401e6f8">cy_en_usb_endp_dir_t</a>&#160;</td>
          <td class="paramname"><em>endpDir</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to reset an endpoint. </p>
<p >This clears sticky bits e.g retry bit, flowcontrol bit.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pCalCtxt</td><td>The pointer to the USBSS context structure <a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usbss__cal__ctxt__t">cy_stc_usbss_cal_ctxt_t</a> allocated by the user.</td></tr>
    <tr><td class="paramname">endpNum</td><td>Endpoint number.</td></tr>
    <tr><td class="paramname">endpDir</td><td>Endpoint direction.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The status code of the function execution <a class="el" href="group__group__usbfxstack__usb__common__enums.html#ga0d79c3063de7043b78fe79bae1e9278a">cy_en_usb_cal_ret_code_t</a>. </dd></dl>

</div>
</div>
<a id="ga86046fe28ba4d0995a12834166150e82" name="ga86046fe28ba4d0995a12834166150e82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga86046fe28ba4d0995a12834166150e82">&#9670;&nbsp;</a></span>Cy_USBSS_Cal_GetSeqNum()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#ga0d79c3063de7043b78fe79bae1e9278a">cy_en_usb_cal_ret_code_t</a> Cy_USBSS_Cal_GetSeqNum </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usbss__cal__ctxt__t">cy_stc_usbss_cal_ctxt_t</a> *&#160;</td>
          <td class="paramname"><em>pCalCtxt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>endpNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#gaaebdfe5d46401ad52420b00ca401e6f8">cy_en_usb_endp_dir_t</a>&#160;</td>
          <td class="paramname"><em>endpDir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>pSeqNum</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function gets the current value of sequence number for an endpoint. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pCalCtxt</td><td>The pointer to the USBSS context structure <a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usbss__cal__ctxt__t">cy_stc_usbss_cal_ctxt_t</a> allocated by the user.</td></tr>
    <tr><td class="paramname">endpNum</td><td>Endpoint number.</td></tr>
    <tr><td class="paramname">endpDir</td><td>Endpoint direction.</td></tr>
    <tr><td class="paramname">pSeqNum</td><td>Current value of sequence number will be store here.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The status code of the function execution <a class="el" href="group__group__usbfxstack__usb__common__enums.html#ga0d79c3063de7043b78fe79bae1e9278a">cy_en_usb_cal_ret_code_t</a>. </dd></dl>

</div>
</div>
<a id="ga7c61f60b4dc28e446e392bb455ce9a5e" name="ga7c61f60b4dc28e446e392bb455ce9a5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7c61f60b4dc28e446e392bb455ce9a5e">&#9670;&nbsp;</a></span>Cy_USBSS_Cal_SetSeqNum()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#ga0d79c3063de7043b78fe79bae1e9278a">cy_en_usb_cal_ret_code_t</a> Cy_USBSS_Cal_SetSeqNum </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usbss__cal__ctxt__t">cy_stc_usbss_cal_ctxt_t</a> *&#160;</td>
          <td class="paramname"><em>pCalCtxt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>endpNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#gaaebdfe5d46401ad52420b00ca401e6f8">cy_en_usb_endp_dir_t</a>&#160;</td>
          <td class="paramname"><em>endpDir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>seqNum</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function sets value of sequence number in hardware for an endpoint. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pCalCtxt</td><td>The pointer to the USBSS context structure <a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usbss__cal__ctxt__t">cy_stc_usbss_cal_ctxt_t</a> allocated by the user.</td></tr>
    <tr><td class="paramname">endpNum</td><td>Endpoint number.</td></tr>
    <tr><td class="paramname">endpDir</td><td>Endpoint direction.</td></tr>
    <tr><td class="paramname">seqNum</td><td>Sequence number need to be written in HW register.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The status code of the function execution <a class="el" href="group__group__usbfxstack__usb__common__enums.html#ga0d79c3063de7043b78fe79bae1e9278a">cy_en_usb_cal_ret_code_t</a>. </dd></dl>

</div>
</div>
<a id="ga2adbf6478437ddaff50aeff1b2f4d543" name="ga2adbf6478437ddaff50aeff1b2f4d543"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2adbf6478437ddaff50aeff1b2f4d543">&#9670;&nbsp;</a></span>Cy_USBSS_Cal_GetDevAddress()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#ga0d79c3063de7043b78fe79bae1e9278a">cy_en_usb_cal_ret_code_t</a> Cy_USBSS_Cal_GetDevAddress </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usbss__cal__ctxt__t">cy_stc_usbss_cal_ctxt_t</a> *&#160;</td>
          <td class="paramname"><em>pCalCtxt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>pDevAddr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function will get device address assigned by Host. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pCalCtxt</td><td>The pointer to the USBSS context structure <a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usbss__cal__ctxt__t">cy_stc_usbss_cal_ctxt_t</a> allocated by the user.</td></tr>
    <tr><td class="paramname">pDevAddr</td><td>device address will be stored here.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The status code of the function execution <a class="el" href="group__group__usbfxstack__usb__common__enums.html#ga0d79c3063de7043b78fe79bae1e9278a">cy_en_usb_cal_ret_code_t</a>. </dd></dl>

</div>
</div>
<a id="ga6bdfc8cdd81fb31432daebaa33a48abf" name="ga6bdfc8cdd81fb31432daebaa33a48abf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6bdfc8cdd81fb31432daebaa33a48abf">&#9670;&nbsp;</a></span>Cy_USBSS_Cal_EndpSetClearStall()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#ga0d79c3063de7043b78fe79bae1e9278a">cy_en_usb_cal_ret_code_t</a> Cy_USBSS_Cal_EndpSetClearStall </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usbss__cal__ctxt__t">cy_stc_usbss_cal_ctxt_t</a> *&#160;</td>
          <td class="paramname"><em>pCalCtxt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>endpNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#gaaebdfe5d46401ad52420b00ca401e6f8">cy_en_usb_endp_dir_t</a>&#160;</td>
          <td class="paramname"><em>endpDir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>setClear</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function enable or disable NRDY condition in hw. </p>
<p >By setting NRDY bit, endpoint will keep sending NRDY till NRDY bit is cleared.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pCalCtxt</td><td>The pointer to the USBSS context structure <a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usbss__cal__ctxt__t">cy_stc_usbss_cal_ctxt_t</a> allocated by the user.</td></tr>
    <tr><td class="paramname">endpNum</td><td>Endpoint number.</td></tr>
    <tr><td class="paramname">endpDir</td><td>Endpoint direction.</td></tr>
    <tr><td class="paramname">setClear</td><td>true for set and false for clear.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The status code of the function execution <a class="el" href="group__group__usbfxstack__usb__common__enums.html#ga0d79c3063de7043b78fe79bae1e9278a">cy_en_usb_cal_ret_code_t</a>. </dd></dl>

</div>
</div>
<a id="gad5247d94b681e640a18c389cc5bdb26f" name="gad5247d94b681e640a18c389cc5bdb26f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad5247d94b681e640a18c389cc5bdb26f">&#9670;&nbsp;</a></span>Cy_USBSS_Cal_EndpSetClearNrdy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#ga0d79c3063de7043b78fe79bae1e9278a">cy_en_usb_cal_ret_code_t</a> Cy_USBSS_Cal_EndpSetClearNrdy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usbss__cal__ctxt__t">cy_stc_usbss_cal_ctxt_t</a> *&#160;</td>
          <td class="paramname"><em>pCalCtxt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>endpNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#gaaebdfe5d46401ad52420b00ca401e6f8">cy_en_usb_endp_dir_t</a>&#160;</td>
          <td class="paramname"><em>endpDir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>setClear</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function enable or disable NRDY condition in hw. </p>
<p >By setting NRDY bit, endpoint will keep sending NRDY till NRDY bit is cleared.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pCalCtxt</td><td>The pointer to the USBSS context structure <a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usbss__cal__ctxt__t">cy_stc_usbss_cal_ctxt_t</a> allocated by the user.</td></tr>
    <tr><td class="paramname">endpNum</td><td>Endpoint number.</td></tr>
    <tr><td class="paramname">endpDir</td><td>Endpoint direction.</td></tr>
    <tr><td class="paramname">setClear</td><td>true for set and false for clear.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The status code of the function execution <a class="el" href="group__group__usbfxstack__usb__common__enums.html#ga0d79c3063de7043b78fe79bae1e9278a">cy_en_usb_cal_ret_code_t</a>. </dd></dl>

</div>
</div>
<a id="ga8eaec4aa577d2fc0bf5e6f279faa22bf" name="ga8eaec4aa577d2fc0bf5e6f279faa22bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8eaec4aa577d2fc0bf5e6f279faa22bf">&#9670;&nbsp;</a></span>Cy_USBSS_Cal_SetClearNrdyAll()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#ga0d79c3063de7043b78fe79bae1e9278a">cy_en_usb_cal_ret_code_t</a> Cy_USBSS_Cal_SetClearNrdyAll </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usbss__cal__ctxt__t">cy_stc_usbss_cal_ctxt_t</a> *&#160;</td>
          <td class="paramname"><em>pCalCtxt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>setClear</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function enable or disable NRDY condition for all endpopint. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pCalCtxt</td><td>The pointer to the USBSS context structure <a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usbss__cal__ctxt__t">cy_stc_usbss_cal_ctxt_t</a> allocated by the user.</td></tr>
    <tr><td class="paramname">setClear</td><td>true for set and false for clear.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The status code of the function execution <a class="el" href="group__group__usbfxstack__usb__common__enums.html#ga0d79c3063de7043b78fe79bae1e9278a">cy_en_usb_cal_ret_code_t</a>. </dd></dl>

</div>
</div>
<a id="ga69fee6dad3726a978cde261215d9b5cb" name="ga69fee6dad3726a978cde261215d9b5cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga69fee6dad3726a978cde261215d9b5cb">&#9670;&nbsp;</a></span>Cy_USBSS_Cal_EndpConfig()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#ga0d79c3063de7043b78fe79bae1e9278a">cy_en_usb_cal_ret_code_t</a> Cy_USBSS_Cal_EndpConfig </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usbss__cal__ctxt__t">cy_stc_usbss_cal_ctxt_t</a> *&#160;</td>
          <td class="paramname"><em>pCalCtxt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__endp__config__t">cy_stc_usb_endp_config_t</a>&#160;</td>
          <td class="paramname"><em>configParam</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function handles configuration of endpoint. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pCalCtxt</td><td>The pointer to the USBSS context structure <a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usbss__cal__ctxt__t">cy_stc_usbss_cal_ctxt_t</a> allocated by the user.</td></tr>
    <tr><td class="paramname">configParam</td><td>Configuration Parameters stored here <a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__endp__config__t">cy_stc_usb_endp_config_t</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The status code of the function execution <a class="el" href="group__group__usbfxstack__usb__common__enums.html#ga0d79c3063de7043b78fe79bae1e9278a">cy_en_usb_cal_ret_code_t</a>. </dd></dl>

</div>
</div>
<a id="ga6fb9d01aaa5a5e17a5290cf3abd3226f" name="ga6fb9d01aaa5a5e17a5290cf3abd3226f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6fb9d01aaa5a5e17a5290cf3abd3226f">&#9670;&nbsp;</a></span>Cy_USBSS_Cal_EndpSetPktsPerBuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#ga0d79c3063de7043b78fe79bae1e9278a">cy_en_usb_cal_ret_code_t</a> Cy_USBSS_Cal_EndpSetPktsPerBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usbss__cal__ctxt__t">cy_stc_usbss_cal_ctxt_t</a> *&#160;</td>
          <td class="paramname"><em>pCalCtxt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>endpNumber</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>pktsPerBuffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function sets the number of maximum sized packets that can fit into a single DMA buffer for an Ingress endpoint. </p>
<p >This needs to be called in cases where the maximum packet size is not a power of 2, so that the EPM can operate correctly.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pCalCtxt</td><td>The pointer to the USBSS context structure <a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usbss__cal__ctxt__t">cy_stc_usbss_cal_ctxt_t</a> allocated by the user.</td></tr>
    <tr><td class="paramname">endpNumber</td><td>Endpoint number.</td></tr>
    <tr><td class="paramname">pktsPerBuffer</td><td>packats per buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The status code of the function execution <a class="el" href="group__group__usbfxstack__usb__common__enums.html#ga0d79c3063de7043b78fe79bae1e9278a">cy_en_usb_cal_ret_code_t</a>. </dd></dl>

</div>
</div>
<a id="ga40ae26797b2a9e62043d5a4921df5471" name="ga40ae26797b2a9e62043d5a4921df5471"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga40ae26797b2a9e62043d5a4921df5471">&#9670;&nbsp;</a></span>Cy_USBSS_Cal_EndpMapStream()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#ga0d79c3063de7043b78fe79bae1e9278a">cy_en_usb_cal_ret_code_t</a> Cy_USBSS_Cal_EndpMapStream </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usbss__cal__ctxt__t">cy_stc_usbss_cal_ctxt_t</a> *&#160;</td>
          <td class="paramname"><em>pCalCtxt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>endpNumber</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#gaaebdfe5d46401ad52420b00ca401e6f8">cy_en_usb_endp_dir_t</a>&#160;</td>
          <td class="paramname"><em>endpDirection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>streamId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>socketNum</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function maps an unused USB Ingress/Egress socket to the specified stream associated with a bulk endpoint. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pCalCtxt</td><td>The pointer to the USBSS context structure <a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usbss__cal__ctxt__t">cy_stc_usbss_cal_ctxt_t</a> allocated by the user.</td></tr>
    <tr><td class="paramname">endpNumber</td><td>Endpoint number.</td></tr>
    <tr><td class="paramname">endpDirection</td><td>Endpoint direction.</td></tr>
    <tr><td class="paramname">streamId</td><td>stream ID.</td></tr>
    <tr><td class="paramname">socketNum</td><td>Socket Number.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The status code of the function execution <a class="el" href="group__group__usbfxstack__usb__common__enums.html#ga0d79c3063de7043b78fe79bae1e9278a">cy_en_usb_cal_ret_code_t</a>. </dd></dl>

</div>
</div>
<a id="ga61e31d2f33a8e95c87ec0b50902b532e" name="ga61e31d2f33a8e95c87ec0b50902b532e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga61e31d2f33a8e95c87ec0b50902b532e">&#9670;&nbsp;</a></span>Cy_USBSS_Cal_EndpUnmapStream()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#ga0d79c3063de7043b78fe79bae1e9278a">cy_en_usb_cal_ret_code_t</a> Cy_USBSS_Cal_EndpUnmapStream </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usbss__cal__ctxt__t">cy_stc_usbss_cal_ctxt_t</a> *&#160;</td>
          <td class="paramname"><em>pCalCtxt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>endpNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#gaaebdfe5d46401ad52420b00ca401e6f8">cy_en_usb_endp_dir_t</a>&#160;</td>
          <td class="paramname"><em>endpDir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>socketNum</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function unmaps the DMA socket to stream mapping for a bulk endpoint. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pCalCtxt</td><td>The pointer to the USBSS context structure <a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usbss__cal__ctxt__t">cy_stc_usbss_cal_ctxt_t</a> allocated by the user.</td></tr>
    <tr><td class="paramname">endpNum</td><td>Endpoint number.</td></tr>
    <tr><td class="paramname">endpDir</td><td>Endpoint direction.</td></tr>
    <tr><td class="paramname">socketNum</td><td>Socket Number.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The status code of the function execution <a class="el" href="group__group__usbfxstack__usb__common__enums.html#ga0d79c3063de7043b78fe79bae1e9278a">cy_en_usb_cal_ret_code_t</a>. </dd></dl>

</div>
</div>
<a id="ga250aa6fee28c93889e34e6a738282dcd" name="ga250aa6fee28c93889e34e6a738282dcd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga250aa6fee28c93889e34e6a738282dcd">&#9670;&nbsp;</a></span>Cy_USBSS_Cal_EnableEndp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#ga0d79c3063de7043b78fe79bae1e9278a">cy_en_usb_cal_ret_code_t</a> Cy_USBSS_Cal_EnableEndp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usbss__cal__ctxt__t">cy_stc_usbss_cal_ctxt_t</a> *&#160;</td>
          <td class="paramname"><em>pCalCtxt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>endpNumber</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#gaaebdfe5d46401ad52420b00ca401e6f8">cy_en_usb_endp_dir_t</a>&#160;</td>
          <td class="paramname"><em>endpDirection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function enables/disable endpoint and set/reset respective interrupt. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pCalCtxt</td><td>The pointer to the USBSS context structure <a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usbss__cal__ctxt__t">cy_stc_usbss_cal_ctxt_t</a> allocated by the user.</td></tr>
    <tr><td class="paramname">endpNumber</td><td>Endpoint number.</td></tr>
    <tr><td class="paramname">endpDirection</td><td>Endpoint direction.</td></tr>
    <tr><td class="paramname">enable</td><td>true for enable and false for disable.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The status code of the function execution <a class="el" href="group__group__usbfxstack__usb__common__enums.html#ga0d79c3063de7043b78fe79bae1e9278a">cy_en_usb_cal_ret_code_t</a>. </dd></dl>

</div>
</div>
<a id="gabff4770fe13d82f3f3bebfe1accd0897" name="gabff4770fe13d82f3f3bebfe1accd0897"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabff4770fe13d82f3f3bebfe1accd0897">&#9670;&nbsp;</a></span>Cy_USBSS_Cal_SetEpBurstMode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#ga0d79c3063de7043b78fe79bae1e9278a">cy_en_usb_cal_ret_code_t</a> Cy_USBSS_Cal_SetEpBurstMode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usbss__cal__ctxt__t">cy_stc_usbss_cal_ctxt_t</a> *&#160;</td>
          <td class="paramname"><em>pCalCtxt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>endpNumber</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#gaaebdfe5d46401ad52420b00ca401e6f8">cy_en_usb_endp_dir_t</a>&#160;</td>
          <td class="paramname"><em>endpDirection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function enables/disables the MULT (allow burst across multiple DMA buffers) feature for the specified USB endpoints. </p>
<p >Enabling the feature can improve the data transfer throughput on the respective endpoints.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pCalCtxt</td><td>The pointer to the USBSS context structure <a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usbss__cal__ctxt__t">cy_stc_usbss_cal_ctxt_t</a> allocated by the user.</td></tr>
    <tr><td class="paramname">endpNumber</td><td>Endpoint number.</td></tr>
    <tr><td class="paramname">endpDirection</td><td>Endpoint direction.</td></tr>
    <tr><td class="paramname">enable</td><td>true for enable burst mode and false for disable burst mode.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The status code of the function execution <a class="el" href="group__group__usbfxstack__usb__common__enums.html#ga0d79c3063de7043b78fe79bae1e9278a">cy_en_usb_cal_ret_code_t</a>. </dd></dl>

</div>
</div>
<a id="gac64a75339e3c8afe7aac0ad969a44a8b" name="gac64a75339e3c8afe7aac0ad969a44a8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac64a75339e3c8afe7aac0ad969a44a8b">&#9670;&nbsp;</a></span>Cy_USBSS_Cal_SetEndpRetryOffset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#ga0d79c3063de7043b78fe79bae1e9278a">cy_en_usb_cal_ret_code_t</a> Cy_USBSS_Cal_SetEndpRetryOffset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usbss__cal__ctxt__t">cy_stc_usbss_cal_ctxt_t</a> *&#160;</td>
          <td class="paramname"><em>pCalCtxt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>endpNumber</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>retryBufOffset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function sets the egress endpoint retry buffer offset for Type-2 (CTRL and BULK) endpoints. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pCalCtxt</td><td>The pointer to the USBSS context structure <a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usbss__cal__ctxt__t">cy_stc_usbss_cal_ctxt_t</a> allocated by the user.</td></tr>
    <tr><td class="paramname">endpNumber</td><td>Endpoint number.</td></tr>
    <tr><td class="paramname">retryBufOffset</td><td>Retry buffer offset.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The status code of the function execution <a class="el" href="group__group__usbfxstack__usb__common__enums.html#ga0d79c3063de7043b78fe79bae1e9278a">cy_en_usb_cal_ret_code_t</a>. </dd></dl>

</div>
</div>
<a id="gac7906db6743acc9bc40421ec001156ab" name="gac7906db6743acc9bc40421ec001156ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac7906db6743acc9bc40421ec001156ab">&#9670;&nbsp;</a></span>Cy_USBSS_Cal_UpdateXferCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#ga0d79c3063de7043b78fe79bae1e9278a">cy_en_usb_cal_ret_code_t</a> Cy_USBSS_Cal_UpdateXferCount </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usbss__cal__ctxt__t">cy_stc_usbss_cal_ctxt_t</a> *&#160;</td>
          <td class="paramname"><em>pCalCtxt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>endpNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#gaaebdfe5d46401ad52420b00ca401e6f8">cy_en_usb_endp_dir_t</a>&#160;</td>
          <td class="paramname"><em>endpDir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>xferCount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function updates xfer count in an ndpoint register. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pCalCtxt</td><td>The pointer to the USBSS context structure <a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usbss__cal__ctxt__t">cy_stc_usbss_cal_ctxt_t</a> allocated by the user.</td></tr>
    <tr><td class="paramname">endpNum</td><td>Endpoint number.</td></tr>
    <tr><td class="paramname">endpDir</td><td>Endpoint direction.</td></tr>
    <tr><td class="paramname">xferCount</td><td>transfer count value stored here.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The status code of the function execution <a class="el" href="group__group__usbfxstack__usb__common__enums.html#ga0d79c3063de7043b78fe79bae1e9278a">cy_en_usb_cal_ret_code_t</a>. </dd></dl>

</div>
</div>
<a id="ga12359d9088d69480459d21101f5e022e" name="ga12359d9088d69480459d21101f5e022e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga12359d9088d69480459d21101f5e022e">&#9670;&nbsp;</a></span>Cy_USBSS_Cal_EnableStatusCtrl()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#ga0d79c3063de7043b78fe79bae1e9278a">cy_en_usb_cal_ret_code_t</a> Cy_USBSS_Cal_EnableStatusCtrl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usbss__cal__ctxt__t">cy_stc_usbss_cal_ctxt_t</a> *&#160;</td>
          <td class="paramname"><em>pCalCtxt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function enable/disable Status Control feature mentioned in PROT_CS register. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pCalCtxt</td><td>The pointer to the USBSS context structure <a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usbss__cal__ctxt__t">cy_stc_usbss_cal_ctxt_t</a> allocated by the user.</td></tr>
    <tr><td class="paramname">enable</td><td>true for enable and false for disable.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The status code of the function execution <a class="el" href="group__group__usbfxstack__usb__common__enums.html#ga0d79c3063de7043b78fe79bae1e9278a">cy_en_usb_cal_ret_code_t</a>. </dd></dl>

</div>
</div>
<a id="ga3c8cba365500310dc638b1e36cc7f932" name="ga3c8cba365500310dc638b1e36cc7f932"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3c8cba365500310dc638b1e36cc7f932">&#9670;&nbsp;</a></span>Cy_USBSS_Cal_ClearStatusClrBusy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#ga0d79c3063de7043b78fe79bae1e9278a">cy_en_usb_cal_ret_code_t</a> Cy_USBSS_Cal_ClearStatusClrBusy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usbss__cal__ctxt__t">cy_stc_usbss_cal_ctxt_t</a> *&#160;</td>
          <td class="paramname"><em>pCalCtxt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function write "1" to STATUS_CLR_BUSY which clears the bit to initiate STATUS response. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pCalCtxt</td><td>The pointer to the USBSS context structure <a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usbss__cal__ctxt__t">cy_stc_usbss_cal_ctxt_t</a> allocated by the user.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The status code of the function execution <a class="el" href="group__group__usbfxstack__usb__common__enums.html#ga0d79c3063de7043b78fe79bae1e9278a">cy_en_usb_cal_ret_code_t</a>. </dd></dl>

</div>
</div>
<a id="ga022037eca4b8a56180fa216ec80b03fe" name="ga022037eca4b8a56180fa216ec80b03fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga022037eca4b8a56180fa216ec80b03fe">&#9670;&nbsp;</a></span>Cy_USBSS_Cal_SendAckSetupDataStatusStage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#ga0d79c3063de7043b78fe79bae1e9278a">cy_en_usb_cal_ret_code_t</a> Cy_USBSS_Cal_SendAckSetupDataStatusStage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usbss__cal__ctxt__t">cy_stc_usbss_cal_ctxt_t</a> *&#160;</td>
          <td class="paramname"><em>pCalCtxt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function enable HW to send ACK in status stage. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pCalCtxt</td><td>The pointer to the USBSS context structure <a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usbss__cal__ctxt__t">cy_stc_usbss_cal_ctxt_t</a> allocated by the user.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The status code of the function execution <a class="el" href="group__group__usbfxstack__usb__common__enums.html#ga0d79c3063de7043b78fe79bae1e9278a">cy_en_usb_cal_ret_code_t</a>. </dd></dl>

</div>
</div>
<a id="ga29ddaeff9647bef019a1de3818262b8d" name="ga29ddaeff9647bef019a1de3818262b8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga29ddaeff9647bef019a1de3818262b8d">&#9670;&nbsp;</a></span>Cy_USBSS_Cal_FlushEPM()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#ga0d79c3063de7043b78fe79bae1e9278a">cy_en_usb_cal_ret_code_t</a> Cy_USBSS_Cal_FlushEPM </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usbss__cal__ctxt__t">cy_stc_usbss_cal_ctxt_t</a> *&#160;</td>
          <td class="paramname"><em>pCalCtxt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>force</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function will flush Ingress and egress both the EPM. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pCalCtxt</td><td>The pointer to the USBSS context structure <a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usbss__cal__ctxt__t">cy_stc_usbss_cal_ctxt_t</a> allocated by the user. </td></tr>
    <tr><td class="paramname">force</td><td>Whether flush should be forcibly done even if pointers are zero.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The status code of the function execution <a class="el" href="group__group__usbfxstack__usb__common__enums.html#ga0d79c3063de7043b78fe79bae1e9278a">cy_en_usb_cal_ret_code_t</a>. </dd></dl>

</div>
</div>
<a id="gaa99dc0c852b592d7cd814cbedd986675" name="gaa99dc0c852b592d7cd814cbedd986675"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa99dc0c852b592d7cd814cbedd986675">&#9670;&nbsp;</a></span>Cy_USBSS_Cal_FlushEndpSocket()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#ga0d79c3063de7043b78fe79bae1e9278a">cy_en_usb_cal_ret_code_t</a> Cy_USBSS_Cal_FlushEndpSocket </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usbss__cal__ctxt__t">cy_stc_usbss_cal_ctxt_t</a> *&#160;</td>
          <td class="paramname"><em>pCalCtxt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>endpNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#gaaebdfe5d46401ad52420b00ca401e6f8">cy_en_usb_endp_dir_t</a>&#160;</td>
          <td class="paramname"><em>endpDir</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function will flush socket associated with an endpoint. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pCalCtxt</td><td>The pointer to the USBSS context structure <a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usbss__cal__ctxt__t">cy_stc_usbss_cal_ctxt_t</a> allocated by the user.</td></tr>
    <tr><td class="paramname">endpNum</td><td>Endpoint number.</td></tr>
    <tr><td class="paramname">endpDir</td><td>Endpoint direction.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The status code of the function execution <a class="el" href="group__group__usbfxstack__usb__common__enums.html#ga0d79c3063de7043b78fe79bae1e9278a">cy_en_usb_cal_ret_code_t</a>. </dd></dl>

</div>
</div>
<a id="ga10fa6eedcea41f7952a00eee608fd878" name="ga10fa6eedcea41f7952a00eee608fd878"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga10fa6eedcea41f7952a00eee608fd878">&#9670;&nbsp;</a></span>Cy_USBSS_Cal_FlushAllEndpSocket()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#ga0d79c3063de7043b78fe79bae1e9278a">cy_en_usb_cal_ret_code_t</a> Cy_USBSS_Cal_FlushAllEndpSocket </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usbss__cal__ctxt__t">cy_stc_usbss_cal_ctxt_t</a> *&#160;</td>
          <td class="paramname"><em>pCalCtxt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function will flush socket associated with all endpoints. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pCalCtxt</td><td>The pointer to the USBSS context structure <a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usbss__cal__ctxt__t">cy_stc_usbss_cal_ctxt_t</a> allocated by the user.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The status code of the function execution <a class="el" href="group__group__usbfxstack__usb__common__enums.html#ga0d79c3063de7043b78fe79bae1e9278a">cy_en_usb_cal_ret_code_t</a>. </dd></dl>

</div>
</div>
<a id="gaf6298913ecbaad5e28408bb858cf7553" name="gaf6298913ecbaad5e28408bb858cf7553"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf6298913ecbaad5e28408bb858cf7553">&#9670;&nbsp;</a></span>Cy_USBSS_Cal_EnableMainIntr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#ga0d79c3063de7043b78fe79bae1e9278a">cy_en_usb_cal_ret_code_t</a> Cy_USBSS_Cal_EnableMainIntr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usbss__cal__ctxt__t">cy_stc_usbss_cal_ctxt_t</a> *&#160;</td>
          <td class="paramname"><em>pCalCtxt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>EnableDisable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function will enable/disable main interrupts. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pCalCtxt</td><td>The pointer to the USBSS context structure <a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usbss__cal__ctxt__t">cy_stc_usbss_cal_ctxt_t</a> allocated by the user.</td></tr>
    <tr><td class="paramname">EnableDisable</td><td>true for enable and false for disable.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The status code of the function execution <a class="el" href="group__group__usbfxstack__usb__common__enums.html#ga0d79c3063de7043b78fe79bae1e9278a">cy_en_usb_cal_ret_code_t</a>. </dd></dl>

</div>
</div>
<a id="ga2cf1de36f201df94065e330650386217" name="ga2cf1de36f201df94065e330650386217"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2cf1de36f201df94065e330650386217">&#9670;&nbsp;</a></span>Cy_USBSS_Cal_EnableLinkIntr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#ga0d79c3063de7043b78fe79bae1e9278a">cy_en_usb_cal_ret_code_t</a> Cy_USBSS_Cal_EnableLinkIntr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usbss__cal__ctxt__t">cy_stc_usbss_cal_ctxt_t</a> *&#160;</td>
          <td class="paramname"><em>pCalCtxt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>EnableDisable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function will enable/disable link interrupts. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pCalCtxt</td><td>The pointer to the USBSS context structure <a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usbss__cal__ctxt__t">cy_stc_usbss_cal_ctxt_t</a> allocated by the user.</td></tr>
    <tr><td class="paramname">EnableDisable</td><td>true for enable and false for disable.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The status code of the function execution <a class="el" href="group__group__usbfxstack__usb__common__enums.html#ga0d79c3063de7043b78fe79bae1e9278a">cy_en_usb_cal_ret_code_t</a>. </dd></dl>

</div>
</div>
<a id="ga2e72483b3db1bc2c7ba9cb05fc200a6a" name="ga2e72483b3db1bc2c7ba9cb05fc200a6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2e72483b3db1bc2c7ba9cb05fc200a6a">&#9670;&nbsp;</a></span>Cy_USBSS_Cal_EnableProtIntr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#ga0d79c3063de7043b78fe79bae1e9278a">cy_en_usb_cal_ret_code_t</a> Cy_USBSS_Cal_EnableProtIntr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usbss__cal__ctxt__t">cy_stc_usbss_cal_ctxt_t</a> *&#160;</td>
          <td class="paramname"><em>pCalCtxt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>EnableDisable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function will enable/disable protocol interrupts. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pCalCtxt</td><td>The pointer to the USBSS context structure <a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usbss__cal__ctxt__t">cy_stc_usbss_cal_ctxt_t</a> allocated by the user.</td></tr>
    <tr><td class="paramname">EnableDisable</td><td>true for enable and false for disable.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The status code of the function execution <a class="el" href="group__group__usbfxstack__usb__common__enums.html#ga0d79c3063de7043b78fe79bae1e9278a">cy_en_usb_cal_ret_code_t</a>. </dd></dl>

</div>
</div>
<a id="ga90002bb32c65433dc32498bec037e360" name="ga90002bb32c65433dc32498bec037e360"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga90002bb32c65433dc32498bec037e360">&#9670;&nbsp;</a></span>Cy_USBSS_Cal_EndpIsNakNrdySet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Cy_USBSS_Cal_EndpIsNakNrdySet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usbss__cal__ctxt__t">cy_stc_usbss_cal_ctxt_t</a> *&#160;</td>
          <td class="paramname"><em>pCalCtxt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>endpNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#gaaebdfe5d46401ad52420b00ca401e6f8">cy_en_usb_endp_dir_t</a>&#160;</td>
          <td class="paramname"><em>endpDir</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function checks whether the specified endpoint is currently in the NRDYed state. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pCalCtxt</td><td>The pointer to the USBSS context structure <a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usbss__cal__ctxt__t">cy_stc_usbss_cal_ctxt_t</a> allocated by the user.</td></tr>
    <tr><td class="paramname">endpNum</td><td>Endpoint number.</td></tr>
    <tr><td class="paramname">endpDir</td><td>Endpoint direction.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether endpoint is currently NRDYed. True means NRDYed state. </dd></dl>

</div>
</div>
<a id="ga2c9e719b163d97fb2e7ab4adcd2fd859" name="ga2c9e719b163d97fb2e7ab4adcd2fd859"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2c9e719b163d97fb2e7ab4adcd2fd859">&#9670;&nbsp;</a></span>Cy_USBSS_Cal_EndpIsStallSet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Cy_USBSS_Cal_EndpIsStallSet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usbss__cal__ctxt__t">cy_stc_usbss_cal_ctxt_t</a> *&#160;</td>
          <td class="paramname"><em>pCalCtxt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>endpNumber</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#gaaebdfe5d46401ad52420b00ca401e6f8">cy_en_usb_endp_dir_t</a>&#160;</td>
          <td class="paramname"><em>endpDirection</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function checks whether the specified endpoint is currently in the STALLed state. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pCalCtxt</td><td>The pointer to the USBSS context structure <a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usbss__cal__ctxt__t">cy_stc_usbss_cal_ctxt_t</a> allocated by the user.</td></tr>
    <tr><td class="paramname">endpNumber</td><td>Endpoint number.</td></tr>
    <tr><td class="paramname">endpDirection</td><td>Endpoint direction.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether endpoint is currently STALLed. True means STALLed state. </dd></dl>

</div>
</div>
<a id="gad4e8a7317c5bfcbaca1d2737d2ff3c3a" name="gad4e8a7317c5bfcbaca1d2737d2ff3c3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad4e8a7317c5bfcbaca1d2737d2ff3c3a">&#9670;&nbsp;</a></span>Cy_USBSS_Cal_EnableSsDevice()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#ga0d79c3063de7043b78fe79bae1e9278a">cy_en_usb_cal_ret_code_t</a> Cy_USBSS_Cal_EnableSsDevice </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usbss__cal__ctxt__t">cy_stc_usbss_cal_ctxt_t</a> *&#160;</td>
          <td class="paramname"><em>pCalCtxt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function enable/disable USB device in SS mode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pCalCtxt</td><td>The pointer to the USBSS context structure <a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usbss__cal__ctxt__t">cy_stc_usbss_cal_ctxt_t</a> allocated by the user.</td></tr>
    <tr><td class="paramname">enable</td><td>true for enable and false for disable.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The status code of the function execution <a class="el" href="group__group__usbfxstack__usb__common__enums.html#ga0d79c3063de7043b78fe79bae1e9278a">cy_en_usb_cal_ret_code_t</a>. </dd></dl>

</div>
</div>
<a id="gaded9ff1dc30cb9ecda87b24167df6f6e" name="gaded9ff1dc30cb9ecda87b24167df6f6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaded9ff1dc30cb9ecda87b24167df6f6e">&#9670;&nbsp;</a></span>Cy_USBSS_Cal_DisConnect()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#ga0d79c3063de7043b78fe79bae1e9278a">cy_en_usb_cal_ret_code_t</a> Cy_USBSS_Cal_DisConnect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usbss__cal__ctxt__t">cy_stc_usbss_cal_ctxt_t</a> *&#160;</td>
          <td class="paramname"><em>pCalCtxt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function handles disconnect device at CAL layer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pCalCtxt</td><td>The pointer to the USBSS context structure <a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usbss__cal__ctxt__t">cy_stc_usbss_cal_ctxt_t</a> allocated by the user.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The status code of the function execution <a class="el" href="group__group__usbfxstack__usb__common__enums.html#ga0d79c3063de7043b78fe79bae1e9278a">cy_en_usb_cal_ret_code_t</a>. </dd></dl>

</div>
</div>
<a id="ga9ac0a7f597daad64a41710dcae6ac644" name="ga9ac0a7f597daad64a41710dcae6ac644"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9ac0a7f597daad64a41710dcae6ac644">&#9670;&nbsp;</a></span>Cy_USBSS_Cal_PTMConfig()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#ga0d79c3063de7043b78fe79bae1e9278a">cy_en_usb_cal_ret_code_t</a> Cy_USBSS_Cal_PTMConfig </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usbss__cal__ctxt__t">cy_stc_usbss_cal_ctxt_t</a> *&#160;</td>
          <td class="paramname"><em>pCalCtxt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ptmControl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function handles PTM related configuration. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pCalCtxt</td><td>The pointer to the USBSS context structure <a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usbss__cal__ctxt__t">cy_stc_usbss_cal_ctxt_t</a> allocated by the user.</td></tr>
    <tr><td class="paramname">ptmControl</td><td>Set to 1 for enabling LDM &amp; PTM. Set to 0 for disabling LDM and reset PTM logic.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The status code of the function execution <a class="el" href="group__group__usbfxstack__usb__common__enums.html#ga0d79c3063de7043b78fe79bae1e9278a">cy_en_usb_cal_ret_code_t</a>. </dd></dl>

</div>
</div>
<a id="ga59e737b497c5fef98d45e23c958961de" name="ga59e737b497c5fef98d45e23c958961de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga59e737b497c5fef98d45e23c958961de">&#9670;&nbsp;</a></span>Cy_USBSS_Cal_EnterLinkCompliance()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cy_USBSS_Cal_EnterLinkCompliance </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usbss__cal__ctxt__t">cy_stc_usbss_cal_ctxt_t</a> *&#160;</td>
          <td class="paramname"><em>pCalCtxt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function performs the actions required when the USB LTSSM enters the Compliance state. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pCalCtxt</td><td>The pointer to the USBSS context structure <a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usbss__cal__ctxt__t">cy_stc_usbss_cal_ctxt_t</a> allocated by the user. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga45eb794902d82fb81204ec9c714bc2bf" name="ga45eb794902d82fb81204ec9c714bc2bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga45eb794902d82fb81204ec9c714bc2bf">&#9670;&nbsp;</a></span>Cy_USBSS_Cal_NextCompliancePattern()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cy_USBSS_Cal_NextCompliancePattern </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usbss__cal__ctxt__t">cy_stc_usbss_cal_ctxt_t</a> *&#160;</td>
          <td class="paramname"><em>pCalCtxt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function causes the LTSSM to move to the next compliance pattern once a Ping.LFPS has been detected. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pCalCtxt</td><td>The pointer to the USBSS context structure <a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usbss__cal__ctxt__t">cy_stc_usbss_cal_ctxt_t</a> allocated by the user. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga5e0a6a9842c4b76b7199e7847b9a1c10" name="ga5e0a6a9842c4b76b7199e7847b9a1c10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5e0a6a9842c4b76b7199e7847b9a1c10">&#9670;&nbsp;</a></span>Cy_USBSS_Cal_ExitLinkCompliance()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cy_USBSS_Cal_ExitLinkCompliance </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usbss__cal__ctxt__t">cy_stc_usbss_cal_ctxt_t</a> *&#160;</td>
          <td class="paramname"><em>pCalCtxt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function performs the required actions when the LTSSM exits the Compliance state due to a Warm Reset. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pCalCtxt</td><td>The pointer to the USBSS context structure <a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usbss__cal__ctxt__t">cy_stc_usbss_cal_ctxt_t</a> allocated by the user. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga4d5d81193ebdbe0cae106c762d85cfd5" name="ga4d5d81193ebdbe0cae106c762d85cfd5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4d5d81193ebdbe0cae106c762d85cfd5">&#9670;&nbsp;</a></span>Cy_USBSS_Cal_SetGen2EBDepth()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cy_USBSS_Cal_SetGen2EBDepth </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usbss__cal__ctxt__t">cy_stc_usbss_cal_ctxt_t</a> *&#160;</td>
          <td class="paramname"><em>pCalCtxt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>gen2_ebdepth</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to update the Elastic Buffer Half Depth setting to be used in Gen2 USB connection. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pCalCtxt</td><td>The pointer to the USBSS context structure <a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usbss__cal__ctxt__t">cy_stc_usbss_cal_ctxt_t</a> allocated by the user.</td></tr>
    <tr><td class="paramname">gen2_ebdepth</td><td>Elastic Buffer Half Depth setting: Valid range from 4 to 16. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga9be60fd522b092a02e235886242afaa1" name="ga9be60fd522b092a02e235886242afaa1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9be60fd522b092a02e235886242afaa1">&#9670;&nbsp;</a></span>Cy_USBSS_Cal_IsEnabled()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Cy_USBSS_Cal_IsEnabled </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usbss__cal__ctxt__t">cy_stc_usbss_cal_ctxt_t</a> *&#160;</td>
          <td class="paramname"><em>pCalCtxt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Indicates whether USB 3.x connection is enabled on the device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pCalCtxt</td><td>The pointer to the USBSS context structure <a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usbss__cal__ctxt__t">cy_stc_usbss_cal_ctxt_t</a> allocated by the user.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if connection is enabled, false otherwise. </dd></dl>

</div>
</div>
<a id="gadf5c8b3b0cafbaed817e3440b2d1c00f" name="gadf5c8b3b0cafbaed817e3440b2d1c00f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadf5c8b3b0cafbaed817e3440b2d1c00f">&#9670;&nbsp;</a></span>Cy_USBSS_Cal_MeasureCCVoltage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t Cy_USBSS_Cal_MeasureCCVoltage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usbss__cal__ctxt__t">cy_stc_usbss_cal_ctxt_t</a> *&#160;</td>
          <td class="paramname"><em>pCalCtxt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>cc2select</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Measure the voltage on CC line and return the corresponding ADC reading. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pCalCtxt</td><td>USBSS Controller context structure. </td></tr>
    <tr><td class="paramname">cc2select</td><td>true to measure CC2 voltage, false for CC1.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ADC reading equivalent to the CC voltage. </dd></dl>

</div>
</div>
<a id="ga32dd04b81939a41a9407227c1fc6fd4a" name="ga32dd04b81939a41a9407227c1fc6fd4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga32dd04b81939a41a9407227c1fc6fd4a">&#9670;&nbsp;</a></span>Cy_USBSS_Cal_SetDmaClkFreq()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#ga0d79c3063de7043b78fe79bae1e9278a">cy_en_usb_cal_ret_code_t</a> Cy_USBSS_Cal_SetDmaClkFreq </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usbss__cal__ctxt__t">cy_stc_usbss_cal_ctxt_t</a> *&#160;</td>
          <td class="paramname"><em>pCalCtxt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__hb__dma__enums.html#gaf07a15620aa6ac9a13b4fffef4cf6a8c">cy_en_hbdma_clk_freq_t</a>&#160;</td>
          <td class="paramname"><em>dmaFreq</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function which sets the desired DMA clock frequency on the FX3G2 device. </p>
<p >This function should be called before USB connection is enabled. The default clock selected is 240 MHz derived from USB2 PLL.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pCalCtxt</td><td>The pointer to the USBSS context structure <a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usbss__cal__ctxt__t">cy_stc_usbss_cal_ctxt_t</a> allocated by the user.</td></tr>
    <tr><td class="paramname">dmaFreq</td><td>Desired DMA clock frequency.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status code </dd></dl>

</div>
</div>
<a id="gaa5afb037192c8eef2e70b9f9e57bf1a7" name="gaa5afb037192c8eef2e70b9f9e57bf1a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa5afb037192c8eef2e70b9f9e57bf1a7">&#9670;&nbsp;</a></span>Cy_USBSS_Cal_DeepSleepPrep()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Cy_USBSS_Cal_DeepSleepPrep </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usbss__cal__ctxt__t">cy_stc_usbss_cal_ctxt_t</a> *&#160;</td>
          <td class="paramname"><em>pCalCtxt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function prepares the USB32DEV controller IP block for entry into deep sleep state. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pCalCtxt</td><td>The pointer to the USBSS context structure <a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usbss__cal__ctxt__t">cy_stc_usbss_cal_ctxt_t</a> allocated by the user.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if application can proceed with deep sleep entry, false otherwise. </dd></dl>

</div>
</div>
<a id="ga07939514c39ef7faafacaa0bb3e9c477" name="ga07939514c39ef7faafacaa0bb3e9c477"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga07939514c39ef7faafacaa0bb3e9c477">&#9670;&nbsp;</a></span>Cy_USBSS_Cal_DeepSleepExit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cy_USBSS_Cal_DeepSleepExit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usbss__cal__ctxt__t">cy_stc_usbss_cal_ctxt_t</a> *&#160;</td>
          <td class="paramname"><em>pCalCtxt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function restores the USB32DEV controller IP block state after USB link has resumed from U3 (suspend) state. </p>
<p >This function is called from the driver internally and not intended to be called directly.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pCalCtxt</td><td>The pointer to the USBSS context structure <a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usbss__cal__ctxt__t">cy_stc_usbss_cal_ctxt_t</a> allocated by the user. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga0a4f7f0c9590b1899c9d6786aebca0a2" name="ga0a4f7f0c9590b1899c9d6786aebca0a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0a4f7f0c9590b1899c9d6786aebca0a2">&#9670;&nbsp;</a></span>Cy_USBSS_Cal_DisableLPMDeviceExit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cy_USBSS_Cal_DisableLPMDeviceExit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usbss__cal__ctxt__t">cy_stc_usbss_cal_ctxt_t</a> *&#160;</td>
          <td class="paramname"><em>pCalCtxt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>devExitDisable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to disable support for device initiated exit from USB low power modes completely. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pCalCtxt</td><td>USBSS Controller context structure. </td></tr>
    <tr><td class="paramname">devExitDisable</td><td>true to disable device initiated exit from LPM states. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part
<div id="nav-path" class="navpath">
    <ul>
        <li class="footer">
            Generated for <b>ModusToolbox USBFXStack</b> by <b>Cypress Semiconductor Corporation</b>.
            All rights reserved.
        </li>
    </ul>
</div>
-->
</body>
</html>
