<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ModusToolbox USBFXStack</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen_style.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><a href="http://www.cypress.com/"><img alt="Logo" src="logo.png"/></a></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">ModusToolbox USBFXStack</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('group__group__usbfxstack__fx__utils__functions.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">Functions<div class="ingroups"><a class="el" href="group__group__usbfxstack__fx__utils.html">FX Utils</a></div></div></div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">General Description</h2>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga0fb4a3012f4b337dd153e1289f5926c0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__fx__utils__functions.html#ga0fb4a3012f4b337dd153e1289f5926c0">InitUart</a> (uint8_t scbIndex)</td></tr>
<tr class="memdesc:ga0fb4a3012f4b337dd153e1289f5926c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize SCB as UART for printing logs.  <a href="group__group__usbfxstack__fx__utils__functions.html#ga0fb4a3012f4b337dd153e1289f5926c0">More...</a><br /></td></tr>
<tr class="separator:ga0fb4a3012f4b337dd153e1289f5926c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaefeea5728c01c203e55e4420c8add5cb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__fx__utils__functions.html#gaefeea5728c01c203e55e4420c8add5cb">Cy_Debug_LogInit</a> (<a class="el" href="group__group__usbfxstack__fx__utils__structs.html#structcy__stc__debug__config__t">cy_stc_debug_config_t</a> *pDbgCfg)</td></tr>
<tr class="memdesc:gaefeea5728c01c203e55e4420c8add5cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">The API initializes the debug logger module with the desired configuration.  <a href="group__group__usbfxstack__fx__utils__functions.html#gaefeea5728c01c203e55e4420c8add5cb">More...</a><br /></td></tr>
<tr class="separator:gaefeea5728c01c203e55e4420c8add5cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4e7e8b0cf6aa7b9fdc30978644fa54c5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__usbfxstack__fx__utils__enums.html#gaedd4e8e9dfaeb575a1df37723dc67e59">cy_en_debug_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__fx__utils__functions.html#ga4e7e8b0cf6aa7b9fdc30978644fa54c5">Cy_Debug_LogDeInit</a> (void)</td></tr>
<tr class="memdesc:ga4e7e8b0cf6aa7b9fdc30978644fa54c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">The API deinitializes the debug logger module.  <a href="group__group__usbfxstack__fx__utils__functions.html#ga4e7e8b0cf6aa7b9fdc30978644fa54c5">More...</a><br /></td></tr>
<tr class="separator:ga4e7e8b0cf6aa7b9fdc30978644fa54c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae4b19bed08d22b1078e243914f8d6779"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__usbfxstack__fx__utils__enums.html#gaedd4e8e9dfaeb575a1df37723dc67e59">cy_en_debug_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__fx__utils__functions.html#gae4b19bed08d22b1078e243914f8d6779">Cy_Debug_AddToLog</a> (uint8_t dbgLevel, char *message,...)</td></tr>
<tr class="memdesc:gae4b19bed08d22b1078e243914f8d6779"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the main logging function supported by this debug module.  <a href="group__group__usbfxstack__fx__utils__functions.html#gae4b19bed08d22b1078e243914f8d6779">More...</a><br /></td></tr>
<tr class="separator:gae4b19bed08d22b1078e243914f8d6779"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab13c61f7ef252d3fab745d20b725f491"><td class="memItemLeft" align="right" valign="top"><a id="gab13c61f7ef252d3fab745d20b725f491" name="gab13c61f7ef252d3fab745d20b725f491"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>Cy_Debug_PrintLog</b> (void)</td></tr>
<tr class="memdesc:gab13c61f7ef252d3fab745d20b725f491"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API is used to get the logger module to incrementally output a part of the saved log messages to the selected interfaces such as UART or Virtual COM port. <br /></td></tr>
<tr class="separator:gab13c61f7ef252d3fab745d20b725f491"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacd0f15e08d9a1320b7b08f0a5d45bf3a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__fx__utils__functions.html#gacd0f15e08d9a1320b7b08f0a5d45bf3a">Cy_Debug_ChangeLogLevel</a> (uint8_t level)</td></tr>
<tr class="memdesc:gacd0f15e08d9a1320b7b08f0a5d45bf3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API can be used to change the verbosity level of messages enabled by the logger module at runtime.  <a href="group__group__usbfxstack__fx__utils__functions.html#gacd0f15e08d9a1320b7b08f0a5d45bf3a">More...</a><br /></td></tr>
<tr class="separator:gacd0f15e08d9a1320b7b08f0a5d45bf3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2e57995933e3b6c5da87b8b1217e117c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__fx__utils__functions.html#ga2e57995933e3b6c5da87b8b1217e117c">Cy_Debug_SetPrintNow</a> (bool immed_print_en)</td></tr>
<tr class="memdesc:ga2e57995933e3b6c5da87b8b1217e117c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API allows the immediate print feature of the debug module to be updated at runtime.  <a href="group__group__usbfxstack__fx__utils__functions.html#ga2e57995933e3b6c5da87b8b1217e117c">More...</a><br /></td></tr>
<tr class="separator:ga2e57995933e3b6c5da87b8b1217e117c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga751fc087d954cfac7356ba19350a136b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__fx__utils__functions.html#ga751fc087d954cfac7356ba19350a136b">Cy_Debug_QueueDataRead</a> (uint8_t *pReadBuffer, uint16_t dataLength, <a class="el" href="group__group__usbfxstack__fx__utils__typedefs.html#gaf8cd8b3a9b4547a32c64518014004d0c">cy_cb_debug_data_recv_cb_t</a> doneCbk, void *pUserCtxt)</td></tr>
<tr class="memdesc:ga751fc087d954cfac7356ba19350a136b"><td class="mdescLeft">&#160;</td><td class="mdescRight">If a CDC interface is being used for data logging, this function queues a read on the corresponding OUT endpoint.  <a href="group__group__usbfxstack__fx__utils__functions.html#ga751fc087d954cfac7356ba19350a136b">More...</a><br /></td></tr>
<tr class="separator:ga751fc087d954cfac7356ba19350a136b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga278b70313ea5e9ed007017832b377036"><td class="memItemLeft" align="right" valign="top"><a id="ga278b70313ea5e9ed007017832b377036" name="ga278b70313ea5e9ed007017832b377036"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>Cy_Debug_HandleReadIntr</b> (void)</td></tr>
<tr class="memdesc:ga278b70313ea5e9ed007017832b377036"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function called from USBFS ISR corresponding to CDC OUT endpoint to read the data and pass on to user callback. <br /></td></tr>
<tr class="separator:ga278b70313ea5e9ed007017832b377036"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa3315e30e4634a50c8d3df7ae9fcab48"><td class="memItemLeft" align="right" valign="top"><a id="gaa3315e30e4634a50c8d3df7ae9fcab48" name="gaa3315e30e4634a50c8d3df7ae9fcab48"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>Cy_USB_CdcEpInDmaISR</b> (void)</td></tr>
<tr class="memdesc:gaa3315e30e4634a50c8d3df7ae9fcab48"><td class="mdescLeft">&#160;</td><td class="mdescRight">CDC IN Endpoint DMA ISR. <br /></td></tr>
<tr class="separator:gaa3315e30e4634a50c8d3df7ae9fcab48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga794619b54345188374ef21031cefa453"><td class="memItemLeft" align="right" valign="top"><a id="ga794619b54345188374ef21031cefa453" name="ga794619b54345188374ef21031cefa453"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>Cy_USB_CdcEpOutDmaISR</b> (void)</td></tr>
<tr class="memdesc:ga794619b54345188374ef21031cefa453"><td class="mdescLeft">&#160;</td><td class="mdescRight">CDC OUT Endpoint DMA ISR. <br /></td></tr>
<tr class="separator:ga794619b54345188374ef21031cefa453"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa0d18c64c8961a8ff51ef03a20123c25"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__fx__utils__functions.html#gaa0d18c64c8961a8ff51ef03a20123c25">Cy_Debug_CdcPrintNow</a> (bool startPrint)</td></tr>
<tr class="memdesc:gaa0d18c64c8961a8ff51ef03a20123c25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable Debug logs over CDC interface.  <a href="group__group__usbfxstack__fx__utils__functions.html#gaa0d18c64c8961a8ff51ef03a20123c25">More...</a><br /></td></tr>
<tr class="separator:gaa0d18c64c8961a8ff51ef03a20123c25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacb605509f2b742261e3627f6ff74c382"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__fx__utils__functions.html#gacb605509f2b742261e3627f6ff74c382">Cy_Efuse_IsBitBlown</a> (uint32_t bitPos, uint32_t offset)</td></tr>
<tr class="memdesc:gacb605509f2b742261e3627f6ff74c382"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether the specified CustomerData eFuse bit is blown.  <a href="group__group__usbfxstack__fx__utils__functions.html#gacb605509f2b742261e3627f6ff74c382">More...</a><br /></td></tr>
<tr class="separator:gacb605509f2b742261e3627f6ff74c382"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad7df8892f9136f9fc000f8c50b9c96c6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__fx__utils__functions.html#gad7df8892f9136f9fc000f8c50b9c96c6">Cy_Efuse_WriteBit</a> (uint32_t bitPos, uint32_t offset)</td></tr>
<tr class="memdesc:gad7df8892f9136f9fc000f8c50b9c96c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Blow one fuse bit in the CustomerData region.  <a href="group__group__usbfxstack__fx__utils__functions.html#gad7df8892f9136f9fc000f8c50b9c96c6">More...</a><br /></td></tr>
<tr class="separator:gad7df8892f9136f9fc000f8c50b9c96c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1cad1f8eda76f8f5515b3b0cd8162a3a"><td class="memItemLeft" align="right" valign="top"><a id="ga1cad1f8eda76f8f5515b3b0cd8162a3a" name="ga1cad1f8eda76f8f5515b3b0cd8162a3a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>InitializeWDT</b> (uint32_t timeout_ms)</td></tr>
<tr class="separator:ga1cad1f8eda76f8f5515b3b0cd8162a3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0c1debcb881e7e2e1847fcf87b0f6e63"><td class="memItemLeft" align="right" valign="top"><a id="ga0c1debcb881e7e2e1847fcf87b0f6e63" name="ga0c1debcb881e7e2e1847fcf87b0f6e63"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>KickWDT</b> (void)</td></tr>
<tr class="separator:ga0c1debcb881e7e2e1847fcf87b0f6e63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8a2edcd097fb16b19b13076805ea3ffd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__fx__utils__functions.html#ga8a2edcd097fb16b19b13076805ea3ffd">Cy_UsbFx_OnResetInit</a> (void)</td></tr>
<tr class="memdesc:ga8a2edcd097fb16b19b13076805ea3ffd"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function performs initialization that is required to enable scatter loading of data into the High BandWidth RAM during device boot-up.  <a href="group__group__usbfxstack__fx__utils__functions.html#ga8a2edcd097fb16b19b13076805ea3ffd">More...</a><br /></td></tr>
<tr class="separator:ga8a2edcd097fb16b19b13076805ea3ffd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae4f158c999383cd222cf71939981fea0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__fx__utils__functions.html#gae4f158c999383cd222cf71939981fea0">Cy_UsbFx_SelectDFTFunctions</a> (uint32_t dft0_func, uint32_t dft1_func, uint32_t usbdft0_func, uint32_t usbdft1_func, uint32_t sipdft0_func, uint32_t sipdft1_func)</td></tr>
<tr class="memdesc:gae4f158c999383cd222cf71939981fea0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function used to select the Design-For-Test debug functions which are to be driven on to the P11.0, P11.1, P9.2, P9.3, P9.4 and P9.5 pins of the EZ-USB FX device.  <a href="group__group__usbfxstack__fx__utils__functions.html#gae4f158c999383cd222cf71939981fea0">More...</a><br /></td></tr>
<tr class="separator:gae4f158c999383cd222cf71939981fea0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5cf44d5bab64a8f284e97950b8ceee34"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__fx__utils__functions.html#ga5cf44d5bab64a8f284e97950b8ceee34">Cy_UsbFx_MemSetDword</a> (uint32_t *pBuffer, uint32_t value, uint32_t byteCount)</td></tr>
<tr class="memdesc:ga5cf44d5bab64a8f284e97950b8ceee34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a memory buffer with the specified 4-byte value.  <a href="group__group__usbfxstack__fx__utils__functions.html#ga5cf44d5bab64a8f284e97950b8ceee34">More...</a><br /></td></tr>
<tr class="separator:ga5cf44d5bab64a8f284e97950b8ceee34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4831d3912d3593c289182b2d55918c2a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__fx__utils__functions.html#ga4831d3912d3593c289182b2d55918c2a">Cy_UsbFx_MemCpyDword</a> (uint32_t *pDst, const uint32_t *pSrc, uint32_t byteCount)</td></tr>
<tr class="memdesc:ga4831d3912d3593c289182b2d55918c2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy data from source to destination buffer using 4-byte words.  <a href="group__group__usbfxstack__fx__utils__functions.html#ga4831d3912d3593c289182b2d55918c2a">More...</a><br /></td></tr>
<tr class="separator:ga4831d3912d3593c289182b2d55918c2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4efb8acb51bffd06f5b1fc8d6f76a173"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__fx__utils__functions.html#ga4efb8acb51bffd06f5b1fc8d6f76a173">Cy_USB_CdcInit</a> (<a class="el" href="group__group__usbfxstack__fx__utils__structs.html#structcy__stc__debug__context__t">cy_stc_debug_context_t</a> *pDbgCtxt)</td></tr>
<tr class="memdesc:ga4efb8acb51bffd06f5b1fc8d6f76a173"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to initialize CDC interface for debug logging.  <a href="group__group__usbfxstack__fx__utils__functions.html#ga4efb8acb51bffd06f5b1fc8d6f76a173">More...</a><br /></td></tr>
<tr class="separator:ga4efb8acb51bffd06f5b1fc8d6f76a173"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2045ac3ec0bc1ad96b38df104352cf33"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__fx__utils__functions.html#ga2045ac3ec0bc1ad96b38df104352cf33">Cy_USB_CdcDeInit</a> (<a class="el" href="group__group__usbfxstack__fx__utils__structs.html#structcy__stc__debug__context__t">cy_stc_debug_context_t</a> *pDbgCtxt)</td></tr>
<tr class="memdesc:ga2045ac3ec0bc1ad96b38df104352cf33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to de-initialize CDC interface for debug logging.  <a href="group__group__usbfxstack__fx__utils__functions.html#ga2045ac3ec0bc1ad96b38df104352cf33">More...</a><br /></td></tr>
<tr class="separator:ga2045ac3ec0bc1ad96b38df104352cf33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga942f6fd81f91594931c4dacf94a88157"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__fx__utils__functions.html#ga942f6fd81f91594931c4dacf94a88157">Cy_Debug_LogtoUsb</a> (<a class="el" href="group__group__usbfxstack__fx__utils__structs.html#structcy__stc__debug__context__t">cy_stc_debug_context_t</a> *pDbgCtxt, uint16_t rdPtr, uint16_t limit)</td></tr>
<tr class="memdesc:ga942f6fd81f91594931c4dacf94a88157"><td class="mdescLeft">&#160;</td><td class="mdescRight">The function used to output log data through USBFS CDC IN endpoint.  <a href="group__group__usbfxstack__fx__utils__functions.html#ga942f6fd81f91594931c4dacf94a88157">More...</a><br /></td></tr>
<tr class="separator:ga942f6fd81f91594931c4dacf94a88157"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6b952f85f64d04031fa2a1f0fa3dcf77"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__fx__utils__functions.html#ga6b952f85f64d04031fa2a1f0fa3dcf77">Cy_USB_CdcClearDmaInterrupt</a> (<a class="el" href="group__group__usbfxstack__fx__utils__structs.html#structcy__stc__debug__context__t">cy_stc_debug_context_t</a> *pDbgCtxt, uint8_t endpDirection, uint32_t endpNumber)</td></tr>
<tr class="memdesc:ga6b952f85f64d04031fa2a1f0fa3dcf77"><td class="mdescLeft">&#160;</td><td class="mdescRight">The function clear the DMA interrrupt associated to the endpoint.  <a href="group__group__usbfxstack__fx__utils__functions.html#ga6b952f85f64d04031fa2a1f0fa3dcf77">More...</a><br /></td></tr>
<tr class="separator:ga6b952f85f64d04031fa2a1f0fa3dcf77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf423654a04d298bbb6c636259de49e46"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__fx__utils__functions.html#gaf423654a04d298bbb6c636259de49e46">Cy_USB_CdcDmaCallback</a> (struct cy_stc_hbdma_channel *pHandle, <a class="el" href="group__group__usbfxstack__hb__dma__enums.html#ga4cef08263826ae203ebb92f2686f8a39">cy_en_hbdma_cb_type_t</a> type, <a class="el" href="group__group__usbfxstack__hb__dma__structs.html#structcy__stc__hbdma__buff__status__t">cy_stc_hbdma_buff_status_t</a> *pbufStat, void *userCtx)</td></tr>
<tr class="memdesc:gaf423654a04d298bbb6c636259de49e46"><td class="mdescLeft">&#160;</td><td class="mdescRight">DMA channel Callback used by the USB CDC logging interface.  <a href="group__group__usbfxstack__fx__utils__functions.html#gaf423654a04d298bbb6c636259de49e46">More...</a><br /></td></tr>
<tr class="separator:gaf423654a04d298bbb6c636259de49e46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga21acfe20c9e7d24563ff3e764661ca32"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__fx__utils__functions.html#ga21acfe20c9e7d24563ff3e764661ca32">Cy_USB_CdcQueueRead</a> (<a class="el" href="group__group__usbfxstack__fx__utils__structs.html#structcy__stc__debug__context__t">cy_stc_debug_context_t</a> *pDbgCtxt, uint8_t endpNumber, uint8_t *pBuffer, uint16_t dataSize)</td></tr>
<tr class="memdesc:ga21acfe20c9e7d24563ff3e764661ca32"><td class="mdescLeft">&#160;</td><td class="mdescRight">The function queue read on OUT endpoint.  <a href="group__group__usbfxstack__fx__utils__functions.html#ga21acfe20c9e7d24563ff3e764661ca32">More...</a><br /></td></tr>
<tr class="separator:ga21acfe20c9e7d24563ff3e764661ca32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabee9036fb0232812c8bd182d0a060dc9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__fx__utils__functions.html#gabee9036fb0232812c8bd182d0a060dc9">Cy_USB_CdcSlpCallback</a> (void *pAppCtxt, <a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__usbd__ctxt__t">cy_stc_usb_usbd_ctxt_t</a> *pUsbdCtxt, <a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__cal__msg__t">cy_stc_usb_cal_msg_t</a> *pMsg)</td></tr>
<tr class="memdesc:gabee9036fb0232812c8bd182d0a060dc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Function will be called by USBD layer when SLP message comes on the CDC OUT endpoint.  <a href="group__group__usbfxstack__fx__utils__functions.html#gabee9036fb0232812c8bd182d0a060dc9">More...</a><br /></td></tr>
<tr class="separator:gabee9036fb0232812c8bd182d0a060dc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga478ea74c858c7bbd69e15f47257d0a19"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__fx__utils__functions.html#ga478ea74c858c7bbd69e15f47257d0a19">Cy_USB_CdcChannelEnable</a> (<a class="el" href="group__group__usbfxstack__fx__utils__structs.html#structcy__stc__debug__context__t">cy_stc_debug_context_t</a> *pDbgCtxt)</td></tr>
<tr class="memdesc:ga478ea74c858c7bbd69e15f47257d0a19"><td class="mdescLeft">&#160;</td><td class="mdescRight">The function enables the CDC Send/Receive DMA channels.  <a href="group__group__usbfxstack__fx__utils__functions.html#ga478ea74c858c7bbd69e15f47257d0a19">More...</a><br /></td></tr>
<tr class="separator:ga478ea74c858c7bbd69e15f47257d0a19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5378b6dd6cdd12e65998a389f47597ed"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__fx__utils__functions.html#ga5378b6dd6cdd12e65998a389f47597ed">CyUsbFsCdc_Init</a> (void)</td></tr>
<tr class="memdesc:ga5378b6dd6cdd12e65998a389f47597ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">The API initializes the USB interface.  <a href="group__group__usbfxstack__fx__utils__functions.html#ga5378b6dd6cdd12e65998a389f47597ed">More...</a><br /></td></tr>
<tr class="separator:ga5378b6dd6cdd12e65998a389f47597ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga37e182711e07019e4787f343a53268b7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__fx__utils__functions.html#ga37e182711e07019e4787f343a53268b7">CyUsbFsCdc_Enable</a> (void)</td></tr>
<tr class="memdesc:ga37e182711e07019e4787f343a53268b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">The function initializes the USB hardware and enables the D+/D- lines and does a pull up on the D+ line for the external host to detect the presence of the device.  <a href="group__group__usbfxstack__fx__utils__functions.html#ga37e182711e07019e4787f343a53268b7">More...</a><br /></td></tr>
<tr class="separator:ga37e182711e07019e4787f343a53268b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacf224cbf5738248fc939655d59cbc366"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__fx__utils__functions.html#gacf224cbf5738248fc939655d59cbc366">CyUsbFsCdc_Disable</a> (void)</td></tr>
<tr class="memdesc:gacf224cbf5738248fc939655d59cbc366"><td class="mdescLeft">&#160;</td><td class="mdescRight">The function disables the USB hardware and disconnects the D+/D- lines.  <a href="group__group__usbfxstack__fx__utils__functions.html#gacf224cbf5738248fc939655d59cbc366">More...</a><br /></td></tr>
<tr class="separator:gacf224cbf5738248fc939655d59cbc366"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3732417c3210c11e0b04b9a1ce808ac0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__usbfxstack__fx__utils__enums.html#gafdda9a37b723065f20403040396554e5">cy_en_usbfs_devstate_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__fx__utils__functions.html#ga3732417c3210c11e0b04b9a1ce808ac0">CyUsbFsCdc_GetState</a> (void)</td></tr>
<tr class="memdesc:ga3732417c3210c11e0b04b9a1ce808ac0"><td class="mdescLeft">&#160;</td><td class="mdescRight">The API returns the current state of the USB device module.  <a href="group__group__usbfxstack__fx__utils__functions.html#ga3732417c3210c11e0b04b9a1ce808ac0">More...</a><br /></td></tr>
<tr class="separator:ga3732417c3210c11e0b04b9a1ce808ac0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9372d7c00d7abe3514e775c6582c84d3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__fx__utils__functions.html#ga9372d7c00d7abe3514e775c6582c84d3">CyUsbFsCdc_CompleteEp0Status</a> (void)</td></tr>
<tr class="memdesc:ga9372d7c00d7abe3514e775c6582c84d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">The API completes the status phase of the current EP0 request.  <a href="group__group__usbfxstack__fx__utils__functions.html#ga9372d7c00d7abe3514e775c6582c84d3">More...</a><br /></td></tr>
<tr class="separator:ga9372d7c00d7abe3514e775c6582c84d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3ee1f9b8c373004e6a8cd719cd57f0d1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__fx__utils__functions.html#ga3ee1f9b8c373004e6a8cd719cd57f0d1">CyUsbFsCdc_Ep0AckWait</a> (void)</td></tr>
<tr class="memdesc:ga3ee1f9b8c373004e6a8cd719cd57f0d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">The function does a blocking wait until the status phase is completed.  <a href="group__group__usbfxstack__fx__utils__functions.html#ga3ee1f9b8c373004e6a8cd719cd57f0d1">More...</a><br /></td></tr>
<tr class="separator:ga3ee1f9b8c373004e6a8cd719cd57f0d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga947b4c77d8ad6743af4d25c8851d3042"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__fx__utils__functions.html#ga947b4c77d8ad6743af4d25c8851d3042">CyUsbFsCdc_StallEp0</a> (void)</td></tr>
<tr class="memdesc:ga947b4c77d8ad6743af4d25c8851d3042"><td class="mdescLeft">&#160;</td><td class="mdescRight">The function stalls endpoint zero to indicate error to current request.  <a href="group__group__usbfxstack__fx__utils__functions.html#ga947b4c77d8ad6743af4d25c8851d3042">More...</a><br /></td></tr>
<tr class="separator:ga947b4c77d8ad6743af4d25c8851d3042"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga77c0bdbb14415fb394c287f2f82451ff"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__fx__utils__functions.html#ga77c0bdbb14415fb394c287f2f82451ff">CyUsbFsCdc_SetupEp0Read</a> (uint8_t *data, uint16_t length, bool last)</td></tr>
<tr class="memdesc:ga77c0bdbb14415fb394c287f2f82451ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">The API does not wait for the read to complete.  <a href="group__group__usbfxstack__fx__utils__functions.html#ga77c0bdbb14415fb394c287f2f82451ff">More...</a><br /></td></tr>
<tr class="separator:ga77c0bdbb14415fb394c287f2f82451ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3a4987825d5afaaa6dcd01e1aef5c7cb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__fx__utils__functions.html#ga3a4987825d5afaaa6dcd01e1aef5c7cb">CyUsbFsCdc_SetupEp0Write</a> (uint8_t *data, uint16_t length, bool last)</td></tr>
<tr class="memdesc:ga3a4987825d5afaaa6dcd01e1aef5c7cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">The API does not wait for the write to complete.  <a href="group__group__usbfxstack__fx__utils__functions.html#ga3a4987825d5afaaa6dcd01e1aef5c7cb">More...</a><br /></td></tr>
<tr class="separator:ga3a4987825d5afaaa6dcd01e1aef5c7cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga73fe6425085835331e6036c5f8cd52d6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__fx__utils__functions.html#ga73fe6425085835331e6036c5f8cd52d6">CyUsbFsCdc_EpEnable</a> (uint8_t ep_index, bool is_out)</td></tr>
<tr class="memdesc:ga73fe6425085835331e6036c5f8cd52d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable an endpoint with the selected configuration.  <a href="group__group__usbfxstack__fx__utils__functions.html#ga73fe6425085835331e6036c5f8cd52d6">More...</a><br /></td></tr>
<tr class="separator:ga73fe6425085835331e6036c5f8cd52d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf77f7ade63eae0e0f203dd15f9044b0d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__fx__utils__functions.html#gaf77f7ade63eae0e0f203dd15f9044b0d">CyUsbFsCdc_EpDisable</a> (uint8_t ep_index)</td></tr>
<tr class="memdesc:gaf77f7ade63eae0e0f203dd15f9044b0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disables a previously enabled endpoint.  <a href="group__group__usbfxstack__fx__utils__functions.html#gaf77f7ade63eae0e0f203dd15f9044b0d">More...</a><br /></td></tr>
<tr class="separator:gaf77f7ade63eae0e0f203dd15f9044b0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2a89bacd2862789fc4a6a0131d791679"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__fx__utils__functions.html#ga2a89bacd2862789fc4a6a0131d791679">CyUsbFsCdc_EpSetStall</a> (uint8_t ep_index)</td></tr>
<tr class="memdesc:ga2a89bacd2862789fc4a6a0131d791679"><td class="mdescLeft">&#160;</td><td class="mdescRight">The endpoint shall stall all IN / OUT tokens after the function has been executed.  <a href="group__group__usbfxstack__fx__utils__functions.html#ga2a89bacd2862789fc4a6a0131d791679">More...</a><br /></td></tr>
<tr class="separator:ga2a89bacd2862789fc4a6a0131d791679"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5baebf0aabfb7d330fa62b616403ab97"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__fx__utils__functions.html#ga5baebf0aabfb7d330fa62b616403ab97">CyUsbFsCdc_EpClearStall</a> (uint8_t ep_index)</td></tr>
<tr class="memdesc:ga5baebf0aabfb7d330fa62b616403ab97"><td class="mdescLeft">&#160;</td><td class="mdescRight">The function shall clear a previously stalled endpoint.  <a href="group__group__usbfxstack__fx__utils__functions.html#ga5baebf0aabfb7d330fa62b616403ab97">More...</a><br /></td></tr>
<tr class="separator:ga5baebf0aabfb7d330fa62b616403ab97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8997881453bd80b2fa5994b13788830c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__fx__utils__functions.html#ga8997881453bd80b2fa5994b13788830c">CyUsbFsCdc_IsEpReady</a> (uint8_t ep_index)</td></tr>
<tr class="memdesc:ga8997881453bd80b2fa5994b13788830c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether the endpoint is ready for data transfer.  <a href="group__group__usbfxstack__fx__utils__functions.html#ga8997881453bd80b2fa5994b13788830c">More...</a><br /></td></tr>
<tr class="separator:ga8997881453bd80b2fa5994b13788830c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8b960f0b839cf7e25cfc0c6cde33c237"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__fx__utils__functions.html#ga8b960f0b839cf7e25cfc0c6cde33c237">CyUsbFsCdc_QueueEpRead</a> (uint8_t ep_index)</td></tr>
<tr class="memdesc:ga8b960f0b839cf7e25cfc0c6cde33c237"><td class="mdescLeft">&#160;</td><td class="mdescRight">The function enables the selected endpoint to receive one packet of data.  <a href="group__group__usbfxstack__fx__utils__functions.html#ga8b960f0b839cf7e25cfc0c6cde33c237">More...</a><br /></td></tr>
<tr class="separator:ga8b960f0b839cf7e25cfc0c6cde33c237"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga84abe79461ba0689b63cc35ef2d074de"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__fx__utils__functions.html#ga84abe79461ba0689b63cc35ef2d074de">CyUsbFsCdc_EpDataRead</a> (uint8_t ep_index, uint8_t *data, uint8_t *count)</td></tr>
<tr class="memdesc:ga84abe79461ba0689b63cc35ef2d074de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the data packet available on the endpoint.  <a href="group__group__usbfxstack__fx__utils__functions.html#ga84abe79461ba0689b63cc35ef2d074de">More...</a><br /></td></tr>
<tr class="separator:ga84abe79461ba0689b63cc35ef2d074de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad8dc0be06978e01b559c8b52bdcc178a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__fx__utils__functions.html#gad8dc0be06978e01b559c8b52bdcc178a">CyUsbFsCdc_SendZlp</a> (uint8_t ep_index)</td></tr>
<tr class="memdesc:gad8dc0be06978e01b559c8b52bdcc178a"><td class="mdescLeft">&#160;</td><td class="mdescRight">The function sends a zero-length packet on the selected IN endpoint.  <a href="group__group__usbfxstack__fx__utils__functions.html#gad8dc0be06978e01b559c8b52bdcc178a">More...</a><br /></td></tr>
<tr class="separator:gad8dc0be06978e01b559c8b52bdcc178a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8f0074c0a98a45f6753fdd5b7c30e304"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__fx__utils__functions.html#ga8f0074c0a98a45f6753fdd5b7c30e304">CyUsbFsCdc_EpDataWrite</a> (uint8_t ep_index, uint8_t *data, uint8_t count)</td></tr>
<tr class="memdesc:ga8f0074c0a98a45f6753fdd5b7c30e304"><td class="mdescLeft">&#160;</td><td class="mdescRight">The function copies the data available in the buffer to the endpoint buffer and arms the endpoint for transfer.  <a href="group__group__usbfxstack__fx__utils__functions.html#ga8f0074c0a98a45f6753fdd5b7c30e304">More...</a><br /></td></tr>
<tr class="separator:ga8f0074c0a98a45f6753fdd5b7c30e304"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf4103715709a52343fc2f19671971ac4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__fx__utils__functions.html#gaf4103715709a52343fc2f19671971ac4">CyUsbFsCdc_EpFlush</a> (uint8_t ep_index)</td></tr>
<tr class="memdesc:gaf4103715709a52343fc2f19671971ac4"><td class="mdescLeft">&#160;</td><td class="mdescRight">The function resets the endpoint and re-arms an OUT endpoint to receive data if a receive was already queued.  <a href="group__group__usbfxstack__fx__utils__functions.html#gaf4103715709a52343fc2f19671971ac4">More...</a><br /></td></tr>
<tr class="separator:gaf4103715709a52343fc2f19671971ac4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga084cff2da557d3f8a9bb2b27d38e8710"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__fx__utils__functions.html#ga084cff2da557d3f8a9bb2b27d38e8710">CyUsbFsCdc_ControlDataReceive</a> (bool recvEnable)</td></tr>
<tr class="memdesc:ga084cff2da557d3f8a9bb2b27d38e8710"><td class="mdescLeft">&#160;</td><td class="mdescRight">Control the handling of data received through the USBFS CDC interface.  <a href="group__group__usbfxstack__fx__utils__functions.html#ga084cff2da557d3f8a9bb2b27d38e8710">More...</a><br /></td></tr>
<tr class="separator:ga084cff2da557d3f8a9bb2b27d38e8710"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga97801d008898af502c57a692a6813f1f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__fx__utils__functions.html#ga97801d008898af502c57a692a6813f1f">Cy_USBHS_App_EnableEpDmaSet</a> (<a class="el" href="group__group__usbfxstack__fx__utils__structs.html#structcy__stc__app__endp__dma__set__t">cy_stc_app_endp_dma_set_t</a> *pEpDmaSet, DW_Type *pDwStruct, uint8_t channelNum, uint8_t epNumber, <a class="el" href="group__group__usbfxstack__usb__common__enums.html#gaaebdfe5d46401ad52420b00ca401e6f8">cy_en_usb_endp_dir_t</a> epDir, uint16_t maxPktSize)</td></tr>
<tr class="memdesc:ga97801d008898af502c57a692a6813f1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configure the DMA resources associated with a USBHS endpoint.  <a href="group__group__usbfxstack__fx__utils__functions.html#ga97801d008898af502c57a692a6813f1f">More...</a><br /></td></tr>
<tr class="separator:ga97801d008898af502c57a692a6813f1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa12cf038737f0426c98ae0df764dad13"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__fx__utils__functions.html#gaa12cf038737f0426c98ae0df764dad13">Cy_USBHS_App_DisableEpDmaSet</a> (<a class="el" href="group__group__usbfxstack__fx__utils__structs.html#structcy__stc__app__endp__dma__set__t">cy_stc_app_endp_dma_set_t</a> *pEpDmaSet)</td></tr>
<tr class="memdesc:gaa12cf038737f0426c98ae0df764dad13"><td class="mdescLeft">&#160;</td><td class="mdescRight">De-init DMA resources related to an USBHS endpoint.  <a href="group__group__usbfxstack__fx__utils__functions.html#gaa12cf038737f0426c98ae0df764dad13">More...</a><br /></td></tr>
<tr class="separator:gaa12cf038737f0426c98ae0df764dad13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7701f1e1cfbd7e0a7136e0e7cc48b0aa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__fx__utils__functions.html#ga7701f1e1cfbd7e0a7136e0e7cc48b0aa">Cy_USBHS_App_ResetEpDma</a> (<a class="el" href="group__group__usbfxstack__fx__utils__structs.html#structcy__stc__app__endp__dma__set__t">cy_stc_app_endp_dma_set_t</a> *pEpDmaSet)</td></tr>
<tr class="memdesc:ga7701f1e1cfbd7e0a7136e0e7cc48b0aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset the DMA resources corresponding to an endpoint.  <a href="group__group__usbfxstack__fx__utils__functions.html#ga7701f1e1cfbd7e0a7136e0e7cc48b0aa">More...</a><br /></td></tr>
<tr class="separator:ga7701f1e1cfbd7e0a7136e0e7cc48b0aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga15586bb414389e3a661532cc1a9220cb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__fx__utils__functions.html#ga15586bb414389e3a661532cc1a9220cb">Cy_USBHS_App_QueueRead</a> (<a class="el" href="group__group__usbfxstack__fx__utils__structs.html#structcy__stc__app__endp__dma__set__t">cy_stc_app_endp_dma_set_t</a> *pEpDmaSet, uint8_t *pBuffer, uint32_t dataSize)</td></tr>
<tr class="memdesc:ga15586bb414389e3a661532cc1a9220cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to queue read operation on an OUT endpoint.  <a href="group__group__usbfxstack__fx__utils__functions.html#ga15586bb414389e3a661532cc1a9220cb">More...</a><br /></td></tr>
<tr class="separator:ga15586bb414389e3a661532cc1a9220cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6d45aa48e0f35510091d893e10b84d9f"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__fx__utils__functions.html#ga6d45aa48e0f35510091d893e10b84d9f">Cy_USBHS_App_ReadShortPacket</a> (<a class="el" href="group__group__usbfxstack__fx__utils__structs.html#structcy__stc__app__endp__dma__set__t">cy_stc_app_endp_dma_set_t</a> *pEpDmaSet, uint16_t pktSize)</td></tr>
<tr class="memdesc:ga6d45aa48e0f35510091d893e10b84d9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to modify an ongoing DMA read operation to take care of a short packet.  <a href="group__group__usbfxstack__fx__utils__functions.html#ga6d45aa48e0f35510091d893e10b84d9f">More...</a><br /></td></tr>
<tr class="separator:ga6d45aa48e0f35510091d893e10b84d9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga853b42a525e0aa30671c4d04fc3d31e9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__fx__utils__functions.html#ga853b42a525e0aa30671c4d04fc3d31e9">Cy_USBHS_App_QueueWrite</a> (<a class="el" href="group__group__usbfxstack__fx__utils__structs.html#structcy__stc__app__endp__dma__set__t">cy_stc_app_endp_dma_set_t</a> *pEpDmaSet, uint8_t *pBuffer, uint32_t dataSize)</td></tr>
<tr class="memdesc:ga853b42a525e0aa30671c4d04fc3d31e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to queue write operation on an IN endpoint.  <a href="group__group__usbfxstack__fx__utils__functions.html#ga853b42a525e0aa30671c4d04fc3d31e9">More...</a><br /></td></tr>
<tr class="separator:ga853b42a525e0aa30671c4d04fc3d31e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga977c3bab2cffff8bd23f9f3cb023fb2d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__fx__utils__functions.html#ga977c3bab2cffff8bd23f9f3cb023fb2d">Cy_USBHS_App_ClearDmaInterrupt</a> (<a class="el" href="group__group__usbfxstack__fx__utils__structs.html#structcy__stc__app__endp__dma__set__t">cy_stc_app_endp_dma_set_t</a> *pEpDmaSet)</td></tr>
<tr class="memdesc:ga977c3bab2cffff8bd23f9f3cb023fb2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable any pending DataWire channel interrupts for an endpoint.  <a href="group__group__usbfxstack__fx__utils__functions.html#ga977c3bab2cffff8bd23f9f3cb023fb2d">More...</a><br /></td></tr>
<tr class="separator:ga977c3bab2cffff8bd23f9f3cb023fb2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga52434f4a962f55fba47ac6d58f144a97"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__fx__utils__functions.html#ga52434f4a962f55fba47ac6d58f144a97">Cy_USBHS_App_IsChannelActive</a> (<a class="el" href="group__group__usbfxstack__fx__utils__structs.html#structcy__stc__app__endp__dma__set__t">cy_stc_app_endp_dma_set_t</a> *pEpDmaSet)</td></tr>
<tr class="memdesc:ga52434f4a962f55fba47ac6d58f144a97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether the DMA channel corresponding to the specified endpoint is active.  <a href="group__group__usbfxstack__fx__utils__functions.html#ga52434f4a962f55fba47ac6d58f144a97">More...</a><br /></td></tr>
<tr class="separator:ga52434f4a962f55fba47ac6d58f144a97"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga0fb4a3012f4b337dd153e1289f5926c0" name="ga0fb4a3012f4b337dd153e1289f5926c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0fb4a3012f4b337dd153e1289f5926c0">&#9670;&nbsp;</a></span>InitUart()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void InitUart </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>scbIndex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize SCB as UART for printing logs. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scbIndex</td><td>Index of SCB to be used for UART output. Only 0 and 1 supported at present. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaefeea5728c01c203e55e4420c8add5cb" name="gaefeea5728c01c203e55e4420c8add5cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaefeea5728c01c203e55e4420c8add5cb">&#9670;&nbsp;</a></span>Cy_Debug_LogInit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cy_Debug_LogInit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__fx__utils__structs.html#structcy__stc__debug__config__t">cy_stc_debug_config_t</a> *&#160;</td>
          <td class="paramname"><em>pDbgCfg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The API initializes the debug logger module with the desired configuration. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pDbgCfg</td><td>Debug module config parameters. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga4e7e8b0cf6aa7b9fdc30978644fa54c5" name="ga4e7e8b0cf6aa7b9fdc30978644fa54c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4e7e8b0cf6aa7b9fdc30978644fa54c5">&#9670;&nbsp;</a></span>Cy_Debug_LogDeInit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__usbfxstack__fx__utils__enums.html#gaedd4e8e9dfaeb575a1df37723dc67e59">cy_en_debug_status_t</a> Cy_Debug_LogDeInit </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The API deinitializes the debug logger module. </p>
<dl class="section return"><dt>Returns</dt><dd>cy_en_debug_status_t </dd></dl>

</div>
</div>
<a id="gae4b19bed08d22b1078e243914f8d6779" name="gae4b19bed08d22b1078e243914f8d6779"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae4b19bed08d22b1078e243914f8d6779">&#9670;&nbsp;</a></span>Cy_Debug_AddToLog()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__usbfxstack__fx__utils__enums.html#gaedd4e8e9dfaeb575a1df37723dc67e59">cy_en_debug_status_t</a> Cy_Debug_AddToLog </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>dbgLevel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>message</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is the main logging function supported by this debug module. </p>
<p >It takes in a variable list of arguments like the printf function, but only the "%c", "%d", "%x" format specifiers are supported. A verbosity level is associated with each message to be printed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dbgLevel</td><td>Verbosity level associated with the message.</td></tr>
    <tr><td class="paramname">message</td><td>Format string.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Success/Failure return code. </dd></dl>

</div>
</div>
<a id="gacd0f15e08d9a1320b7b08f0a5d45bf3a" name="gacd0f15e08d9a1320b7b08f0a5d45bf3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacd0f15e08d9a1320b7b08f0a5d45bf3a">&#9670;&nbsp;</a></span>Cy_Debug_ChangeLogLevel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cy_Debug_ChangeLogLevel </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>level</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API can be used to change the verbosity level of messages enabled by the logger module at runtime. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">level</td><td>New verbosity level to be set. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga2e57995933e3b6c5da87b8b1217e117c" name="ga2e57995933e3b6c5da87b8b1217e117c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2e57995933e3b6c5da87b8b1217e117c">&#9670;&nbsp;</a></span>Cy_Debug_SetPrintNow()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cy_Debug_SetPrintNow </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>immed_print_en</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API allows the immediate print feature of the debug module to be updated at runtime. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">immed_print_en</td><td>Whether immediate (blocking) print function is to be enabled or disabled. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga751fc087d954cfac7356ba19350a136b" name="ga751fc087d954cfac7356ba19350a136b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga751fc087d954cfac7356ba19350a136b">&#9670;&nbsp;</a></span>Cy_Debug_QueueDataRead()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Cy_Debug_QueueDataRead </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>pReadBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>dataLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__fx__utils__typedefs.html#gaf8cd8b3a9b4547a32c64518014004d0c">cy_cb_debug_data_recv_cb_t</a>&#160;</td>
          <td class="paramname"><em>doneCbk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pUserCtxt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If a CDC interface is being used for data logging, this function queues a read on the corresponding OUT endpoint. </p>
<p >The doneCbk will be called once the requested amount of data is received or a SLP/ZLP is received on the OUT endpoint.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pReadBuffer</td><td>Pointer to buffer into which data is to be read.</td></tr>
    <tr><td class="paramname">dataLength</td><td>Maximum size of data to be read. Expected to be a multiple of 64.</td></tr>
    <tr><td class="paramname">doneCbk</td><td>Callback function to be called on read completion.</td></tr>
    <tr><td class="paramname">pUserCtxt</td><td>User context structure to be passed to the callback.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if read operation is queued, false otherwise. </dd></dl>

</div>
</div>
<a id="gaa0d18c64c8961a8ff51ef03a20123c25" name="gaa0d18c64c8961a8ff51ef03a20123c25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa0d18c64c8961a8ff51ef03a20123c25">&#9670;&nbsp;</a></span>Cy_Debug_CdcPrintNow()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cy_Debug_CdcPrintNow </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>startPrint</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable Debug logs over CDC interface. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">startPrint</td><td>Enable the CDC prints. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gacb605509f2b742261e3627f6ff74c382" name="gacb605509f2b742261e3627f6ff74c382"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacb605509f2b742261e3627f6ff74c382">&#9670;&nbsp;</a></span>Cy_Efuse_IsBitBlown()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Cy_Efuse_IsBitBlown </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>bitPos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check whether the specified CustomerData eFuse bit is blown. </p>
<p >The fuse read is done through system call made to USB-FX device ROM code.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bitPos</td><td>Bit position of the fuse to be checked. Valid values are in the range of 0 to 7</td></tr>
    <tr><td class="paramname">offset</td><td>Byte offset of the fuse to be checked. Valid values are in the range of 0x52 to 0x7F</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the fuse bit is already blown, false otherwise. </dd></dl>

</div>
</div>
<a id="gad7df8892f9136f9fc000f8c50b9c96c6" name="gad7df8892f9136f9fc000f8c50b9c96c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad7df8892f9136f9fc000f8c50b9c96c6">&#9670;&nbsp;</a></span>Cy_Efuse_WriteBit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cy_Efuse_WriteBit </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>bitPos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Blow one fuse bit in the CustomerData region. </p>
<p >The fuse programming is done through system call made to the USB-FX device ROM code.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bitPos</td><td>Bit position of the fuse to be written. Valid values are in the range of 0 to 7</td></tr>
    <tr><td class="paramname">offset</td><td>Byte offset of the fuse to be written. Valid values are in the range of 0x52 to 0x7F </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga8a2edcd097fb16b19b13076805ea3ffd" name="ga8a2edcd097fb16b19b13076805ea3ffd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8a2edcd097fb16b19b13076805ea3ffd">&#9670;&nbsp;</a></span>Cy_UsbFx_OnResetInit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cy_UsbFx_OnResetInit </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function performs initialization that is required to enable scatter loading of data into the High BandWidth RAM during device boot-up. </p>
<p >The FX10/FX20 device comes up with the High BandWidth RAM disabled and hence any attempt to read/write the RAM will cause the processor to hang. The RAM needs to be enabled with default clock settings to allow scatter loading to work. This function needs to be called from Cy_OnResetUser. </p>

</div>
</div>
<a id="gae4f158c999383cd222cf71939981fea0" name="gae4f158c999383cd222cf71939981fea0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae4f158c999383cd222cf71939981fea0">&#9670;&nbsp;</a></span>Cy_UsbFx_SelectDFTFunctions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Cy_UsbFx_SelectDFTFunctions </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>dft0_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>dft1_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>usbdft0_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>usbdft1_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>sipdft0_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>sipdft1_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function used to select the Design-For-Test debug functions which are to be driven on to the P11.0, P11.1, P9.2, P9.3, P9.4 and P9.5 pins of the EZ-USB FX device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dft0_func</td><td>Select the debug function to be driven on the P11.0 pin. Any USB/LVDS function is supported. </td></tr>
    <tr><td class="paramname">dft1_func</td><td>Select the debug function to be driven on the P11.1 pin. Any USB/LVDS function is supported. </td></tr>
    <tr><td class="paramname">usbdft0_func</td><td>Select the debug function to be driven on the P9.2 pin. Only USB functions are supported. </td></tr>
    <tr><td class="paramname">usbdft1_func</td><td>Select the debug function to be driven on the P9.3 pin. Only USB functions are supported. </td></tr>
    <tr><td class="paramname">sipdft0_func</td><td>Select the debug function to be driven on the P9.4 pin. Only LVDS/LVCMOS functions are supported. </td></tr>
    <tr><td class="paramname">sipdft1_func</td><td>Select the debug function to be driven on the P9.5 pin. Only LVDS/LVCMOS functions are supported.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if DFT configuration is done, false in case of error. </dd></dl>

</div>
</div>
<a id="ga5cf44d5bab64a8f284e97950b8ceee34" name="ga5cf44d5bab64a8f284e97950b8ceee34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5cf44d5bab64a8f284e97950b8ceee34">&#9670;&nbsp;</a></span>Cy_UsbFx_MemSetDword()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cy_UsbFx_MemSetDword </td>
          <td>(</td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>pBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>byteCount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize a memory buffer with the specified 4-byte value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pBuffer</td><td>Pointer to buffer to be initialized.</td></tr>
    <tr><td class="paramname">value</td><td>Value to initialize the memory buffer with.</td></tr>
    <tr><td class="paramname">byteCount</td><td>Size of the buffer in bytes. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga4831d3912d3593c289182b2d55918c2a" name="ga4831d3912d3593c289182b2d55918c2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4831d3912d3593c289182b2d55918c2a">&#9670;&nbsp;</a></span>Cy_UsbFx_MemCpyDword()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cy_UsbFx_MemCpyDword </td>
          <td>(</td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>pDst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t *&#160;</td>
          <td class="paramname"><em>pSrc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>byteCount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy data from source to destination buffer using 4-byte words. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pDst</td><td>Pointer to destination buffer.</td></tr>
    <tr><td class="paramname">pSrc</td><td>Pointer to source buffer.</td></tr>
    <tr><td class="paramname">byteCount</td><td>Size of the buffer in bytes. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga4efb8acb51bffd06f5b1fc8d6f76a173" name="ga4efb8acb51bffd06f5b1fc8d6f76a173"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4efb8acb51bffd06f5b1fc8d6f76a173">&#9670;&nbsp;</a></span>Cy_USB_CdcInit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Cy_USB_CdcInit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__fx__utils__structs.html#structcy__stc__debug__context__t">cy_stc_debug_context_t</a> *&#160;</td>
          <td class="paramname"><em>pDbgCtxt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to initialize CDC interface for debug logging. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pDbgCtxt</td><td>Debug Context</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if initialization is successful, else False </dd></dl>

</div>
</div>
<a id="ga2045ac3ec0bc1ad96b38df104352cf33" name="ga2045ac3ec0bc1ad96b38df104352cf33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2045ac3ec0bc1ad96b38df104352cf33">&#9670;&nbsp;</a></span>Cy_USB_CdcDeInit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Cy_USB_CdcDeInit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__fx__utils__structs.html#structcy__stc__debug__context__t">cy_stc_debug_context_t</a> *&#160;</td>
          <td class="paramname"><em>pDbgCtxt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to de-initialize CDC interface for debug logging. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pDbgCtxt</td><td>Debug Context</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if deinitialization is successful, else False </dd></dl>

</div>
</div>
<a id="ga942f6fd81f91594931c4dacf94a88157" name="ga942f6fd81f91594931c4dacf94a88157"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga942f6fd81f91594931c4dacf94a88157">&#9670;&nbsp;</a></span>Cy_Debug_LogtoUsb()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t Cy_Debug_LogtoUsb </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__fx__utils__structs.html#structcy__stc__debug__context__t">cy_stc_debug_context_t</a> *&#160;</td>
          <td class="paramname"><em>pDbgCtxt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>rdPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>limit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The function used to output log data through USBFS CDC IN endpoint. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pDbgCtxt</td><td>Debug Context.</td></tr>
    <tr><td class="paramname">rdPtr</td><td>Pointer to read data</td></tr>
    <tr><td class="paramname">limit</td><td>Number of bytes to be read</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>return rdPtr pointer value </dd></dl>

</div>
</div>
<a id="ga6b952f85f64d04031fa2a1f0fa3dcf77" name="ga6b952f85f64d04031fa2a1f0fa3dcf77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6b952f85f64d04031fa2a1f0fa3dcf77">&#9670;&nbsp;</a></span>Cy_USB_CdcClearDmaInterrupt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cy_USB_CdcClearDmaInterrupt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__fx__utils__structs.html#structcy__stc__debug__context__t">cy_stc_debug_context_t</a> *&#160;</td>
          <td class="paramname"><em>pDbgCtxt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>endpDirection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>endpNumber</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The function clear the DMA interrrupt associated to the endpoint. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pDbgCtxt</td><td>Debug Context.</td></tr>
    <tr><td class="paramname">endpDirection</td><td>IN or OUT endpoint</td></tr>
    <tr><td class="paramname">endpNumber</td><td>Endpoint Number </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaf423654a04d298bbb6c636259de49e46" name="gaf423654a04d298bbb6c636259de49e46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf423654a04d298bbb6c636259de49e46">&#9670;&nbsp;</a></span>Cy_USB_CdcDmaCallback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cy_USB_CdcDmaCallback </td>
          <td>(</td>
          <td class="paramtype">struct cy_stc_hbdma_channel *&#160;</td>
          <td class="paramname"><em>pHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__hb__dma__enums.html#ga4cef08263826ae203ebb92f2686f8a39">cy_en_hbdma_cb_type_t</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__hb__dma__structs.html#structcy__stc__hbdma__buff__status__t">cy_stc_hbdma_buff_status_t</a> *&#160;</td>
          <td class="paramname"><em>pbufStat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>userCtx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>DMA channel Callback used by the USB CDC logging interface. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pHandle</td><td>CDC Channel Handle.</td></tr>
    <tr><td class="paramname">type</td><td>Event type</td></tr>
    <tr><td class="paramname">pbufStat</td><td>DMA buffer pointer</td></tr>
    <tr><td class="paramname">userCtx</td><td>User context </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga21acfe20c9e7d24563ff3e764661ca32" name="ga21acfe20c9e7d24563ff3e764661ca32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga21acfe20c9e7d24563ff3e764661ca32">&#9670;&nbsp;</a></span>Cy_USB_CdcQueueRead()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cy_USB_CdcQueueRead </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__fx__utils__structs.html#structcy__stc__debug__context__t">cy_stc_debug_context_t</a> *&#160;</td>
          <td class="paramname"><em>pDbgCtxt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>endpNumber</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>pBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>dataSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The function queue read on OUT endpoint. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pDbgCtxt</td><td>Debug Context.</td></tr>
    <tr><td class="paramname">endpNumber</td><td>Out Endpoint number to queue the read</td></tr>
    <tr><td class="paramname">pBuffer</td><td>Buffer pointer to store the read data.</td></tr>
    <tr><td class="paramname">dataSize</td><td>Bytes to read on OUT endpoint </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gabee9036fb0232812c8bd182d0a060dc9" name="gabee9036fb0232812c8bd182d0a060dc9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabee9036fb0232812c8bd182d0a060dc9">&#9670;&nbsp;</a></span>Cy_USB_CdcSlpCallback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cy_USB_CdcSlpCallback </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pAppCtxt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__usbd__ctxt__t">cy_stc_usb_usbd_ctxt_t</a> *&#160;</td>
          <td class="paramname"><em>pUsbdCtxt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__structs.html#structcy__stc__usb__cal__msg__t">cy_stc_usb_cal_msg_t</a> *&#160;</td>
          <td class="paramname"><em>pMsg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The Function will be called by USBD layer when SLP message comes on the CDC OUT endpoint. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pAppCtxt</td><td>User context</td></tr>
    <tr><td class="paramname">pUsbdCtxt</td><td>USBD context</td></tr>
    <tr><td class="paramname">pMsg</td><td>Message </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga478ea74c858c7bbd69e15f47257d0a19" name="ga478ea74c858c7bbd69e15f47257d0a19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga478ea74c858c7bbd69e15f47257d0a19">&#9670;&nbsp;</a></span>Cy_USB_CdcChannelEnable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Cy_USB_CdcChannelEnable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__fx__utils__structs.html#structcy__stc__debug__context__t">cy_stc_debug_context_t</a> *&#160;</td>
          <td class="paramname"><em>pDbgCtxt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The function enables the CDC Send/Receive DMA channels. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pDbgCtxt</td><td>Debug context</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if channel was enabled successfully, false otherwise. </dd></dl>

</div>
</div>
<a id="ga5378b6dd6cdd12e65998a389f47597ed" name="ga5378b6dd6cdd12e65998a389f47597ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5378b6dd6cdd12e65998a389f47597ed">&#9670;&nbsp;</a></span>CyUsbFsCdc_Init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool CyUsbFsCdc_Init </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The API initializes the USB interface. </p>
<p >This is mainly a software state machine initialization. The PHY is not enabled at this point. The API helps to cleanup previous state information.</p>
<dl class="section return"><dt>Returns</dt><dd>true if the action is successful, false otherwise. </dd></dl>

</div>
</div>
<a id="ga37e182711e07019e4787f343a53268b7" name="ga37e182711e07019e4787f343a53268b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga37e182711e07019e4787f343a53268b7">&#9670;&nbsp;</a></span>CyUsbFsCdc_Enable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool CyUsbFsCdc_Enable </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The function initializes the USB hardware and enables the D+/D- lines and does a pull up on the D+ line for the external host to detect the presence of the device. </p>
<p >The API expects that the USB block is already initialized.</p>
<dl class="section return"><dt>Returns</dt><dd>true if the action is successful, false otherwise. </dd></dl>

</div>
</div>
<a id="gacf224cbf5738248fc939655d59cbc366" name="gacf224cbf5738248fc939655d59cbc366"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacf224cbf5738248fc939655d59cbc366">&#9670;&nbsp;</a></span>CyUsbFsCdc_Disable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool CyUsbFsCdc_Disable </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The function disables the USB hardware and disconnects the D+/D- lines. </p>
<dl class="section return"><dt>Returns</dt><dd>true if the action is successful, false otherwise. </dd></dl>

</div>
</div>
<a id="ga3732417c3210c11e0b04b9a1ce808ac0" name="ga3732417c3210c11e0b04b9a1ce808ac0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3732417c3210c11e0b04b9a1ce808ac0">&#9670;&nbsp;</a></span>CyUsbFsCdc_GetState()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__usbfxstack__fx__utils__enums.html#gafdda9a37b723065f20403040396554e5">cy_en_usbfs_devstate_t</a> CyUsbFsCdc_GetState </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The API returns the current state of the USB device module. </p>
<dl class="section return"><dt>Returns</dt><dd>The current USB device/stack state. </dd></dl>

</div>
</div>
<a id="ga9372d7c00d7abe3514e775c6582c84d3" name="ga9372d7c00d7abe3514e775c6582c84d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9372d7c00d7abe3514e775c6582c84d3">&#9670;&nbsp;</a></span>CyUsbFsCdc_CompleteEp0Status()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool CyUsbFsCdc_CompleteEp0Status </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The API completes the status phase of the current EP0 request. </p>
<p >The caller is expected to call the function in sequence. The status phase is handled inplicitly when the setup_read and setup_write functions are invoked correctly with the last flag set to true. The function does not wait for the transfer to complete. In case of an error, the EP0 shall be stalled by the USB module.</p>
<dl class="section return"><dt>Returns</dt><dd>true if the action is successful, false otherwise. </dd></dl>

</div>
</div>
<a id="ga3ee1f9b8c373004e6a8cd719cd57f0d1" name="ga3ee1f9b8c373004e6a8cd719cd57f0d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3ee1f9b8c373004e6a8cd719cd57f0d1">&#9670;&nbsp;</a></span>CyUsbFsCdc_Ep0AckWait()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool CyUsbFsCdc_Ep0AckWait </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The function does a blocking wait until the status phase is completed. </p>
<p >This function should be invoked only if the task loop can be safely blocked.</p>
<dl class="section return"><dt>Returns</dt><dd>true if the action is successful, false otherwise. </dd></dl>

</div>
</div>
<a id="ga947b4c77d8ad6743af4d25c8851d3042" name="ga947b4c77d8ad6743af4d25c8851d3042"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga947b4c77d8ad6743af4d25c8851d3042">&#9670;&nbsp;</a></span>CyUsbFsCdc_StallEp0()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool CyUsbFsCdc_StallEp0 </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The function stalls endpoint zero to indicate error to current request. </p>
<p >The stall is automatically cleared on receiving a new setup request.</p>
<dl class="section return"><dt>Returns</dt><dd>true if the action is successful, false otherwise. </dd></dl>

</div>
</div>
<a id="ga77c0bdbb14415fb394c287f2f82451ff" name="ga77c0bdbb14415fb394c287f2f82451ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga77c0bdbb14415fb394c287f2f82451ff">&#9670;&nbsp;</a></span>CyUsbFsCdc_SetupEp0Read()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool CyUsbFsCdc_SetupEp0Read </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The API does not wait for the read to complete. </p>
<p >The function just updates the state machine and queues the first packet read. The read has to be completed by repeatedly queueing packet read requests. The last parameter can be used to do multiple partial transfers. For default single tranfers, the last parameter should always be true.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>Buffer to write the received USB EP0 data into. The caller should ensure that the buffer is capable of receiving upto a size of length bytes.</td></tr>
    <tr><td class="paramname">length</td><td>Length of data to be transferred. This has to be a multiple of eight bytes.</td></tr>
    <tr><td class="paramname">last</td><td>Whether the request is a partial transfer or not. Set to true if the stack needs to implicily handle the status phase after completing the transfer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the action is successful, false otherwise. </dd></dl>

</div>
</div>
<a id="ga3a4987825d5afaaa6dcd01e1aef5c7cb" name="ga3a4987825d5afaaa6dcd01e1aef5c7cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3a4987825d5afaaa6dcd01e1aef5c7cb">&#9670;&nbsp;</a></span>CyUsbFsCdc_SetupEp0Write()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool CyUsbFsCdc_SetupEp0Write </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The API does not wait for the write to complete. </p>
<p >The function just updates the state machine and queues the first packet. The write has to be completed by repeatedly queueing packet requests. The last parameter can be used to do multiple partial transfers. For default single tranfers, the last parameter should always be true.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>Buffer containing the USB EP0 data to be transferred.</td></tr>
    <tr><td class="paramname">length</td><td>Length of data to be transferred.</td></tr>
    <tr><td class="paramname">last</td><td>Whether the request is a partial transfer or not. Set to true if the stack needs to implicily handle the status phase after completing the transfer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the action is successful, false otherwise. </dd></dl>

</div>
</div>
<a id="ga73fe6425085835331e6036c5f8cd52d6" name="ga73fe6425085835331e6036c5f8cd52d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga73fe6425085835331e6036c5f8cd52d6">&#9670;&nbsp;</a></span>CyUsbFsCdc_EpEnable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool CyUsbFsCdc_EpEnable </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>ep_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>is_out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable an endpoint with the selected configuration. </p>
<p >The endpoint shall be initialized and configured with the provided parameters. The API expects the endpoint to be in disabled state.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ep_index</td><td>Index of endpoint to be enabled. Valid values are from 1 to 8 (inclusive).</td></tr>
    <tr><td class="paramname">is_out</td><td>true if the endpoint is an OUT endpoint, false for IN endpoint.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the action is successful, false otherwise. </dd></dl>

</div>
</div>
<a id="gaf77f7ade63eae0e0f203dd15f9044b0d" name="gaf77f7ade63eae0e0f203dd15f9044b0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf77f7ade63eae0e0f203dd15f9044b0d">&#9670;&nbsp;</a></span>CyUsbFsCdc_EpDisable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool CyUsbFsCdc_EpDisable </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>ep_index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disables a previously enabled endpoint. </p>
<p >The endpoint shall be disabled and all data in the FIFO cleared. The endpoint shall stop responding to requests from USB host.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ep_index</td><td>Index of endpoint to be disabled. Valid values are from 1 to 8 (inclusive).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the action is successful, false otherwise. </dd></dl>

</div>
</div>
<a id="ga2a89bacd2862789fc4a6a0131d791679" name="ga2a89bacd2862789fc4a6a0131d791679"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2a89bacd2862789fc4a6a0131d791679">&#9670;&nbsp;</a></span>CyUsbFsCdc_EpSetStall()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool CyUsbFsCdc_EpSetStall </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>ep_index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The endpoint shall stall all IN / OUT tokens after the function has been executed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ep_index</td><td>Index of endpoint to be modified. Valid values are from 1 to 8 (inclusive).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the action is successful, false otherwise. </dd></dl>

</div>
</div>
<a id="ga5baebf0aabfb7d330fa62b616403ab97" name="ga5baebf0aabfb7d330fa62b616403ab97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5baebf0aabfb7d330fa62b616403ab97">&#9670;&nbsp;</a></span>CyUsbFsCdc_EpClearStall()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool CyUsbFsCdc_EpClearStall </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>ep_index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The function shall clear a previously stalled endpoint. </p>
<p >The function shall reset the data toggle even if the endpoint was not previously stalled. This call shall also reset the endpoint to the default state. So read should be explicitly invoked for an OUT endpoint. The endpoint shall start NAKing all the IN / OUT tokens once the function gets executed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ep_index</td><td>Index of endpoint to be modified. Valid values are from 1 to 8 (inclusive).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the action is successful, false otherwise. </dd></dl>

</div>
</div>
<a id="ga8997881453bd80b2fa5994b13788830c" name="ga8997881453bd80b2fa5994b13788830c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8997881453bd80b2fa5994b13788830c">&#9670;&nbsp;</a></span>CyUsbFsCdc_IsEpReady()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool CyUsbFsCdc_IsEpReady </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>ep_index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks whether the endpoint is ready for data transfer. </p>
<p >The API expects that the endpoint is enabled and active.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ep_index</td><td>Endpoint to be checked</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Endpoint status: true - If this is an IN endpoint, then the EP is ready to send data. If there was a previous transfer then it has completed successfully. If this is an OUT endpoint, then the EP has received a packet of data from the USB host. false - If this is an IN endpoint, data is being sent out and not completed. If this is an OUT endpoint, then the data is not yet received. If the endpoint is not active or USB connection is not active, this API returns CyFalse. </dd></dl>

</div>
</div>
<a id="ga8b960f0b839cf7e25cfc0c6cde33c237" name="ga8b960f0b839cf7e25cfc0c6cde33c237"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8b960f0b839cf7e25cfc0c6cde33c237">&#9670;&nbsp;</a></span>CyUsbFsCdc_QueueEpRead()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool CyUsbFsCdc_QueueEpRead </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>ep_index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The function enables the selected endpoint to receive one packet of data. </p>
<p >It does not wait for the data to be received.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ep_index</td><td>Index of endpoint on which read is to be queued.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the operation is successful, false otherwise. </dd></dl>

</div>
</div>
<a id="ga84abe79461ba0689b63cc35ef2d074de" name="ga84abe79461ba0689b63cc35ef2d074de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga84abe79461ba0689b63cc35ef2d074de">&#9670;&nbsp;</a></span>CyUsbFsCdc_EpDataRead()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool CyUsbFsCdc_EpDataRead </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>ep_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves the data packet available on the endpoint. </p>
<p >The function expects that a data is already available and retrieves the packet from the endpoint buffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ep_index</td><td>Index of endpoint on which read is to be performed.</td></tr>
    <tr><td class="paramname">data</td><td>Pointer to buffer into which the data should be read.</td></tr>
    <tr><td class="paramname">count</td><td>Size of the data to be read (in bytes).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the operation is successful, false otherwise. </dd></dl>

</div>
</div>
<a id="gad8dc0be06978e01b559c8b52bdcc178a" name="gad8dc0be06978e01b559c8b52bdcc178a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad8dc0be06978e01b559c8b52bdcc178a">&#9670;&nbsp;</a></span>CyUsbFsCdc_SendZlp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool CyUsbFsCdc_SendZlp </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>ep_index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The function sends a zero-length packet on the selected IN endpoint. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ep_index</td><td>Index of endpoint on which ZLP is to be sent.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the operation is successful, false otherwise. </dd></dl>

</div>
</div>
<a id="ga8f0074c0a98a45f6753fdd5b7c30e304" name="ga8f0074c0a98a45f6753fdd5b7c30e304"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8f0074c0a98a45f6753fdd5b7c30e304">&#9670;&nbsp;</a></span>CyUsbFsCdc_EpDataWrite()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool CyUsbFsCdc_EpDataWrite </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>ep_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The function copies the data available in the buffer to the endpoint buffer and arms the endpoint for transfer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ep_index</td><td>Index of endpoint on which data is to be transferred.</td></tr>
    <tr><td class="paramname">data</td><td>Pointer to buffer containing the data to be written.</td></tr>
    <tr><td class="paramname">count</td><td>Size of the data to be transferred (in bytes).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the operation is successful, false otherwise. </dd></dl>

</div>
</div>
<a id="gaf4103715709a52343fc2f19671971ac4" name="gaf4103715709a52343fc2f19671971ac4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf4103715709a52343fc2f19671971ac4">&#9670;&nbsp;</a></span>CyUsbFsCdc_EpFlush()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool CyUsbFsCdc_EpFlush </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>ep_index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The function resets the endpoint and re-arms an OUT endpoint to receive data if a receive was already queued. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ep_index</td><td>Index of endpoint which is to be flushed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the operation is successful, false otherwise. </dd></dl>

</div>
</div>
<a id="ga084cff2da557d3f8a9bb2b27d38e8710" name="ga084cff2da557d3f8a9bb2b27d38e8710"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga084cff2da557d3f8a9bb2b27d38e8710">&#9670;&nbsp;</a></span>CyUsbFsCdc_ControlDataReceive()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CyUsbFsCdc_ControlDataReceive </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>recvEnable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Control the handling of data received through the USBFS CDC interface. </p>
<p >When data receive is not enabled, the driver will keep discarding any data received on the OUT endpoint. When data receive is enabled, it is expected that the user will queue read operations to fetch the OUT data as required.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">recvEnable</td><td>Whether data receive handling is enabled. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga97801d008898af502c57a692a6813f1f" name="ga97801d008898af502c57a692a6813f1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga97801d008898af502c57a692a6813f1f">&#9670;&nbsp;</a></span>Cy_USBHS_App_EnableEpDmaSet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Cy_USBHS_App_EnableEpDmaSet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__fx__utils__structs.html#structcy__stc__app__endp__dma__set__t">cy_stc_app_endp_dma_set_t</a> *&#160;</td>
          <td class="paramname"><em>pEpDmaSet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DW_Type *&#160;</td>
          <td class="paramname"><em>pDwStruct</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>channelNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>epNumber</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__usb__common__enums.html#gaaebdfe5d46401ad52420b00ca401e6f8">cy_en_usb_endp_dir_t</a>&#160;</td>
          <td class="paramname"><em>epDir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>maxPktSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configure the DMA resources associated with a USBHS endpoint. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pEpDmaSet</td><td>USBHS endpoint DMA wrapper structure</td></tr>
    <tr><td class="paramname">pDwStruct</td><td>Pointer to DataWire instance to be used for this endpoint.</td></tr>
    <tr><td class="paramname">channelNum</td><td>DataWire channel number to be used.</td></tr>
    <tr><td class="paramname">epNumber</td><td>USB endpoint number.</td></tr>
    <tr><td class="paramname">epDir</td><td>USB endpoint direction.</td></tr>
    <tr><td class="paramname">maxPktSize</td><td>Maximum packet size for the endpoint.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the action is successful, false otherwise. </dd></dl>

</div>
</div>
<a id="gaa12cf038737f0426c98ae0df764dad13" name="gaa12cf038737f0426c98ae0df764dad13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa12cf038737f0426c98ae0df764dad13">&#9670;&nbsp;</a></span>Cy_USBHS_App_DisableEpDmaSet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cy_USBHS_App_DisableEpDmaSet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__fx__utils__structs.html#structcy__stc__app__endp__dma__set__t">cy_stc_app_endp_dma_set_t</a> *&#160;</td>
          <td class="paramname"><em>pEpDmaSet</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>De-init DMA resources related to an USBHS endpoint. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pEpDmaSet</td><td>USBHS endpoint DMA wrapper structure </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga7701f1e1cfbd7e0a7136e0e7cc48b0aa" name="ga7701f1e1cfbd7e0a7136e0e7cc48b0aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7701f1e1cfbd7e0a7136e0e7cc48b0aa">&#9670;&nbsp;</a></span>Cy_USBHS_App_ResetEpDma()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cy_USBHS_App_ResetEpDma </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__fx__utils__structs.html#structcy__stc__app__endp__dma__set__t">cy_stc_app_endp_dma_set_t</a> *&#160;</td>
          <td class="paramname"><em>pEpDmaSet</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reset the DMA resources corresponding to an endpoint. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pEpDmaSet</td><td>USBHS endpoint DMA wrapper structure </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga15586bb414389e3a661532cc1a9220cb" name="ga15586bb414389e3a661532cc1a9220cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga15586bb414389e3a661532cc1a9220cb">&#9670;&nbsp;</a></span>Cy_USBHS_App_QueueRead()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Cy_USBHS_App_QueueRead </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__fx__utils__structs.html#structcy__stc__app__endp__dma__set__t">cy_stc_app_endp_dma_set_t</a> *&#160;</td>
          <td class="paramname"><em>pEpDmaSet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>pBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>dataSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to queue read operation on an OUT endpoint. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pEpDmaSet</td><td>USBHS endpoint DMA wrapper structure</td></tr>
    <tr><td class="paramname">pBuffer</td><td>Pointer to buffer into which the data should be read.</td></tr>
    <tr><td class="paramname">dataSize</td><td>Amount of data (in bytes) to be read.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the action is successful, false otherwise. </dd></dl>

</div>
</div>
<a id="ga6d45aa48e0f35510091d893e10b84d9f" name="ga6d45aa48e0f35510091d893e10b84d9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6d45aa48e0f35510091d893e10b84d9f">&#9670;&nbsp;</a></span>Cy_USBHS_App_ReadShortPacket()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t Cy_USBHS_App_ReadShortPacket </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__fx__utils__structs.html#structcy__stc__app__endp__dma__set__t">cy_stc_app_endp_dma_set_t</a> *&#160;</td>
          <td class="paramname"><em>pEpDmaSet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>pktSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to modify an ongoing DMA read operation to take care of a short packet. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pEpDmaSet</td><td>USBHS endpoint DMA wrapper structure</td></tr>
    <tr><td class="paramname">pktSize</td><td>Size (in bytes) of the short packet which has been received.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Total amount of data received on the endpoint including any previous full packets. </dd></dl>

</div>
</div>
<a id="ga853b42a525e0aa30671c4d04fc3d31e9" name="ga853b42a525e0aa30671c4d04fc3d31e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga853b42a525e0aa30671c4d04fc3d31e9">&#9670;&nbsp;</a></span>Cy_USBHS_App_QueueWrite()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Cy_USBHS_App_QueueWrite </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__fx__utils__structs.html#structcy__stc__app__endp__dma__set__t">cy_stc_app_endp_dma_set_t</a> *&#160;</td>
          <td class="paramname"><em>pEpDmaSet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>pBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>dataSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to queue write operation on an IN endpoint. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pEpDmaSet</td><td>USBHS endpoint DMA wrapper structure</td></tr>
    <tr><td class="paramname">pBuffer</td><td>Pointer to buffer containing write data.</td></tr>
    <tr><td class="paramname">dataSize</td><td>Amount of data to be transferred (in bytes).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the action is successful, false otherwise. </dd></dl>

</div>
</div>
<a id="ga977c3bab2cffff8bd23f9f3cb023fb2d" name="ga977c3bab2cffff8bd23f9f3cb023fb2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga977c3bab2cffff8bd23f9f3cb023fb2d">&#9670;&nbsp;</a></span>Cy_USBHS_App_ClearDmaInterrupt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cy_USBHS_App_ClearDmaInterrupt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__fx__utils__structs.html#structcy__stc__app__endp__dma__set__t">cy_stc_app_endp_dma_set_t</a> *&#160;</td>
          <td class="paramname"><em>pEpDmaSet</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disable any pending DataWire channel interrupts for an endpoint. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pEpDmaSet</td><td>USBHS endpoint DMA wrapper structure </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga52434f4a962f55fba47ac6d58f144a97" name="ga52434f4a962f55fba47ac6d58f144a97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga52434f4a962f55fba47ac6d58f144a97">&#9670;&nbsp;</a></span>Cy_USBHS_App_IsChannelActive()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Cy_USBHS_App_IsChannelActive </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__fx__utils__structs.html#structcy__stc__app__endp__dma__set__t">cy_stc_app_endp_dma_set_t</a> *&#160;</td>
          <td class="paramname"><em>pEpDmaSet</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check whether the DMA channel corresponding to the specified endpoint is active. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pEpDmaSet</td><td>USBHS endpoint DMA wrapper structure</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the channel is active, false otherwise. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part
<div id="nav-path" class="navpath">
    <ul>
        <li class="footer">
            Generated for <b>ModusToolbox USBFXStack</b> by <b>Cypress Semiconductor Corporation</b>.
            All rights reserved.
        </li>
    </ul>
</div>
-->
</body>
</html>
