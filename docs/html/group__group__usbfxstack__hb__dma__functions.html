<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ModusToolbox USBFXStack</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen_style.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><a href="http://www.cypress.com/"><img alt="Logo" src="logo.png"/></a></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">ModusToolbox USBFXStack</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('group__group__usbfxstack__hb__dma__functions.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">Functions<div class="ingroups"><a class="el" href="group__group__usbfxstack__hb__dma.html">HB-DMA</a></div></div></div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">General Description</h2>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gab7604ab75c6effda2157d432dc0e8075"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__usbfxstack__hb__dma__enums.html#gaf3e10413a429d02d39bde06bd19fa9ab">cy_en_hbdma_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__hb__dma__functions.html#gab7604ab75c6effda2157d432dc0e8075">Cy_HBDma_Init</a> (LVDSSS_LVDS_Type *lvds_base, USB32DEV_Type *usbss_base, <a class="el" href="group__group__usbfxstack__hb__dma__structs.html#structcy__stc__hbdma__context__t">cy_stc_hbdma_context_t</a> *pContext, uint32_t usb_egrs_fq_depth, uint32_t usb_egrs_rq_ctrl)</td></tr>
<tr class="memdesc:gab7604ab75c6effda2157d432dc0e8075"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the High BandWidth DMA driver.  <a href="group__group__usbfxstack__hb__dma__functions.html#gab7604ab75c6effda2157d432dc0e8075">More...</a><br /></td></tr>
<tr class="separator:gab7604ab75c6effda2157d432dc0e8075"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7afaba6c4e0610da3f9240442b3c5ead"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__hb__dma__functions.html#ga7afaba6c4e0610da3f9240442b3c5ead">Cy_HBDma_DeInit</a> (<a class="el" href="group__group__usbfxstack__hb__dma__structs.html#structcy__stc__hbdma__context__t">cy_stc_hbdma_context_t</a> *pContext)</td></tr>
<tr class="memdesc:ga7afaba6c4e0610da3f9240442b3c5ead"><td class="mdescLeft">&#160;</td><td class="mdescRight">De-initialize the High BandWidth DMA adapter.  <a href="group__group__usbfxstack__hb__dma__functions.html#ga7afaba6c4e0610da3f9240442b3c5ead">More...</a><br /></td></tr>
<tr class="separator:ga7afaba6c4e0610da3f9240442b3c5ead"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8a99bdb364b392c87d12f143f8488288"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__usbfxstack__hb__dma__enums.html#gaf3e10413a429d02d39bde06bd19fa9ab">cy_en_hbdma_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__hb__dma__functions.html#ga8a99bdb364b392c87d12f143f8488288">Cy_HBDma_GetDescriptor</a> (uint16_t dscrIndex, <a class="el" href="group__group__usbfxstack__hb__dma__structs.html#structcy__stc__hbdma__desc__t">cy_stc_hbdma_desc_t</a> *dscr_p)</td></tr>
<tr class="memdesc:ga8a99bdb364b392c87d12f143f8488288"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads and returns the contents of the High BandWidth DMA descriptor with the specified index.  <a href="group__group__usbfxstack__hb__dma__functions.html#ga8a99bdb364b392c87d12f143f8488288">More...</a><br /></td></tr>
<tr class="separator:ga8a99bdb364b392c87d12f143f8488288"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga815ddd5d10b5a5bc14927c0522b10c8f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__usbfxstack__hb__dma__enums.html#gaf3e10413a429d02d39bde06bd19fa9ab">cy_en_hbdma_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__hb__dma__functions.html#ga815ddd5d10b5a5bc14927c0522b10c8f">Cy_HBDma_SetDescriptor</a> (uint16_t dscrIndex, <a class="el" href="group__group__usbfxstack__hb__dma__structs.html#structcy__stc__hbdma__desc__t">cy_stc_hbdma_desc_t</a> *dscr_p)</td></tr>
<tr class="memdesc:ga815ddd5d10b5a5bc14927c0522b10c8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates the High BandWidth DMA descriptor at a specified index with the desired values.  <a href="group__group__usbfxstack__hb__dma__functions.html#ga815ddd5d10b5a5bc14927c0522b10c8f">More...</a><br /></td></tr>
<tr class="separator:ga815ddd5d10b5a5bc14927c0522b10c8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac0d27f05e71c9f155e6512a62ee4264a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__usbfxstack__hb__dma__enums.html#gaf3e10413a429d02d39bde06bd19fa9ab">cy_en_hbdma_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__hb__dma__functions.html#gac0d27f05e71c9f155e6512a62ee4264a">Cy_HBDma_GetSocketStatus</a> (<a class="el" href="group__group__usbfxstack__hb__dma__structs.html#structcy__stc__hbdma__context__t">cy_stc_hbdma_context_t</a> *pContext, <a class="el" href="group__group__usbfxstack__hb__dma__enums.html#gab83411cd9077b5c27dda0bad41d89a06">cy_hbdma_socket_id_t</a> sock_id, <a class="el" href="group__group__usbfxstack__hb__dma__structs.html#structcy__stc__hbdma__sock__t">cy_stc_hbdma_sock_t</a> *sckConf_p)</td></tr>
<tr class="memdesc:gac0d27f05e71c9f155e6512a62ee4264a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read and return the contents of all control and status registers associated with a High BandWidth DMA socket.  <a href="group__group__usbfxstack__hb__dma__functions.html#gac0d27f05e71c9f155e6512a62ee4264a">More...</a><br /></td></tr>
<tr class="separator:gac0d27f05e71c9f155e6512a62ee4264a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga29be73ec0bd34905c36319154a15ec48"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__usbfxstack__hb__dma__enums.html#gaf3e10413a429d02d39bde06bd19fa9ab">cy_en_hbdma_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__hb__dma__functions.html#ga29be73ec0bd34905c36319154a15ec48">Cy_HBDma_SetSocketConfig</a> (<a class="el" href="group__group__usbfxstack__hb__dma__structs.html#structcy__stc__hbdma__context__t">cy_stc_hbdma_context_t</a> *pContext, <a class="el" href="group__group__usbfxstack__hb__dma__enums.html#gab83411cd9077b5c27dda0bad41d89a06">cy_hbdma_socket_id_t</a> sock_id, <a class="el" href="group__group__usbfxstack__hb__dma__structs.html#structcy__stc__hbdma__sockconfig__t">cy_stc_hbdma_sockconfig_t</a> *conf)</td></tr>
<tr class="memdesc:ga29be73ec0bd34905c36319154a15ec48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates the configuration of a HBDma socket with the desired fields from the config structure passed in as parameter.  <a href="group__group__usbfxstack__hb__dma__functions.html#ga29be73ec0bd34905c36319154a15ec48">More...</a><br /></td></tr>
<tr class="separator:ga29be73ec0bd34905c36319154a15ec48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga69c97024a8307c18deb2994d29a7a35c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__usbfxstack__hb__dma__enums.html#gaf3e10413a429d02d39bde06bd19fa9ab">cy_en_hbdma_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__hb__dma__functions.html#ga69c97024a8307c18deb2994d29a7a35c">Cy_HBDma_UpdateSockIntrMask</a> (<a class="el" href="group__group__usbfxstack__hb__dma__structs.html#structcy__stc__hbdma__context__t">cy_stc_hbdma_context_t</a> *pContext, <a class="el" href="group__group__usbfxstack__hb__dma__enums.html#gab83411cd9077b5c27dda0bad41d89a06">cy_hbdma_socket_id_t</a> sock_id, uint32_t intrMap, bool enable)</td></tr>
<tr class="memdesc:ga69c97024a8307c18deb2994d29a7a35c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Special function provided to update only the interrupt mask associated with a HBDma socket.  <a href="group__group__usbfxstack__hb__dma__functions.html#ga69c97024a8307c18deb2994d29a7a35c">More...</a><br /></td></tr>
<tr class="separator:ga69c97024a8307c18deb2994d29a7a35c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga56c84be36a902107ece8bd74b732ea48"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__usbfxstack__hb__dma__enums.html#gaf3e10413a429d02d39bde06bd19fa9ab">cy_en_hbdma_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__hb__dma__functions.html#ga56c84be36a902107ece8bd74b732ea48">Cy_HBDma_SocketEnable</a> (<a class="el" href="group__group__usbfxstack__hb__dma__structs.html#structcy__stc__hbdma__context__t">cy_stc_hbdma_context_t</a> *pContext, <a class="el" href="group__group__usbfxstack__hb__dma__enums.html#gab83411cd9077b5c27dda0bad41d89a06">cy_hbdma_socket_id_t</a> sock_id)</td></tr>
<tr class="memdesc:ga56c84be36a902107ece8bd74b732ea48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to enable a High BandWidth DMA socket after it has been configured using the Cy_HBDma_SetSocketConfig API.  <a href="group__group__usbfxstack__hb__dma__functions.html#ga56c84be36a902107ece8bd74b732ea48">More...</a><br /></td></tr>
<tr class="separator:ga56c84be36a902107ece8bd74b732ea48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga58afb3f835a37db93ecba9a9730bc5f0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__usbfxstack__hb__dma__enums.html#gaf3e10413a429d02d39bde06bd19fa9ab">cy_en_hbdma_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__hb__dma__functions.html#ga58afb3f835a37db93ecba9a9730bc5f0">Cy_HBDma_SocketDisable</a> (<a class="el" href="group__group__usbfxstack__hb__dma__structs.html#structcy__stc__hbdma__context__t">cy_stc_hbdma_context_t</a> *pContext, <a class="el" href="group__group__usbfxstack__hb__dma__enums.html#gab83411cd9077b5c27dda0bad41d89a06">cy_hbdma_socket_id_t</a> sock_id)</td></tr>
<tr class="memdesc:ga58afb3f835a37db93ecba9a9730bc5f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to disable a High BandWidth DMA socket.  <a href="group__group__usbfxstack__hb__dma__functions.html#ga58afb3f835a37db93ecba9a9730bc5f0">More...</a><br /></td></tr>
<tr class="separator:ga58afb3f835a37db93ecba9a9730bc5f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae2c5376dd61d3d97b38ff7453e20841e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__usbfxstack__hb__dma__enums.html#gaf3e10413a429d02d39bde06bd19fa9ab">cy_en_hbdma_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__hb__dma__functions.html#gae2c5376dd61d3d97b38ff7453e20841e">Cy_HBDma_SocketSetWrapUp</a> (<a class="el" href="group__group__usbfxstack__hb__dma__structs.html#structcy__stc__hbdma__context__t">cy_stc_hbdma_context_t</a> *pContext, <a class="el" href="group__group__usbfxstack__hb__dma__enums.html#gab83411cd9077b5c27dda0bad41d89a06">cy_hbdma_socket_id_t</a> sock_id)</td></tr>
<tr class="memdesc:gae2c5376dd61d3d97b38ff7453e20841e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function sets the bit that forces a socket with a partially filled buffer to wrap up the buffer.  <a href="group__group__usbfxstack__hb__dma__functions.html#gae2c5376dd61d3d97b38ff7453e20841e">More...</a><br /></td></tr>
<tr class="separator:gae2c5376dd61d3d97b38ff7453e20841e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5b9f77671bfa7d111a29c6fea7e6d18e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__usbfxstack__hb__dma__enums.html#gaf3e10413a429d02d39bde06bd19fa9ab">cy_en_hbdma_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__hb__dma__functions.html#ga5b9f77671bfa7d111a29c6fea7e6d18e">Cy_HBDma_SendSocketEvent</a> (<a class="el" href="group__group__usbfxstack__hb__dma__structs.html#structcy__stc__hbdma__context__t">cy_stc_hbdma_context_t</a> *pContext, <a class="el" href="group__group__usbfxstack__hb__dma__enums.html#gab83411cd9077b5c27dda0bad41d89a06">cy_hbdma_socket_id_t</a> sock_id, bool isProduceEvent)</td></tr>
<tr class="memdesc:ga5b9f77671bfa7d111a29c6fea7e6d18e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to send an event notification to the specified socket.  <a href="group__group__usbfxstack__hb__dma__functions.html#ga5b9f77671bfa7d111a29c6fea7e6d18e">More...</a><br /></td></tr>
<tr class="separator:ga5b9f77671bfa7d111a29c6fea7e6d18e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5a9a4641d7e532489b3b1938ae89df84"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__usbfxstack__hb__dma__enums.html#gaf3e10413a429d02d39bde06bd19fa9ab">cy_en_hbdma_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__hb__dma__functions.html#ga5a9a4641d7e532489b3b1938ae89df84">Cy_HbDma_ConnectEventTrigger</a> (<a class="el" href="group__group__usbfxstack__hb__dma__structs.html#structcy__stc__hbdma__context__t">cy_stc_hbdma_context_t</a> *pContext, <a class="el" href="group__group__usbfxstack__hb__dma__enums.html#gab83411cd9077b5c27dda0bad41d89a06">cy_hbdma_socket_id_t</a> src_sock, <a class="el" href="group__group__usbfxstack__hb__dma__enums.html#gab83411cd9077b5c27dda0bad41d89a06">cy_hbdma_socket_id_t</a> dst_sock, uint8_t trigNum)</td></tr>
<tr class="memdesc:ga5a9a4641d7e532489b3b1938ae89df84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to connect the event trigger output from one socket to the input of another socket.  <a href="group__group__usbfxstack__hb__dma__functions.html#ga5a9a4641d7e532489b3b1938ae89df84">More...</a><br /></td></tr>
<tr class="separator:ga5a9a4641d7e532489b3b1938ae89df84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1e68c5fa3f5421fdb202358da6257ceb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__usbfxstack__hb__dma__enums.html#gaf3e10413a429d02d39bde06bd19fa9ab">cy_en_hbdma_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__hb__dma__functions.html#ga1e68c5fa3f5421fdb202358da6257ceb">Cy_HbDma_DisconnectEventTriggers</a> (<a class="el" href="group__group__usbfxstack__hb__dma__structs.html#structcy__stc__hbdma__context__t">cy_stc_hbdma_context_t</a> *pContext, <a class="el" href="group__group__usbfxstack__hb__dma__enums.html#gab83411cd9077b5c27dda0bad41d89a06">cy_hbdma_socket_id_t</a> dst_sock)</td></tr>
<tr class="memdesc:ga1e68c5fa3f5421fdb202358da6257ceb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to break all event trigger connections coming to a socket.  <a href="group__group__usbfxstack__hb__dma__functions.html#ga1e68c5fa3f5421fdb202358da6257ceb">More...</a><br /></td></tr>
<tr class="separator:ga1e68c5fa3f5421fdb202358da6257ceb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad7794a4f5fbb7076af32e11a27a3f1a7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__usbfxstack__hb__dma__enums.html#gaf3e10413a429d02d39bde06bd19fa9ab">cy_en_hbdma_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__hb__dma__functions.html#gad7794a4f5fbb7076af32e11a27a3f1a7">Cy_HBDma_HandleInterrupts</a> (<a class="el" href="group__group__usbfxstack__hb__dma__structs.html#structcy__stc__hbdma__context__t">cy_stc_hbdma_context_t</a> *pContext, <a class="el" href="group__group__usbfxstack__hb__dma__enums.html#ga93990ff7fbc856e3f3bfc00a76331509">cy_hbdma_adapter_id_t</a> adapter)</td></tr>
<tr class="memdesc:gad7794a4f5fbb7076af32e11a27a3f1a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function which handles the interrupts generated by any of the sockets associated with a High BandWidth DMA adapter.  <a href="group__group__usbfxstack__hb__dma__functions.html#gad7794a4f5fbb7076af32e11a27a3f1a7">More...</a><br /></td></tr>
<tr class="separator:gad7794a4f5fbb7076af32e11a27a3f1a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacbd71d2e2ced0f0f2bb63cf071083b03"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__usbfxstack__hb__dma__enums.html#gaf3e10413a429d02d39bde06bd19fa9ab">cy_en_hbdma_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__hb__dma__functions.html#gacbd71d2e2ced0f0f2bb63cf071083b03">Cy_HBDma_SetInterruptCallback</a> (<a class="el" href="group__group__usbfxstack__hb__dma__structs.html#structcy__stc__hbdma__context__t">cy_stc_hbdma_context_t</a> *pContext, <a class="el" href="group__group__usbfxstack__hb__dma__typedefs.html#ga85e2868090c71b227b87e0798cd7ccd9">cy_cb_hbdma_intr_callback_t</a> cb_p, void *cbContext)</td></tr>
<tr class="memdesc:gacbd71d2e2ced0f0f2bb63cf071083b03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that registers a callback which can be called the HBDma driver to provide notification of socket interrupts.  <a href="group__group__usbfxstack__hb__dma__functions.html#gacbd71d2e2ced0f0f2bb63cf071083b03">More...</a><br /></td></tr>
<tr class="separator:gacbd71d2e2ced0f0f2bb63cf071083b03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga09649439e2ed09810cd07974539422c0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__hb__dma__functions.html#ga09649439e2ed09810cd07974539422c0">Cy_HBDma_EvictReadCache</a> (bool isCm4Access)</td></tr>
<tr class="memdesc:ga09649439e2ed09810cd07974539422c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evicts the read cache used while masters are using either the Fast AHB bus (Cortex-M4) or the Slow AHB bus (Cortex-M0+, DataWire, DMAC or Crypto) to read content from the High BandWidth RAM area.  <a href="group__group__usbfxstack__hb__dma__functions.html#ga09649439e2ed09810cd07974539422c0">More...</a><br /></td></tr>
<tr class="separator:ga09649439e2ed09810cd07974539422c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga025adad5e435a2465dd8c5c86af2489b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__usbfxstack__hb__dma__enums.html#gaf3e10413a429d02d39bde06bd19fa9ab">cy_en_hbdma_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__hb__dma__functions.html#ga025adad5e435a2465dd8c5c86af2489b">Cy_HBDma_SetClockFrequency</a> (<a class="el" href="group__group__usbfxstack__hb__dma__enums.html#gaf07a15620aa6ac9a13b4fffef4cf6a8c">cy_en_hbdma_clk_freq_t</a> dmaFreq)</td></tr>
<tr class="memdesc:ga025adad5e435a2465dd8c5c86af2489b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the high bandwidth DMA clock frequency to the desired value.  <a href="group__group__usbfxstack__hb__dma__functions.html#ga025adad5e435a2465dd8c5c86af2489b">More...</a><br /></td></tr>
<tr class="separator:ga025adad5e435a2465dd8c5c86af2489b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4865c480ade86e0b79f4ef2160ed3164"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__hb__dma__functions.html#ga4865c480ade86e0b79f4ef2160ed3164">Cy_HBDma_Is64KBufferEnabled</a> (<a class="el" href="group__group__usbfxstack__hb__dma__structs.html#structcy__stc__hbdma__context__t">cy_stc_hbdma_context_t</a> *pDrvContext)</td></tr>
<tr class="memdesc:ga4865c480ade86e0b79f4ef2160ed3164"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether 64KB DMA buffer support is enabled on the device.  <a href="group__group__usbfxstack__hb__dma__functions.html#ga4865c480ade86e0b79f4ef2160ed3164">More...</a><br /></td></tr>
<tr class="separator:ga4865c480ade86e0b79f4ef2160ed3164"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab7ff1ea9bf263cf80645fed9e0b1edcd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__hb__dma__functions.html#gab7ff1ea9bf263cf80645fed9e0b1edcd">Cy_HBDma_SetUsbEgressAdapterDelay</a> (<a class="el" href="group__group__usbfxstack__hb__dma__structs.html#structcy__stc__hbdma__context__t">cy_stc_hbdma_context_t</a> *pDrvContext, uint8_t gblDelayCycles)</td></tr>
<tr class="memdesc:gab7ff1ea9bf263cf80645fed9e0b1edcd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the number of cycles of delay to be applied between consecutive AXI data fetches made by the USB egress DMA adapter.  <a href="group__group__usbfxstack__hb__dma__functions.html#gab7ff1ea9bf263cf80645fed9e0b1edcd">More...</a><br /></td></tr>
<tr class="separator:gab7ff1ea9bf263cf80645fed9e0b1edcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5054870fc1b7e19a70b052d876b8c451"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__hb__dma__functions.html#ga5054870fc1b7e19a70b052d876b8c451">Cy_HBDma_SetLvdsAdapterIngressMode</a> (<a class="el" href="group__group__usbfxstack__hb__dma__structs.html#structcy__stc__hbdma__context__t">cy_stc_hbdma_context_t</a> *pDrvContext, bool isAdap0Ingress, bool isAdap1Ingress)</td></tr>
<tr class="memdesc:ga5054870fc1b7e19a70b052d876b8c451"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function enables or disables the support for egress data transfers from RAM buffers which are not 16-byte aligned based on whether the specified LVDS DMA adapters are working in Ingress only mode or not.  <a href="group__group__usbfxstack__hb__dma__functions.html#ga5054870fc1b7e19a70b052d876b8c451">More...</a><br /></td></tr>
<tr class="separator:ga5054870fc1b7e19a70b052d876b8c451"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga73c1b44eee45847690e71a9f4dbf9fa7"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__hb__dma__functions.html#ga73c1b44eee45847690e71a9f4dbf9fa7">Cy_HBDma_Mgr_GetVersion</a> (void)</td></tr>
<tr class="memdesc:ga73c1b44eee45847690e71a9f4dbf9fa7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the High BandWidth Manager Middleware version information in the form of a 32-bit word including the major, minor, patch and build numbers.  <a href="group__group__usbfxstack__hb__dma__functions.html#ga73c1b44eee45847690e71a9f4dbf9fa7">More...</a><br /></td></tr>
<tr class="separator:ga73c1b44eee45847690e71a9f4dbf9fa7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0270a0db7487599f2e8cf8c6bf505251"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__usbfxstack__hb__dma__enums.html#ga8a1d453b60acfddb9766af3ad7c2ddaa">cy_en_hbdma_mgr_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__hb__dma__functions.html#ga0270a0db7487599f2e8cf8c6bf505251">Cy_HBDma_DscrList_Create</a> (<a class="el" href="group__group__usbfxstack__hb__dma__structs.html#structcy__stc__hbdma__dscr__list__t">cy_stc_hbdma_dscr_list_t</a> *list_p, uint16_t maxDscrCount)</td></tr>
<tr class="memdesc:ga0270a0db7487599f2e8cf8c6bf505251"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the allocator used to manage High BandWidth DMA descriptors.  <a href="group__group__usbfxstack__hb__dma__functions.html#ga0270a0db7487599f2e8cf8c6bf505251">More...</a><br /></td></tr>
<tr class="separator:ga0270a0db7487599f2e8cf8c6bf505251"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad54594cfbaee3daf93a076fc68b9f00d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__usbfxstack__hb__dma__enums.html#ga8a1d453b60acfddb9766af3ad7c2ddaa">cy_en_hbdma_mgr_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__hb__dma__functions.html#gad54594cfbaee3daf93a076fc68b9f00d">Cy_HBDma_DscrList_Destroy</a> (<a class="el" href="group__group__usbfxstack__hb__dma__structs.html#structcy__stc__hbdma__dscr__list__t">cy_stc_hbdma_dscr_list_t</a> *list_p)</td></tr>
<tr class="memdesc:gad54594cfbaee3daf93a076fc68b9f00d"><td class="mdescLeft">&#160;</td><td class="mdescRight">De-initialize the allocator used to manage High BandWidth DMA descriptors.  <a href="group__group__usbfxstack__hb__dma__functions.html#gad54594cfbaee3daf93a076fc68b9f00d">More...</a><br /></td></tr>
<tr class="separator:gad54594cfbaee3daf93a076fc68b9f00d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabb860ae2a4d79c507239da5ab41fec0e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__usbfxstack__hb__dma__enums.html#ga8a1d453b60acfddb9766af3ad7c2ddaa">cy_en_hbdma_mgr_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__hb__dma__functions.html#gabb860ae2a4d79c507239da5ab41fec0e">Cy_HBDma_DscrList_Get</a> (<a class="el" href="group__group__usbfxstack__hb__dma__structs.html#structcy__stc__hbdma__dscr__list__t">cy_stc_hbdma_dscr_list_t</a> *list_p, uint16_t *dscrIndex_p)</td></tr>
<tr class="memdesc:gabb860ae2a4d79c507239da5ab41fec0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain a free HBW DMA descriptor from the free list.  <a href="group__group__usbfxstack__hb__dma__functions.html#gabb860ae2a4d79c507239da5ab41fec0e">More...</a><br /></td></tr>
<tr class="separator:gabb860ae2a4d79c507239da5ab41fec0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaff76d81c20945a5b223775955485e44"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__usbfxstack__hb__dma__enums.html#ga8a1d453b60acfddb9766af3ad7c2ddaa">cy_en_hbdma_mgr_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__hb__dma__functions.html#gaaff76d81c20945a5b223775955485e44">Cy_HBDma_DscrList_Put</a> (<a class="el" href="group__group__usbfxstack__hb__dma__structs.html#structcy__stc__hbdma__dscr__list__t">cy_stc_hbdma_dscr_list_t</a> *list_p, uint16_t dscrIndex)</td></tr>
<tr class="memdesc:gaaff76d81c20945a5b223775955485e44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Release a HBW DMA descriptor back to the free list.  <a href="group__group__usbfxstack__hb__dma__functions.html#gaaff76d81c20945a5b223775955485e44">More...</a><br /></td></tr>
<tr class="separator:gaaff76d81c20945a5b223775955485e44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga55d68477b4bbc31bd66832453295487a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__usbfxstack__hb__dma__enums.html#ga8a1d453b60acfddb9766af3ad7c2ddaa">cy_en_hbdma_mgr_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__hb__dma__functions.html#ga55d68477b4bbc31bd66832453295487a">Cy_HBDma_BufMgr_Create</a> (<a class="el" href="group__group__usbfxstack__hb__dma__structs.html#structcy__stc__hbdma__buf__mgr__t">cy_stc_hbdma_buf_mgr_t</a> *mgr_p, uint32_t *baseAddr, uint32_t regionSize)</td></tr>
<tr class="memdesc:ga55d68477b4bbc31bd66832453295487a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function initializes the custom heap used for DMA buffer allocation.  <a href="group__group__usbfxstack__hb__dma__functions.html#ga55d68477b4bbc31bd66832453295487a">More...</a><br /></td></tr>
<tr class="separator:ga55d68477b4bbc31bd66832453295487a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga972d84b73265cd460f4116a875572144"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__usbfxstack__hb__dma__enums.html#ga8a1d453b60acfddb9766af3ad7c2ddaa">cy_en_hbdma_mgr_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__hb__dma__functions.html#ga972d84b73265cd460f4116a875572144">Cy_HBDma_BufMgr_Destroy</a> (<a class="el" href="group__group__usbfxstack__hb__dma__structs.html#structcy__stc__hbdma__buf__mgr__t">cy_stc_hbdma_buf_mgr_t</a> *mgr_p, bool freeAll)</td></tr>
<tr class="memdesc:ga972d84b73265cd460f4116a875572144"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function frees up the custom heap used for DMA buffer allocation.  <a href="group__group__usbfxstack__hb__dma__functions.html#ga972d84b73265cd460f4116a875572144">More...</a><br /></td></tr>
<tr class="separator:ga972d84b73265cd460f4116a875572144"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga53fb59b7fff1e3f32106cce3dfe91bee"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__hb__dma__functions.html#ga53fb59b7fff1e3f32106cce3dfe91bee">Cy_HBDma_BufMgr_Alloc</a> (<a class="el" href="group__group__usbfxstack__hb__dma__structs.html#structcy__stc__hbdma__buf__mgr__t">cy_stc_hbdma_buf_mgr_t</a> *mgr_p, uint32_t bufferSize)</td></tr>
<tr class="memdesc:ga53fb59b7fff1e3f32106cce3dfe91bee"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function allocates memory required for DMA buffers required by the firmware application.  <a href="group__group__usbfxstack__hb__dma__functions.html#ga53fb59b7fff1e3f32106cce3dfe91bee">More...</a><br /></td></tr>
<tr class="separator:ga53fb59b7fff1e3f32106cce3dfe91bee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga73272ac6afd3e262859e0651fc870eba"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__usbfxstack__hb__dma__enums.html#ga8a1d453b60acfddb9766af3ad7c2ddaa">cy_en_hbdma_mgr_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__hb__dma__functions.html#ga73272ac6afd3e262859e0651fc870eba">Cy_HBDma_BufMgr_Free</a> (<a class="el" href="group__group__usbfxstack__hb__dma__structs.html#structcy__stc__hbdma__buf__mgr__t">cy_stc_hbdma_buf_mgr_t</a> *mgr_p, void *buffer_p)</td></tr>
<tr class="memdesc:ga73272ac6afd3e262859e0651fc870eba"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function frees memory which was previously allocated using Cy_HBDma_BufMgr_Alloc.  <a href="group__group__usbfxstack__hb__dma__functions.html#ga73272ac6afd3e262859e0651fc870eba">More...</a><br /></td></tr>
<tr class="separator:ga73272ac6afd3e262859e0651fc870eba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7b048031a2c4a5598791278aa6362ba2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__usbfxstack__hb__dma__enums.html#ga8a1d453b60acfddb9766af3ad7c2ddaa">cy_en_hbdma_mgr_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__hb__dma__functions.html#ga7b048031a2c4a5598791278aa6362ba2">Cy_HBDma_Mgr_Init</a> (<a class="el" href="group__group__usbfxstack__hb__dma__structs.html#structcy__stc__hbdma__mgr__context__t">cy_stc_hbdma_mgr_context_t</a> *context_p, <a class="el" href="group__group__usbfxstack__hb__dma__structs.html#structcy__stc__hbdma__context__t">cy_stc_hbdma_context_t</a> *drvContext_p, <a class="el" href="group__group__usbfxstack__hb__dma__structs.html#structcy__stc__hbdma__dscr__list__t">cy_stc_hbdma_dscr_list_t</a> *dscrPool_p, <a class="el" href="group__group__usbfxstack__hb__dma__structs.html#structcy__stc__hbdma__buf__mgr__t">cy_stc_hbdma_buf_mgr_t</a> *bufMgr_p)</td></tr>
<tr class="memdesc:ga7b048031a2c4a5598791278aa6362ba2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the High BandWidth DMA manager library.  <a href="group__group__usbfxstack__hb__dma__functions.html#ga7b048031a2c4a5598791278aa6362ba2">More...</a><br /></td></tr>
<tr class="separator:ga7b048031a2c4a5598791278aa6362ba2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab4961fcbc111e04c9af83e40fd1c983f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__usbfxstack__hb__dma__enums.html#ga8a1d453b60acfddb9766af3ad7c2ddaa">cy_en_hbdma_mgr_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__hb__dma__functions.html#gab4961fcbc111e04c9af83e40fd1c983f">Cy_HBDma_Mgr_DeInit</a> (<a class="el" href="group__group__usbfxstack__hb__dma__structs.html#structcy__stc__hbdma__mgr__context__t">cy_stc_hbdma_mgr_context_t</a> *context_p)</td></tr>
<tr class="memdesc:gab4961fcbc111e04c9af83e40fd1c983f"><td class="mdescLeft">&#160;</td><td class="mdescRight">De-initialize the High BandWidth DMA manager library.  <a href="group__group__usbfxstack__hb__dma__functions.html#gab4961fcbc111e04c9af83e40fd1c983f">More...</a><br /></td></tr>
<tr class="separator:gab4961fcbc111e04c9af83e40fd1c983f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga51a42ea3fc4527e840654eb2a0dc5fcd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__hb__dma__functions.html#ga51a42ea3fc4527e840654eb2a0dc5fcd">Cy_HBDma_Mgr_RegisterUsbContext</a> (<a class="el" href="group__group__usbfxstack__hb__dma__structs.html#structcy__stc__hbdma__mgr__context__t">cy_stc_hbdma_mgr_context_t</a> *context_p, void *pUsbStackCtx)</td></tr>
<tr class="memdesc:ga51a42ea3fc4527e840654eb2a0dc5fcd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register the USB stack context pointer with the High BandWidth manager.  <a href="group__group__usbfxstack__hb__dma__functions.html#ga51a42ea3fc4527e840654eb2a0dc5fcd">More...</a><br /></td></tr>
<tr class="separator:ga51a42ea3fc4527e840654eb2a0dc5fcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa8a5b3b3e0cde64db51870a4d1d6e9d8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__usbfxstack__hb__dma__enums.html#ga8a1d453b60acfddb9766af3ad7c2ddaa">cy_en_hbdma_mgr_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__hb__dma__functions.html#gaa8a5b3b3e0cde64db51870a4d1d6e9d8">Cy_HBDma_Mgr_UpdateMultEn</a> (<a class="el" href="group__group__usbfxstack__hb__dma__structs.html#structcy__stc__hbdma__mgr__context__t">cy_stc_hbdma_mgr_context_t</a> *pContext, uint32_t endpNumber, bool isEgressEp, bool multEnable)</td></tr>
<tr class="memdesc:gaa8a5b3b3e0cde64db51870a4d1d6e9d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the MULT setting for sockets associated with USB endpoints.  <a href="group__group__usbfxstack__hb__dma__functions.html#gaa8a5b3b3e0cde64db51870a4d1d6e9d8">More...</a><br /></td></tr>
<tr class="separator:gaa8a5b3b3e0cde64db51870a4d1d6e9d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa82429d7fa2c2e991eceb96bc9ec8668"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__usbfxstack__hb__dma__enums.html#ga8a1d453b60acfddb9766af3ad7c2ddaa">cy_en_hbdma_mgr_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__hb__dma__functions.html#gaa82429d7fa2c2e991eceb96bc9ec8668">Cy_HBDma_Channel_Create</a> (<a class="el" href="group__group__usbfxstack__hb__dma__structs.html#structcy__stc__hbdma__mgr__context__t">cy_stc_hbdma_mgr_context_t</a> *pDmaMgr, <a class="el" href="group__group__usbfxstack__hb__dma__structs.html#structcy__stc__hbdma__channel__t">cy_stc_hbdma_channel_t</a> *handle, <a class="el" href="group__group__usbfxstack__hb__dma__structs.html#structcy__stc__hbdma__chn__config__t">cy_stc_hbdma_chn_config_t</a> *config)</td></tr>
<tr class="memdesc:gaa82429d7fa2c2e991eceb96bc9ec8668"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a High BandWidth DMA channel based on the parameters specified in the config structure.  <a href="group__group__usbfxstack__hb__dma__functions.html#gaa82429d7fa2c2e991eceb96bc9ec8668">More...</a><br /></td></tr>
<tr class="separator:gaa82429d7fa2c2e991eceb96bc9ec8668"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0d36ce61ee1a513773f7e6c964c5cab9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__usbfxstack__hb__dma__enums.html#ga8a1d453b60acfddb9766af3ad7c2ddaa">cy_en_hbdma_mgr_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__hb__dma__functions.html#ga0d36ce61ee1a513773f7e6c964c5cab9">Cy_HBDma_Channel_Destroy</a> (<a class="el" href="group__group__usbfxstack__hb__dma__structs.html#structcy__stc__hbdma__channel__t">cy_stc_hbdma_channel_t</a> *handle)</td></tr>
<tr class="memdesc:ga0d36ce61ee1a513773f7e6c964c5cab9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy a High BandWidth DMA channel.  <a href="group__group__usbfxstack__hb__dma__functions.html#ga0d36ce61ee1a513773f7e6c964c5cab9">More...</a><br /></td></tr>
<tr class="separator:ga0d36ce61ee1a513773f7e6c964c5cab9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8d726d57b772a75adb666f1c082be8ed"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__usbfxstack__hb__dma__enums.html#ga8a1d453b60acfddb9766af3ad7c2ddaa">cy_en_hbdma_mgr_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__hb__dma__functions.html#ga8d726d57b772a75adb666f1c082be8ed">Cy_HBDma_Channel_Enable</a> (<a class="el" href="group__group__usbfxstack__hb__dma__structs.html#structcy__stc__hbdma__channel__t">cy_stc_hbdma_channel_t</a> *handle, uint32_t xferSize)</td></tr>
<tr class="memdesc:ga8d726d57b772a75adb666f1c082be8ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable a High BandWidth DMA channel for data transfer.  <a href="group__group__usbfxstack__hb__dma__functions.html#ga8d726d57b772a75adb666f1c082be8ed">More...</a><br /></td></tr>
<tr class="separator:ga8d726d57b772a75adb666f1c082be8ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga651b4f103e80a7bad7136db793dae675"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__usbfxstack__hb__dma__enums.html#ga8a1d453b60acfddb9766af3ad7c2ddaa">cy_en_hbdma_mgr_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__hb__dma__functions.html#ga651b4f103e80a7bad7136db793dae675">Cy_HBDma_Channel_Disable</a> (<a class="el" href="group__group__usbfxstack__hb__dma__structs.html#structcy__stc__hbdma__channel__t">cy_stc_hbdma_channel_t</a> *handle)</td></tr>
<tr class="memdesc:ga651b4f103e80a7bad7136db793dae675"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable a High BandWidth DMA channel.  <a href="group__group__usbfxstack__hb__dma__functions.html#ga651b4f103e80a7bad7136db793dae675">More...</a><br /></td></tr>
<tr class="separator:ga651b4f103e80a7bad7136db793dae675"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac255726795e25981414fda4901d21857"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__usbfxstack__hb__dma__enums.html#ga8a1d453b60acfddb9766af3ad7c2ddaa">cy_en_hbdma_mgr_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__hb__dma__functions.html#gac255726795e25981414fda4901d21857">Cy_HBDma_Channel_Reset</a> (<a class="el" href="group__group__usbfxstack__hb__dma__structs.html#structcy__stc__hbdma__channel__t">cy_stc_hbdma_channel_t</a> *handle)</td></tr>
<tr class="memdesc:gac255726795e25981414fda4901d21857"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset a High BandWidth DMA channel.  <a href="group__group__usbfxstack__hb__dma__functions.html#gac255726795e25981414fda4901d21857">More...</a><br /></td></tr>
<tr class="separator:gac255726795e25981414fda4901d21857"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae37cf3b7af8526e834a0f6a6457090d8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__usbfxstack__hb__dma__enums.html#ga8a1d453b60acfddb9766af3ad7c2ddaa">cy_en_hbdma_mgr_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__hb__dma__functions.html#gae37cf3b7af8526e834a0f6a6457090d8">Cy_HBDma_Channel_SetWrapUp</a> (<a class="el" href="group__group__usbfxstack__hb__dma__structs.html#structcy__stc__hbdma__channel__t">cy_stc_hbdma_channel_t</a> *pHandle, uint8_t sckOffset)</td></tr>
<tr class="memdesc:gae37cf3b7af8526e834a0f6a6457090d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API is used to forcibly commit a DMA buffer to the consumer, and is useful in the case where data transfer has abruptly stopped without the producer being able to commit the data buffer.  <a href="group__group__usbfxstack__hb__dma__functions.html#gae37cf3b7af8526e834a0f6a6457090d8">More...</a><br /></td></tr>
<tr class="separator:gae37cf3b7af8526e834a0f6a6457090d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacdec948100f14eef4ca783584a4afbcc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__usbfxstack__hb__dma__enums.html#ga8a1d453b60acfddb9766af3ad7c2ddaa">cy_en_hbdma_mgr_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__hb__dma__functions.html#gacdec948100f14eef4ca783584a4afbcc">Cy_HBDma_Channel_GetBuffer</a> (<a class="el" href="group__group__usbfxstack__hb__dma__structs.html#structcy__stc__hbdma__channel__t">cy_stc_hbdma_channel_t</a> *handle, <a class="el" href="group__group__usbfxstack__hb__dma__structs.html#structcy__stc__hbdma__buff__status__t">cy_stc_hbdma_buff_status_t</a> *bufStat_p)</td></tr>
<tr class="memdesc:gacdec948100f14eef4ca783584a4afbcc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the status of the active DMA buffer associated with the DMA channel.  <a href="group__group__usbfxstack__hb__dma__functions.html#gacdec948100f14eef4ca783584a4afbcc">More...</a><br /></td></tr>
<tr class="separator:gacdec948100f14eef4ca783584a4afbcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab7e186254f83c498e9ad4de42c61dde0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__usbfxstack__hb__dma__enums.html#ga8a1d453b60acfddb9766af3ad7c2ddaa">cy_en_hbdma_mgr_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__hb__dma__functions.html#gab7e186254f83c498e9ad4de42c61dde0">Cy_HBDma_Channel_CommitBuffer</a> (<a class="el" href="group__group__usbfxstack__hb__dma__structs.html#structcy__stc__hbdma__channel__t">cy_stc_hbdma_channel_t</a> *handle, <a class="el" href="group__group__usbfxstack__hb__dma__structs.html#structcy__stc__hbdma__buff__status__t">cy_stc_hbdma_buff_status_t</a> *bufStat_p)</td></tr>
<tr class="memdesc:gab7e186254f83c498e9ad4de42c61dde0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark a DMA buffer occupied on the consumer side of the DMA channel.  <a href="group__group__usbfxstack__hb__dma__functions.html#gab7e186254f83c498e9ad4de42c61dde0">More...</a><br /></td></tr>
<tr class="separator:gab7e186254f83c498e9ad4de42c61dde0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga36d9f9a1a77bd366da57f1bcf76e0c32"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__usbfxstack__hb__dma__enums.html#ga8a1d453b60acfddb9766af3ad7c2ddaa">cy_en_hbdma_mgr_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__hb__dma__functions.html#ga36d9f9a1a77bd366da57f1bcf76e0c32">Cy_HBDma_Channel_DiscardBuffer</a> (<a class="el" href="group__group__usbfxstack__hb__dma__structs.html#structcy__stc__hbdma__channel__t">cy_stc_hbdma_channel_t</a> *handle, <a class="el" href="group__group__usbfxstack__hb__dma__structs.html#structcy__stc__hbdma__buff__status__t">cy_stc_hbdma_buff_status_t</a> *bufStat_p)</td></tr>
<tr class="memdesc:ga36d9f9a1a77bd366da57f1bcf76e0c32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark a DMA buffer empty on the producer side of the DMA channel.  <a href="group__group__usbfxstack__hb__dma__functions.html#ga36d9f9a1a77bd366da57f1bcf76e0c32">More...</a><br /></td></tr>
<tr class="separator:ga36d9f9a1a77bd366da57f1bcf76e0c32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga024377611ec57ace8d8f04222e755bdd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__usbfxstack__hb__dma__enums.html#ga8a1d453b60acfddb9766af3ad7c2ddaa">cy_en_hbdma_mgr_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__hb__dma__functions.html#ga024377611ec57ace8d8f04222e755bdd">Cy_HBDma_Channel_SendData</a> (<a class="el" href="group__group__usbfxstack__hb__dma__structs.html#structcy__stc__hbdma__channel__t">cy_stc_hbdma_channel_t</a> *handle, uint16_t sckIdx, uint8_t *dataBuf_p, uint32_t dataSize)</td></tr>
<tr class="memdesc:ga024377611ec57ace8d8f04222e755bdd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prepares to send data through a DMA channel.  <a href="group__group__usbfxstack__hb__dma__functions.html#ga024377611ec57ace8d8f04222e755bdd">More...</a><br /></td></tr>
<tr class="separator:ga024377611ec57ace8d8f04222e755bdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga959f1cb234b881a73a69ddf525b3fe23"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__usbfxstack__hb__dma__enums.html#ga8a1d453b60acfddb9766af3ad7c2ddaa">cy_en_hbdma_mgr_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__hb__dma__functions.html#ga959f1cb234b881a73a69ddf525b3fe23">Cy_HBDma_Channel_WaitForSendCplt</a> (<a class="el" href="group__group__usbfxstack__hb__dma__structs.html#structcy__stc__hbdma__channel__t">cy_stc_hbdma_channel_t</a> *handle, uint16_t sckIdx)</td></tr>
<tr class="memdesc:ga959f1cb234b881a73a69ddf525b3fe23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Waits until the DMA transfer requested using Cy_HBDma_Channel_SendData API has been completed.  <a href="group__group__usbfxstack__hb__dma__functions.html#ga959f1cb234b881a73a69ddf525b3fe23">More...</a><br /></td></tr>
<tr class="separator:ga959f1cb234b881a73a69ddf525b3fe23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8c11132ed6ff40bd7509be86f65a3365"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__usbfxstack__hb__dma__enums.html#ga8a1d453b60acfddb9766af3ad7c2ddaa">cy_en_hbdma_mgr_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__hb__dma__functions.html#ga8c11132ed6ff40bd7509be86f65a3365">Cy_HBDma_Channel_ReceiveData</a> (<a class="el" href="group__group__usbfxstack__hb__dma__structs.html#structcy__stc__hbdma__channel__t">cy_stc_hbdma_channel_t</a> *handle, uint16_t sckIdx, uint8_t *dataBuf_p, uint32_t bufferSize, uint32_t *actualSize_p)</td></tr>
<tr class="memdesc:ga8c11132ed6ff40bd7509be86f65a3365"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prepare to receive a specific amount of data using a DMA channel.  <a href="group__group__usbfxstack__hb__dma__functions.html#ga8c11132ed6ff40bd7509be86f65a3365">More...</a><br /></td></tr>
<tr class="separator:ga8c11132ed6ff40bd7509be86f65a3365"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab3c7d15c4b19f769cfea45cd4c324163"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__usbfxstack__hb__dma__enums.html#ga8a1d453b60acfddb9766af3ad7c2ddaa">cy_en_hbdma_mgr_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__hb__dma__functions.html#gab3c7d15c4b19f769cfea45cd4c324163">Cy_HBDma_Channel_WaitForReceiveCplt</a> (<a class="el" href="group__group__usbfxstack__hb__dma__structs.html#structcy__stc__hbdma__channel__t">cy_stc_hbdma_channel_t</a> *handle, uint16_t sckIdx, uint32_t *actualSize_p)</td></tr>
<tr class="memdesc:gab3c7d15c4b19f769cfea45cd4c324163"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait until a HBW DMA operation initiated using Cy_HBDma_Channel_ReceiveData has been completed.  <a href="group__group__usbfxstack__hb__dma__functions.html#gab3c7d15c4b19f769cfea45cd4c324163">More...</a><br /></td></tr>
<tr class="separator:gab3c7d15c4b19f769cfea45cd4c324163"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga56a61ec4d579c09f43a7127961e3c121"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__usbfxstack__hb__dma__enums.html#ga8a1d453b60acfddb9766af3ad7c2ddaa">cy_en_hbdma_mgr_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__hb__dma__functions.html#ga56a61ec4d579c09f43a7127961e3c121">Cy_HBDma_Channel_GetBufferInfo</a> (<a class="el" href="group__group__usbfxstack__hb__dma__structs.html#structcy__stc__hbdma__channel__t">cy_stc_hbdma_channel_t</a> *pHandle, uint8_t **pBufPtrs, uint8_t bufferCnt)</td></tr>
<tr class="memdesc:ga56a61ec4d579c09f43a7127961e3c121"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the set of DMA buffers associated with a HBDma channel.  <a href="group__group__usbfxstack__hb__dma__functions.html#ga56a61ec4d579c09f43a7127961e3c121">More...</a><br /></td></tr>
<tr class="separator:ga56a61ec4d579c09f43a7127961e3c121"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga41d83f4793be18a2879f9a4d05454e98"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__usbfxstack__hb__dma__enums.html#ga8a1d453b60acfddb9766af3ad7c2ddaa">cy_en_hbdma_mgr_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__hb__dma__functions.html#ga41d83f4793be18a2879f9a4d05454e98">Cy_HBDma_Channel_AutoDropData</a> (<a class="el" href="group__group__usbfxstack__hb__dma__structs.html#structcy__stc__hbdma__channel__t">cy_stc_hbdma_channel_t</a> *pHandle)</td></tr>
<tr class="memdesc:ga41d83f4793be18a2879f9a4d05454e98"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function allows an active Auto DMA channel to be configured to drop all data that is being received on the producer side.  <a href="group__group__usbfxstack__hb__dma__functions.html#ga41d83f4793be18a2879f9a4d05454e98">More...</a><br /></td></tr>
<tr class="separator:ga41d83f4793be18a2879f9a4d05454e98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2e16f6d9d7ae6fd777e8b72ade3f50cd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__hb__dma__functions.html#ga2e16f6d9d7ae6fd777e8b72ade3f50cd">Cy_HBDma_Channel_Cb</a> (<a class="el" href="group__group__usbfxstack__hb__dma__enums.html#gab83411cd9077b5c27dda0bad41d89a06">cy_hbdma_socket_id_t</a> socketId, <a class="el" href="group__group__usbfxstack__hb__dma__enums.html#ga9fa6002eb355bdec4f739851bac4590a">cy_en_hbdma_sock_evt_t</a> intrType, uint32_t curDscr, void *userCtx)</td></tr>
<tr class="memdesc:ga2e16f6d9d7ae6fd777e8b72ade3f50cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">High BandWidth DMA channel callback function implementation.  <a href="group__group__usbfxstack__hb__dma__functions.html#ga2e16f6d9d7ae6fd777e8b72ade3f50cd">More...</a><br /></td></tr>
<tr class="separator:ga2e16f6d9d7ae6fd777e8b72ade3f50cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf0c60cfe5c5ca8ceedf96d38d2ff258d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__hb__dma__functions.html#gaf0c60cfe5c5ca8ceedf96d38d2ff258d">Cy_HBDma_Mgr_TaskHandler</a> (void *pTaskParam)</td></tr>
<tr class="memdesc:gaf0c60cfe5c5ca8ceedf96d38d2ff258d"><td class="mdescLeft">&#160;</td><td class="mdescRight">High BandWidth DMA manager task.  <a href="group__group__usbfxstack__hb__dma__functions.html#gaf0c60cfe5c5ca8ceedf96d38d2ff258d">More...</a><br /></td></tr>
<tr class="separator:gaf0c60cfe5c5ca8ceedf96d38d2ff258d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab693e55b497981a5cefa84973457088d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__hb__dma__functions.html#gab693e55b497981a5cefa84973457088d">Cy_HBDma_Mgr_RegisterISRCtrlCallback</a> (<a class="el" href="group__group__usbfxstack__hb__dma__structs.html#structcy__stc__hbdma__mgr__context__t">cy_stc_hbdma_mgr_context_t</a> *pDmaMgr, <a class="el" href="group__group__usbfxstack__hb__dma__typedefs.html#gaf82cec3d6d5f7b17e52508a08794b34f">cy_cb_hbdma_mgr_intr_ctrl_cb_t</a> cb)</td></tr>
<tr class="memdesc:gab693e55b497981a5cefa84973457088d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a function callback that the DMA manager can call to dynamically enable or disable the HBDMA interrupts based on the state of the interrupt notification message queue.  <a href="group__group__usbfxstack__hb__dma__functions.html#gab693e55b497981a5cefa84973457088d">More...</a><br /></td></tr>
<tr class="separator:gab693e55b497981a5cefa84973457088d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6999b46a26a52114850ff548a989506b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__usbfxstack__hb__dma__enums.html#ga5e9d5386a585e87f3d3a0991ff321c7f">cy_en_hbdma_chn_state_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__hb__dma__functions.html#ga6999b46a26a52114850ff548a989506b">Cy_HBDma_Channel_GetChannelState</a> (<a class="el" href="group__group__usbfxstack__hb__dma__structs.html#structcy__stc__hbdma__channel__t">cy_stc_hbdma_channel_t</a> *pHandle)</td></tr>
<tr class="memdesc:ga6999b46a26a52114850ff548a989506b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the state of DMA channel.  <a href="group__group__usbfxstack__hb__dma__functions.html#ga6999b46a26a52114850ff548a989506b">More...</a><br /></td></tr>
<tr class="separator:ga6999b46a26a52114850ff548a989506b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa54235631fbe7834dc902810a619a292"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__hb__dma__functions.html#gaa54235631fbe7834dc902810a619a292">Cy_HBDma_Mgr_DmaCallbackConfigure</a> (<a class="el" href="group__group__usbfxstack__hb__dma__structs.html#structcy__stc__hbdma__mgr__context__t">cy_stc_hbdma_mgr_context_t</a> *pDmaMgr, bool callbackFromISREnable)</td></tr>
<tr class="memdesc:gaa54235631fbe7834dc902810a619a292"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to configure context from which DMA callback functions are generated.  <a href="group__group__usbfxstack__hb__dma__functions.html#gaa54235631fbe7834dc902810a619a292">More...</a><br /></td></tr>
<tr class="separator:gaa54235631fbe7834dc902810a619a292"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga580bac11a3a9eb4d2580d3c242fcf497"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__hb__dma__functions.html#ga580bac11a3a9eb4d2580d3c242fcf497">Cy_HBDma_Mgr_GetIntrDropCount</a> (<a class="el" href="group__group__usbfxstack__hb__dma__structs.html#structcy__stc__hbdma__mgr__context__t">cy_stc_hbdma_mgr_context_t</a> *pDmaMgr)</td></tr>
<tr class="memdesc:ga580bac11a3a9eb4d2580d3c242fcf497"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to get count of DMA interrupt messages dropped due to message queue overflow.  <a href="group__group__usbfxstack__hb__dma__functions.html#ga580bac11a3a9eb4d2580d3c242fcf497">More...</a><br /></td></tr>
<tr class="separator:ga580bac11a3a9eb4d2580d3c242fcf497"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacc1cb4929f6b9a4002de6498e31ef1ca"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__hb__dma__functions.html#gacc1cb4929f6b9a4002de6498e31ef1ca">Cy_HBDma_Mgr_SetUsbEgressAdapterDelay</a> (<a class="el" href="group__group__usbfxstack__hb__dma__structs.html#structcy__stc__hbdma__mgr__context__t">cy_stc_hbdma_mgr_context_t</a> *pDmaMgr, uint8_t gblDelayCycles)</td></tr>
<tr class="memdesc:gacc1cb4929f6b9a4002de6498e31ef1ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the number of cycles of delay to be applied between consecutive AXI data fetches made by the USB egress DMA adapter.  <a href="group__group__usbfxstack__hb__dma__functions.html#gacc1cb4929f6b9a4002de6498e31ef1ca">More...</a><br /></td></tr>
<tr class="separator:gacc1cb4929f6b9a4002de6498e31ef1ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadf9f54714f6cd6888ca8947d9968ee33"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__hb__dma__functions.html#gadf9f54714f6cd6888ca8947d9968ee33">Cy_HBDma_Mgr_SetLvdsAdapterIngressMode</a> (<a class="el" href="group__group__usbfxstack__hb__dma__structs.html#structcy__stc__hbdma__mgr__context__t">cy_stc_hbdma_mgr_context_t</a> *pDmaMgr, bool isAdap0Ingress, bool isAdap1Ingress)</td></tr>
<tr class="memdesc:gadf9f54714f6cd6888ca8947d9968ee33"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function enables or disables the support for egress data transfers from RAM buffers which are not 16-byte aligned based on whether the specified LVDS DMA adapters are working in Ingress only mode or not.  <a href="group__group__usbfxstack__hb__dma__functions.html#gadf9f54714f6cd6888ca8947d9968ee33">More...</a><br /></td></tr>
<tr class="separator:gadf9f54714f6cd6888ca8947d9968ee33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaae9cb0b7fcd758e64980ddfe4a784cdf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__usbfxstack__hb__dma__enums.html#ga8a1d453b60acfddb9766af3ad7c2ddaa">cy_en_hbdma_mgr_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__hb__dma__functions.html#gaae9cb0b7fcd758e64980ddfe4a784cdf">Cy_HBDma_DW_Configure</a> (<a class="el" href="group__group__usbfxstack__hb__dma__structs.html#structcy__stc__hbdma__channel__t">cy_stc_hbdma_channel_t</a> *pHandle, bool enable)</td></tr>
<tr class="memdesc:gaae9cb0b7fcd758e64980ddfe4a784cdf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configure the trigger connections for the DataWire used for transfers through a USB High-Speed Endpoint.  <a href="group__group__usbfxstack__hb__dma__functions.html#gaae9cb0b7fcd758e64980ddfe4a784cdf">More...</a><br /></td></tr>
<tr class="separator:gaae9cb0b7fcd758e64980ddfe4a784cdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga66412f84c789f6489d484b78b86be607"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__usbfxstack__hb__dma__enums.html#ga8a1d453b60acfddb9766af3ad7c2ddaa">cy_en_hbdma_mgr_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__hb__dma__functions.html#ga66412f84c789f6489d484b78b86be607">Cy_HBDma_DW_QueueRead</a> (<a class="el" href="group__group__usbfxstack__hb__dma__structs.html#structcy__stc__hbdma__channel__t">cy_stc_hbdma_channel_t</a> *pHandle, uint8_t prodIndex, uint8_t *pBuffer, uint16_t dataSize)</td></tr>
<tr class="memdesc:ga66412f84c789f6489d484b78b86be607"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function which queues read operation using DataWire DMA on USBHS OUT endpoint corresponding to a DMA channel.  <a href="group__group__usbfxstack__hb__dma__functions.html#ga66412f84c789f6489d484b78b86be607">More...</a><br /></td></tr>
<tr class="separator:ga66412f84c789f6489d484b78b86be607"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad56befbc8bbb358ad4c43f8d0978f91d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__usbfxstack__hb__dma__enums.html#ga8a1d453b60acfddb9766af3ad7c2ddaa">cy_en_hbdma_mgr_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__hb__dma__functions.html#gad56befbc8bbb358ad4c43f8d0978f91d">Cy_HBDma_DW_CompleteShortRead</a> (<a class="el" href="group__group__usbfxstack__hb__dma__structs.html#structcy__stc__hbdma__channel__t">cy_stc_hbdma_channel_t</a> *pHandle, uint8_t prodIndex, uint16_t shortPktSize)</td></tr>
<tr class="memdesc:gad56befbc8bbb358ad4c43f8d0978f91d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function which terminates ongoing USBHS ingress transfer when a short packet has been received on the endpoint.  <a href="group__group__usbfxstack__hb__dma__functions.html#gad56befbc8bbb358ad4c43f8d0978f91d">More...</a><br /></td></tr>
<tr class="separator:gad56befbc8bbb358ad4c43f8d0978f91d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad15112511c48efacc81b3655efb173a7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__usbfxstack__hb__dma__enums.html#ga8a1d453b60acfddb9766af3ad7c2ddaa">cy_en_hbdma_mgr_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__hb__dma__functions.html#gad15112511c48efacc81b3655efb173a7">Cy_HBDma_DW_QueueWrite</a> (<a class="el" href="group__group__usbfxstack__hb__dma__structs.html#structcy__stc__hbdma__channel__t">cy_stc_hbdma_channel_t</a> *pHandle, uint8_t consIndex, uint8_t *pBuffer, uint16_t dataSize)</td></tr>
<tr class="memdesc:gad15112511c48efacc81b3655efb173a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function which queues write operation using DataWire DMA on USBHS IN endpoint corresponding to a DMA channel.  <a href="group__group__usbfxstack__hb__dma__functions.html#gad15112511c48efacc81b3655efb173a7">More...</a><br /></td></tr>
<tr class="separator:gad15112511c48efacc81b3655efb173a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga239ee6292b479e83cb5645c837d9b75d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__hb__dma__functions.html#ga239ee6292b479e83cb5645c837d9b75d">Cy_HBDma_Mgr_HandleDW0Interrupt</a> (<a class="el" href="group__group__usbfxstack__hb__dma__structs.html#structcy__stc__hbdma__mgr__context__t">cy_stc_hbdma_mgr_context_t</a> *pDmaMgr)</td></tr>
<tr class="memdesc:ga239ee6292b479e83cb5645c837d9b75d"><td class="mdescLeft">&#160;</td><td class="mdescRight">DMA manager function that handles transfer completion interrupt from any of the DataWire channels associated with non EP0 USB-HS OUT endpoints (channels 1 to 15).  <a href="group__group__usbfxstack__hb__dma__functions.html#ga239ee6292b479e83cb5645c837d9b75d">More...</a><br /></td></tr>
<tr class="separator:ga239ee6292b479e83cb5645c837d9b75d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6a3d090dba3c10f62e5268af3337bdbf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__hb__dma__functions.html#ga6a3d090dba3c10f62e5268af3337bdbf">Cy_HBDma_Mgr_HandleDW1Interrupt</a> (<a class="el" href="group__group__usbfxstack__hb__dma__structs.html#structcy__stc__hbdma__mgr__context__t">cy_stc_hbdma_mgr_context_t</a> *pDmaMgr)</td></tr>
<tr class="memdesc:ga6a3d090dba3c10f62e5268af3337bdbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">DMA manager function that handles transfer completion interrupt from any of the DataWire channels associated with non EP0 USB-HS IN endpoints (channels 1 to 15).  <a href="group__group__usbfxstack__hb__dma__functions.html#ga6a3d090dba3c10f62e5268af3337bdbf">More...</a><br /></td></tr>
<tr class="separator:ga6a3d090dba3c10f62e5268af3337bdbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafc5003e1a752a17ac8e38636b36cec9d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__usbfxstack__hb__dma__functions.html#gafc5003e1a752a17ac8e38636b36cec9d">Cy_HBDma_Mgr_HandleUsbShortInterrupt</a> (<a class="el" href="group__group__usbfxstack__hb__dma__structs.html#structcy__stc__hbdma__mgr__context__t">cy_stc_hbdma_mgr_context_t</a> *pDmaMgr, uint8_t epNum, uint16_t pktSize)</td></tr>
<tr class="memdesc:gafc5003e1a752a17ac8e38636b36cec9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">DMA manager function that handles SLP or ZLP interrupts from USB-HS OUT endpoints.  <a href="group__group__usbfxstack__hb__dma__functions.html#gafc5003e1a752a17ac8e38636b36cec9d">More...</a><br /></td></tr>
<tr class="separator:gafc5003e1a752a17ac8e38636b36cec9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="gab7604ab75c6effda2157d432dc0e8075" name="gab7604ab75c6effda2157d432dc0e8075"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab7604ab75c6effda2157d432dc0e8075">&#9670;&nbsp;</a></span>Cy_HBDma_Init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__usbfxstack__hb__dma__enums.html#gaf3e10413a429d02d39bde06bd19fa9ab">cy_en_hbdma_status_t</a> Cy_HBDma_Init </td>
          <td>(</td>
          <td class="paramtype">LVDSSS_LVDS_Type *&#160;</td>
          <td class="paramname"><em>lvds_base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">USB32DEV_Type *&#160;</td>
          <td class="paramname"><em>usbss_base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__hb__dma__structs.html#structcy__stc__hbdma__context__t">cy_stc_hbdma_context_t</a> *&#160;</td>
          <td class="paramname"><em>pContext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>usb_egrs_fq_depth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>usb_egrs_rq_ctrl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes the High BandWidth DMA driver. </p>
<p >Pointers to the USB32DEV and LVDS control register blocks need to be passed as parameters while initializing the driver.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lvds_base</td><td>Pointer to the LVDS IP control registers.</td></tr>
    <tr><td class="paramname">usbss_base</td><td>Pointer to the USB32DEV IP control registers.</td></tr>
    <tr><td class="paramname">pContext</td><td>Pointer to the HBDma driver context structure.</td></tr>
    <tr><td class="paramname">usb_egrs_fq_depth</td><td>Fetch queue depth setting to be set for the USB32DEV egress DMA adapter.</td></tr>
    <tr><td class="paramname">usb_egrs_rq_ctrl</td><td>Read queue empty threshold to be set for the USB32DEV egress DMA adapter.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CY_HBDMA_SUCCESS if driver initialization is successful. CY_HBDMA_BAD_PARAM if the parameters passed in are invalid. </dd></dl>

</div>
</div>
<a id="ga7afaba6c4e0610da3f9240442b3c5ead" name="ga7afaba6c4e0610da3f9240442b3c5ead"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7afaba6c4e0610da3f9240442b3c5ead">&#9670;&nbsp;</a></span>Cy_HBDma_DeInit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cy_HBDma_DeInit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__hb__dma__structs.html#structcy__stc__hbdma__context__t">cy_stc_hbdma_context_t</a> *&#160;</td>
          <td class="paramname"><em>pContext</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>De-initialize the High BandWidth DMA adapter. </p>
<p >This function also disables the DMA adapters associated with the LVDS and USB32DEV IP blocks.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pContext</td><td>Pointer to the HBDma driver context structure. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga8a99bdb364b392c87d12f143f8488288" name="ga8a99bdb364b392c87d12f143f8488288"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8a99bdb364b392c87d12f143f8488288">&#9670;&nbsp;</a></span>Cy_HBDma_GetDescriptor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__usbfxstack__hb__dma__enums.html#gaf3e10413a429d02d39bde06bd19fa9ab">cy_en_hbdma_status_t</a> Cy_HBDma_GetDescriptor </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>dscrIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__hb__dma__structs.html#structcy__stc__hbdma__desc__t">cy_stc_hbdma_desc_t</a> *&#160;</td>
          <td class="paramname"><em>dscr_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads and returns the contents of the High BandWidth DMA descriptor with the specified index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dscrIndex</td><td>Index of the DMA descriptor to be fetched.</td></tr>
    <tr><td class="paramname">dscr_p</td><td>Pointer to structure to be filled with the descriptor information.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CY_HBDMA_SUCCESS if descriptor fetch is successful. CY_HBDMA_BAD_PARAM if the parameters passed in are invalid. </dd></dl>

</div>
</div>
<a id="ga815ddd5d10b5a5bc14927c0522b10c8f" name="ga815ddd5d10b5a5bc14927c0522b10c8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga815ddd5d10b5a5bc14927c0522b10c8f">&#9670;&nbsp;</a></span>Cy_HBDma_SetDescriptor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__usbfxstack__hb__dma__enums.html#gaf3e10413a429d02d39bde06bd19fa9ab">cy_en_hbdma_status_t</a> Cy_HBDma_SetDescriptor </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>dscrIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__hb__dma__structs.html#structcy__stc__hbdma__desc__t">cy_stc_hbdma_desc_t</a> *&#160;</td>
          <td class="paramname"><em>dscr_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Updates the High BandWidth DMA descriptor at a specified index with the desired values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dscrIndex</td><td>DMA descriptor index.</td></tr>
    <tr><td class="paramname">dscr_p</td><td>Structure containing the values to be updated in the DMA descriptor.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CY_HBDMA_SUCCESS if descriptor update is successful. CY_HBDMA_BAD_PARAM if the parameters passed in are invalid. </dd></dl>

</div>
</div>
<a id="gac0d27f05e71c9f155e6512a62ee4264a" name="gac0d27f05e71c9f155e6512a62ee4264a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac0d27f05e71c9f155e6512a62ee4264a">&#9670;&nbsp;</a></span>Cy_HBDma_GetSocketStatus()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__usbfxstack__hb__dma__enums.html#gaf3e10413a429d02d39bde06bd19fa9ab">cy_en_hbdma_status_t</a> Cy_HBDma_GetSocketStatus </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__hb__dma__structs.html#structcy__stc__hbdma__context__t">cy_stc_hbdma_context_t</a> *&#160;</td>
          <td class="paramname"><em>pContext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__hb__dma__enums.html#gab83411cd9077b5c27dda0bad41d89a06">cy_hbdma_socket_id_t</a>&#160;</td>
          <td class="paramname"><em>sock_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__hb__dma__structs.html#structcy__stc__hbdma__sock__t">cy_stc_hbdma_sock_t</a> *&#160;</td>
          <td class="paramname"><em>sckConf_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read and return the contents of all control and status registers associated with a High BandWidth DMA socket. </p>
<p >This function can be used to check the current socket status, and also as the first step during a read-modify-write update of the socket configuration.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pContext</td><td>Pointer to the driver context structure.</td></tr>
    <tr><td class="paramname">sock_id</td><td>ID of the socket whose status is to be retrieved.</td></tr>
    <tr><td class="paramname">sckConf_p</td><td>Pointer to structure to be filled with the socket status.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CY_HBDMA_SUCCESS if socket status read is successful. CY_HBDMA_BAD_PARAM if the parameters passed in are invalid. </dd></dl>

</div>
</div>
<a id="ga29be73ec0bd34905c36319154a15ec48" name="ga29be73ec0bd34905c36319154a15ec48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga29be73ec0bd34905c36319154a15ec48">&#9670;&nbsp;</a></span>Cy_HBDma_SetSocketConfig()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__usbfxstack__hb__dma__enums.html#gaf3e10413a429d02d39bde06bd19fa9ab">cy_en_hbdma_status_t</a> Cy_HBDma_SetSocketConfig </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__hb__dma__structs.html#structcy__stc__hbdma__context__t">cy_stc_hbdma_context_t</a> *&#160;</td>
          <td class="paramname"><em>pContext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__hb__dma__enums.html#gab83411cd9077b5c27dda0bad41d89a06">cy_hbdma_socket_id_t</a>&#160;</td>
          <td class="paramname"><em>sock_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__hb__dma__structs.html#structcy__stc__hbdma__sockconfig__t">cy_stc_hbdma_sockconfig_t</a> *&#160;</td>
          <td class="paramname"><em>conf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Updates the configuration of a HBDma socket with the desired fields from the config structure passed in as parameter. </p>
<p >This API can be used to update the current descriptor, the interrupt masks and the various config bits associated with the socket functionality.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pContext</td><td>Pointer to the driver context structure.</td></tr>
    <tr><td class="paramname">sock_id</td><td>ID of the socket whose configuration is to be updated.</td></tr>
    <tr><td class="paramname">conf</td><td>Pointer to the desired socket configuration.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CY_HBDMA_SUCCESS if socket update is successful. CY_HBDMA_BAD_PARAM if the parameters passed in are invalid. </dd></dl>

</div>
</div>
<a id="ga69c97024a8307c18deb2994d29a7a35c" name="ga69c97024a8307c18deb2994d29a7a35c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga69c97024a8307c18deb2994d29a7a35c">&#9670;&nbsp;</a></span>Cy_HBDma_UpdateSockIntrMask()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__usbfxstack__hb__dma__enums.html#gaf3e10413a429d02d39bde06bd19fa9ab">cy_en_hbdma_status_t</a> Cy_HBDma_UpdateSockIntrMask </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__hb__dma__structs.html#structcy__stc__hbdma__context__t">cy_stc_hbdma_context_t</a> *&#160;</td>
          <td class="paramname"><em>pContext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__hb__dma__enums.html#gab83411cd9077b5c27dda0bad41d89a06">cy_hbdma_socket_id_t</a>&#160;</td>
          <td class="paramname"><em>sock_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>intrMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Special function provided to update only the interrupt mask associated with a HBDma socket. </p>
<p >This is a subset of the functionality provided by the Cy_HBDma_SetSocketConfig API.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pContext</td><td>Pointer to the HBDMA driver context structure.</td></tr>
    <tr><td class="paramname">sock_id</td><td>ID of the socket to be updated.</td></tr>
    <tr><td class="paramname">intrMap</td><td>Bit map specifying the interrupt mask bits to be updated.</td></tr>
    <tr><td class="paramname">enable</td><td>Whether the interrupts specified in intrMap are to be enabled or disabled.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CY_HBDMA_SUCCESS if socket update is successful. CY_HBDMA_BAD_PARAM if the parameters passed in are invalid. </dd></dl>

</div>
</div>
<a id="ga56c84be36a902107ece8bd74b732ea48" name="ga56c84be36a902107ece8bd74b732ea48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga56c84be36a902107ece8bd74b732ea48">&#9670;&nbsp;</a></span>Cy_HBDma_SocketEnable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__usbfxstack__hb__dma__enums.html#gaf3e10413a429d02d39bde06bd19fa9ab">cy_en_hbdma_status_t</a> Cy_HBDma_SocketEnable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__hb__dma__structs.html#structcy__stc__hbdma__context__t">cy_stc_hbdma_context_t</a> *&#160;</td>
          <td class="paramname"><em>pContext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__hb__dma__enums.html#gab83411cd9077b5c27dda0bad41d89a06">cy_hbdma_socket_id_t</a>&#160;</td>
          <td class="paramname"><em>sock_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to enable a High BandWidth DMA socket after it has been configured using the Cy_HBDma_SetSocketConfig API. </p>
<p >If the socket has not been configured properly before it is enabled, it can result in unexpected transfers or errors.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pContext</td><td>Pointer to HBDMA driver context structure.</td></tr>
    <tr><td class="paramname">sock_id</td><td>ID of the socket to be enabled.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CY_HBDMA_SUCCESS if socket update is successful. CY_HBDMA_BAD_PARAM if the parameters passed in are invalid. </dd></dl>

</div>
</div>
<a id="ga58afb3f835a37db93ecba9a9730bc5f0" name="ga58afb3f835a37db93ecba9a9730bc5f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga58afb3f835a37db93ecba9a9730bc5f0">&#9670;&nbsp;</a></span>Cy_HBDma_SocketDisable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__usbfxstack__hb__dma__enums.html#gaf3e10413a429d02d39bde06bd19fa9ab">cy_en_hbdma_status_t</a> Cy_HBDma_SocketDisable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__hb__dma__structs.html#structcy__stc__hbdma__context__t">cy_stc_hbdma_context_t</a> *&#160;</td>
          <td class="paramname"><em>pContext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__hb__dma__enums.html#gab83411cd9077b5c27dda0bad41d89a06">cy_hbdma_socket_id_t</a>&#160;</td>
          <td class="paramname"><em>sock_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to disable a High BandWidth DMA socket. </p>
<p >This function causes any ongoing DMA transfer on the socket to be aborted and blocks until the socket has moved into the disabled state.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pContext</td><td>Pointer to HBDMA driver context structure.</td></tr>
    <tr><td class="paramname">sock_id</td><td>ID of the socket to be disabled.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CY_HBDMA_SUCCESS if socket update is successful. CY_HBDMA_BAD_PARAM if the parameters passed in are invalid. </dd></dl>

</div>
</div>
<a id="gae2c5376dd61d3d97b38ff7453e20841e" name="gae2c5376dd61d3d97b38ff7453e20841e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae2c5376dd61d3d97b38ff7453e20841e">&#9670;&nbsp;</a></span>Cy_HBDma_SocketSetWrapUp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__usbfxstack__hb__dma__enums.html#gaf3e10413a429d02d39bde06bd19fa9ab">cy_en_hbdma_status_t</a> Cy_HBDma_SocketSetWrapUp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__hb__dma__structs.html#structcy__stc__hbdma__context__t">cy_stc_hbdma_context_t</a> *&#160;</td>
          <td class="paramname"><em>pContext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__hb__dma__enums.html#gab83411cd9077b5c27dda0bad41d89a06">cy_hbdma_socket_id_t</a>&#160;</td>
          <td class="paramname"><em>sock_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function sets the bit that forces a socket with a partially filled buffer to wrap up the buffer. </p>
<p >The function does not wait for the socket to wrap up. This API should be called after ensuring that the socket in question is not actively receiving data. Otherwise, this can result in data loss.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pContext</td><td>Pointer to HBDMA driver context structure.</td></tr>
    <tr><td class="paramname">sock_id</td><td>ID of the socket to be wraped up.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CY_HBDMA_SUCCESS if socket update is successful. CY_HBDMA_BAD_PARAM if the parameters passed in are invalid. </dd></dl>

</div>
</div>
<a id="ga5b9f77671bfa7d111a29c6fea7e6d18e" name="ga5b9f77671bfa7d111a29c6fea7e6d18e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5b9f77671bfa7d111a29c6fea7e6d18e">&#9670;&nbsp;</a></span>Cy_HBDma_SendSocketEvent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__usbfxstack__hb__dma__enums.html#gaf3e10413a429d02d39bde06bd19fa9ab">cy_en_hbdma_status_t</a> Cy_HBDma_SendSocketEvent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__hb__dma__structs.html#structcy__stc__hbdma__context__t">cy_stc_hbdma_context_t</a> *&#160;</td>
          <td class="paramname"><em>pContext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__hb__dma__enums.html#gab83411cd9077b5c27dda0bad41d89a06">cy_hbdma_socket_id_t</a>&#160;</td>
          <td class="paramname"><em>sock_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isProduceEvent</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to send an event notification to the specified socket. </p>
<p >Either a produce event or a consume event can be sent based on the use case and type of the socket.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pContext</td><td>Pointer to HBDMA driver context structure.</td></tr>
    <tr><td class="paramname">sock_id</td><td>ID of the socket to which the event is to be sent.</td></tr>
    <tr><td class="paramname">isProduceEvent</td><td>Set to true for sending a produce event, false for consume event.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CY_HBDMA_SUCCESS if sending the event is successful. CY_HBDMA_BAD_PARAM if the parameters passed in are invalid. </dd></dl>

</div>
</div>
<a id="ga5a9a4641d7e532489b3b1938ae89df84" name="ga5a9a4641d7e532489b3b1938ae89df84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5a9a4641d7e532489b3b1938ae89df84">&#9670;&nbsp;</a></span>Cy_HbDma_ConnectEventTrigger()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__usbfxstack__hb__dma__enums.html#gaf3e10413a429d02d39bde06bd19fa9ab">cy_en_hbdma_status_t</a> Cy_HbDma_ConnectEventTrigger </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__hb__dma__structs.html#structcy__stc__hbdma__context__t">cy_stc_hbdma_context_t</a> *&#160;</td>
          <td class="paramname"><em>pContext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__hb__dma__enums.html#gab83411cd9077b5c27dda0bad41d89a06">cy_hbdma_socket_id_t</a>&#160;</td>
          <td class="paramname"><em>src_sock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__hb__dma__enums.html#gab83411cd9077b5c27dda0bad41d89a06">cy_hbdma_socket_id_t</a>&#160;</td>
          <td class="paramname"><em>dst_sock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>trigNum</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to connect the event trigger output from one socket to the input of another socket. </p>
<p >The same mechanism is used for sending produce events from an ingress socket to an egress socket as well as for sending consume events from an egress socket to an ingress socket.</p>
<p >If the DMA configuration used is a 1:2 or a 2:1 channel, trigger outputs from multiple sockets can be connected to the input of one socket. The trigNum parameter is used to specify the index of the event trigger input on the destination side.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pContext</td><td>Pointer to HBDMA driver context structure.</td></tr>
    <tr><td class="paramname">src_sock</td><td>ID of the socket which generates the produce or consume event trigger.</td></tr>
    <tr><td class="paramname">dst_sock</td><td>ID of the socket which receives the event trigger.</td></tr>
    <tr><td class="paramname">trigNum</td><td>Index of the trigger input on the destination socket. Can be 0 or 1.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CY_HBDMA_SUCCESS if the trigger connection is successful. CY_HBDMA_BAD_PARAM if the parameters passed in are invalid. </dd></dl>

</div>
</div>
<a id="ga1e68c5fa3f5421fdb202358da6257ceb" name="ga1e68c5fa3f5421fdb202358da6257ceb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1e68c5fa3f5421fdb202358da6257ceb">&#9670;&nbsp;</a></span>Cy_HbDma_DisconnectEventTriggers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__usbfxstack__hb__dma__enums.html#gaf3e10413a429d02d39bde06bd19fa9ab">cy_en_hbdma_status_t</a> Cy_HbDma_DisconnectEventTriggers </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__hb__dma__structs.html#structcy__stc__hbdma__context__t">cy_stc_hbdma_context_t</a> *&#160;</td>
          <td class="paramname"><em>pContext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__hb__dma__enums.html#gab83411cd9077b5c27dda0bad41d89a06">cy_hbdma_socket_id_t</a>&#160;</td>
          <td class="paramname"><em>dst_sock</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to break all event trigger connections coming to a socket. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pContext</td><td>Pointer to HBDMA driver context structure.</td></tr>
    <tr><td class="paramname">dst_sock</td><td>ID of the socket which receives the event trigger.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CY_HBDMA_SUCCESS if the operation is successful. CY_HBDMA_BAD_PARAM if the parameters passed in are invalid. </dd></dl>

</div>
</div>
<a id="gad7794a4f5fbb7076af32e11a27a3f1a7" name="gad7794a4f5fbb7076af32e11a27a3f1a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad7794a4f5fbb7076af32e11a27a3f1a7">&#9670;&nbsp;</a></span>Cy_HBDma_HandleInterrupts()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__usbfxstack__hb__dma__enums.html#gaf3e10413a429d02d39bde06bd19fa9ab">cy_en_hbdma_status_t</a> Cy_HBDma_HandleInterrupts </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__hb__dma__structs.html#structcy__stc__hbdma__context__t">cy_stc_hbdma_context_t</a> *&#160;</td>
          <td class="paramname"><em>pContext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__hb__dma__enums.html#ga93990ff7fbc856e3f3bfc00a76331509">cy_hbdma_adapter_id_t</a>&#160;</td>
          <td class="paramname"><em>adapter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function which handles the interrupts generated by any of the sockets associated with a High BandWidth DMA adapter. </p>
<p >This function is expected to be called from the ISR for the corresponding interrupt vector.</p>
<p >The interrupt handling in the driver is only a top-half implementation which notifies the HBDma manager layer and then clears the interrupt.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pContext</td><td>Pointer to HBDMA driver context structure.</td></tr>
    <tr><td class="paramname">adapter</td><td>Identifies the adapter for which the interrupts are to be serviced.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CY_HBDMA_SUCCESS if the adapter specified is valid. CY_HBDMA_BAD_PARAM if invalid parameters are passed in. </dd></dl>

</div>
</div>
<a id="gacbd71d2e2ced0f0f2bb63cf071083b03" name="gacbd71d2e2ced0f0f2bb63cf071083b03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacbd71d2e2ced0f0f2bb63cf071083b03">&#9670;&nbsp;</a></span>Cy_HBDma_SetInterruptCallback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__usbfxstack__hb__dma__enums.html#gaf3e10413a429d02d39bde06bd19fa9ab">cy_en_hbdma_status_t</a> Cy_HBDma_SetInterruptCallback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__hb__dma__structs.html#structcy__stc__hbdma__context__t">cy_stc_hbdma_context_t</a> *&#160;</td>
          <td class="paramname"><em>pContext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__hb__dma__typedefs.html#ga85e2868090c71b227b87e0798cd7ccd9">cy_cb_hbdma_intr_callback_t</a>&#160;</td>
          <td class="paramname"><em>cb_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cbContext</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function that registers a callback which can be called the HBDma driver to provide notification of socket interrupts. </p>
<p >The callback will be registered by the HBDma manager layer and will be called when the socket interrupts are serviced through the Cy_HBDma_HandleInterrupts function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pContext</td><td>Pointer to HBDMA driver context structure.</td></tr>
    <tr><td class="paramname">cb_p</td><td>Callback function pointer.</td></tr>
    <tr><td class="paramname">cbContext</td><td>Opaque user data to be passed to the callback function.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CY_HBDMA_SUCCESS if callback registration is successful. CY_HBDMA_BAD_PARAM if the parameters passed in are invalid. </dd></dl>

</div>
</div>
<a id="ga09649439e2ed09810cd07974539422c0" name="ga09649439e2ed09810cd07974539422c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga09649439e2ed09810cd07974539422c0">&#9670;&nbsp;</a></span>Cy_HBDma_EvictReadCache()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cy_HBDma_EvictReadCache </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isCm4Access</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evicts the read cache used while masters are using either the Fast AHB bus (Cortex-M4) or the Slow AHB bus (Cortex-M0+, DataWire, DMAC or Crypto) to read content from the High BandWidth RAM area. </p>
<p >This operation is required whenever a master is reading from the RAM while there is a possibility of the corresponding memory having been modified by DMA operations.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">isCm4Access</td><td>Whether the read cache used by Cortex-M4 is to be cleared. Set to false for all other masters. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga025adad5e435a2465dd8c5c86af2489b" name="ga025adad5e435a2465dd8c5c86af2489b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga025adad5e435a2465dd8c5c86af2489b">&#9670;&nbsp;</a></span>Cy_HBDma_SetClockFrequency()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__usbfxstack__hb__dma__enums.html#gaf3e10413a429d02d39bde06bd19fa9ab">cy_en_hbdma_status_t</a> Cy_HBDma_SetClockFrequency </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__hb__dma__enums.html#gaf07a15620aa6ac9a13b4fffef4cf6a8c">cy_en_hbdma_clk_freq_t</a>&#160;</td>
          <td class="paramname"><em>dmaFreq</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the high bandwidth DMA clock frequency to the desired value. </p>
<p >Please note that parameters in the USB block need to be set based on the operating USB speed and selected clock frequency. Hence, this function is expected to be called from the USB stack and not expected to be called directly.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dmaFreq</td><td>Desired DMA domain clock frequency.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CY_HBDMA_SUCCESS if clock setup is successful CY_HBDMA_BAD_PARAM if the parameter passed in is invalid. </dd></dl>

</div>
</div>
<a id="ga4865c480ade86e0b79f4ef2160ed3164" name="ga4865c480ade86e0b79f4ef2160ed3164"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4865c480ade86e0b79f4ef2160ed3164">&#9670;&nbsp;</a></span>Cy_HBDma_Is64KBufferEnabled()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Cy_HBDma_Is64KBufferEnabled </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__hb__dma__structs.html#structcy__stc__hbdma__context__t">cy_stc_hbdma_context_t</a> *&#160;</td>
          <td class="paramname"><em>pDrvContext</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check whether 64KB DMA buffer support is enabled on the device. </p>
<p >This feature is not supported on A0 silicon revision of FX10.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pDrvContext</td><td>Pointer to DMA driver context structure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if 64KB DMA buffers are supported. false if 64KB DMA buffers are not supported. </dd></dl>

</div>
</div>
<a id="gab7ff1ea9bf263cf80645fed9e0b1edcd" name="gab7ff1ea9bf263cf80645fed9e0b1edcd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab7ff1ea9bf263cf80645fed9e0b1edcd">&#9670;&nbsp;</a></span>Cy_HBDma_SetUsbEgressAdapterDelay()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cy_HBDma_SetUsbEgressAdapterDelay </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__hb__dma__structs.html#structcy__stc__hbdma__context__t">cy_stc_hbdma_context_t</a> *&#160;</td>
          <td class="paramname"><em>pDrvContext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>gblDelayCycles</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Update the number of cycles of delay to be applied between consecutive AXI data fetches made by the USB egress DMA adapter. </p>
<p >The function is meant to be used by the USB stack based on current USB speed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pDrvContext</td><td>Pointer to DMA driver context structure.</td></tr>
    <tr><td class="paramname">gblDelayCycles</td><td>Number of delay cycles to be applied in the range of 0 to 15. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga5054870fc1b7e19a70b052d876b8c451" name="ga5054870fc1b7e19a70b052d876b8c451"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5054870fc1b7e19a70b052d876b8c451">&#9670;&nbsp;</a></span>Cy_HBDma_SetLvdsAdapterIngressMode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cy_HBDma_SetLvdsAdapterIngressMode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__hb__dma__structs.html#structcy__stc__hbdma__context__t">cy_stc_hbdma_context_t</a> *&#160;</td>
          <td class="paramname"><em>pDrvContext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isAdap0Ingress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isAdap1Ingress</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function enables or disables the support for egress data transfers from RAM buffers which are not 16-byte aligned based on whether the specified LVDS DMA adapters are working in Ingress only mode or not. </p>
<p >For any ingress-only adapter, this support can be disabled to gain better DMA performance.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pDrvContext</td><td>Pointer to DMA driver context structure.</td></tr>
    <tr><td class="paramname">isAdap0Ingress</td><td>Whether adapter 0 (sockets 0 to 15) is being used only in ingress direction.</td></tr>
    <tr><td class="paramname">isAdap1Ingress</td><td>Whether adapter 1 (sockets 16 to 31) is being used only in ingress direction. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga73c1b44eee45847690e71a9f4dbf9fa7" name="ga73c1b44eee45847690e71a9f4dbf9fa7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga73c1b44eee45847690e71a9f4dbf9fa7">&#9670;&nbsp;</a></span>Cy_HBDma_Mgr_GetVersion()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t Cy_HBDma_Mgr_GetVersion </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the High BandWidth Manager Middleware version information in the form of a 32-bit word including the major, minor, patch and build numbers. </p>
<dl class="section return"><dt>Returns</dt><dd>Version information for this library in the format: b31:28 -&gt; Major Version b27:24 -&gt; Minor Version b23:16 -&gt; Patch Version b15:00 -&gt; Build Number </dd></dl>

</div>
</div>
<a id="ga0270a0db7487599f2e8cf8c6bf505251" name="ga0270a0db7487599f2e8cf8c6bf505251"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0270a0db7487599f2e8cf8c6bf505251">&#9670;&nbsp;</a></span>Cy_HBDma_DscrList_Create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__usbfxstack__hb__dma__enums.html#ga8a1d453b60acfddb9766af3ad7c2ddaa">cy_en_hbdma_mgr_status_t</a> Cy_HBDma_DscrList_Create </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__hb__dma__structs.html#structcy__stc__hbdma__dscr__list__t">cy_stc_hbdma_dscr_list_t</a> *&#160;</td>
          <td class="paramname"><em>list_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>maxDscrCount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize the allocator used to manage High BandWidth DMA descriptors. </p>
<p >It is assumed that all descriptors are free for use after this API has been called.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">list_p</td><td>Pointer to the descriptor list structure to be initialized.</td></tr>
    <tr><td class="paramname">maxDscrCount</td><td>Maximum number of descriptors to be allowed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CY_HBDMA_MGR_SUCCESS if the allocator initialization is successful. CY_HBDMA_MGR_BAD_PARAM if the parameters are invalid. </dd></dl>

</div>
</div>
<a id="gad54594cfbaee3daf93a076fc68b9f00d" name="gad54594cfbaee3daf93a076fc68b9f00d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad54594cfbaee3daf93a076fc68b9f00d">&#9670;&nbsp;</a></span>Cy_HBDma_DscrList_Destroy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__usbfxstack__hb__dma__enums.html#ga8a1d453b60acfddb9766af3ad7c2ddaa">cy_en_hbdma_mgr_status_t</a> Cy_HBDma_DscrList_Destroy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__hb__dma__structs.html#structcy__stc__hbdma__dscr__list__t">cy_stc_hbdma_dscr_list_t</a> *&#160;</td>
          <td class="paramname"><em>list_p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>De-initialize the allocator used to manage High BandWidth DMA descriptors. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">list_p</td><td>Pointer to the descriptor list structure to be de-initialized.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CY_HBDMA_MGR_SUCCESS if the allocator de-init is successful. CY_HBDMA_MGR_BAD_PARAM if the parameter is invalid. </dd></dl>

</div>
</div>
<a id="gabb860ae2a4d79c507239da5ab41fec0e" name="gabb860ae2a4d79c507239da5ab41fec0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabb860ae2a4d79c507239da5ab41fec0e">&#9670;&nbsp;</a></span>Cy_HBDma_DscrList_Get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__usbfxstack__hb__dma__enums.html#ga8a1d453b60acfddb9766af3ad7c2ddaa">cy_en_hbdma_mgr_status_t</a> Cy_HBDma_DscrList_Get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__hb__dma__structs.html#structcy__stc__hbdma__dscr__list__t">cy_stc_hbdma_dscr_list_t</a> *&#160;</td>
          <td class="paramname"><em>list_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t *&#160;</td>
          <td class="paramname"><em>dscrIndex_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Obtain a free HBW DMA descriptor from the free list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">list_p</td><td>Pointer to the descriptor list structure.</td></tr>
    <tr><td class="paramname">dscrIndex_p</td><td>Return parameter through which the descriptor index is returned.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CY_HBDMA_MGR_SUCCESS if a free descriptor is available and is being returned. CY_HBDMA_MGR_BAD_PARAM if the parameters are invalid. CY_HBDMA_MGR_MEMORY_ERROR if no descriptors are available. </dd></dl>

</div>
</div>
<a id="gaaff76d81c20945a5b223775955485e44" name="gaaff76d81c20945a5b223775955485e44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaff76d81c20945a5b223775955485e44">&#9670;&nbsp;</a></span>Cy_HBDma_DscrList_Put()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__usbfxstack__hb__dma__enums.html#ga8a1d453b60acfddb9766af3ad7c2ddaa">cy_en_hbdma_mgr_status_t</a> Cy_HBDma_DscrList_Put </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__hb__dma__structs.html#structcy__stc__hbdma__dscr__list__t">cy_stc_hbdma_dscr_list_t</a> *&#160;</td>
          <td class="paramname"><em>list_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>dscrIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Release a HBW DMA descriptor back to the free list. </p>
<dl class="section note"><dt>Note</dt><dd>The function will succeed even if the descriptor being freed was already free.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">list_p</td><td>Pointer to the descriptor list structure.</td></tr>
    <tr><td class="paramname">dscrIndex</td><td>Index of descriptor to be freed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CY_HBDMA_MGR_SUCCESS if the descriptor free operation is successful. CY_HBDMA_MGR_BAD_PARAM if the parameters are invalid. </dd></dl>

</div>
</div>
<a id="ga55d68477b4bbc31bd66832453295487a" name="ga55d68477b4bbc31bd66832453295487a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga55d68477b4bbc31bd66832453295487a">&#9670;&nbsp;</a></span>Cy_HBDma_BufMgr_Create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__usbfxstack__hb__dma__enums.html#ga8a1d453b60acfddb9766af3ad7c2ddaa">cy_en_hbdma_mgr_status_t</a> Cy_HBDma_BufMgr_Create </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__hb__dma__structs.html#structcy__stc__hbdma__buf__mgr__t">cy_stc_hbdma_buf_mgr_t</a> *&#160;</td>
          <td class="paramname"><em>mgr_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>regionSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function initializes the custom heap used for DMA buffer allocation. </p>
<p >These functions use a home-grown allocator in order to ensure that all DMA buffers allocated are cache line aligned (multiple of 64 bytes).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mgr_p</td><td>Pointer to the buffer manager context structure.</td></tr>
    <tr><td class="paramname">baseAddr</td><td>Base address of the memory region reserved for DMA buffers.</td></tr>
    <tr><td class="paramname">regionSize</td><td>Size of the memory region reserved for DMA buffers.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CY_HBDMA_MGR_SUCCESS if the custom heap init is successful. CY_HBDMA_MGR_BAD_PARAM in case of invalid parameters. </dd></dl>

</div>
</div>
<a id="ga972d84b73265cd460f4116a875572144" name="ga972d84b73265cd460f4116a875572144"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga972d84b73265cd460f4116a875572144">&#9670;&nbsp;</a></span>Cy_HBDma_BufMgr_Destroy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__usbfxstack__hb__dma__enums.html#ga8a1d453b60acfddb9766af3ad7c2ddaa">cy_en_hbdma_mgr_status_t</a> Cy_HBDma_BufMgr_Destroy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__hb__dma__structs.html#structcy__stc__hbdma__buf__mgr__t">cy_stc_hbdma_buf_mgr_t</a> *&#160;</td>
          <td class="paramname"><em>mgr_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>freeAll</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function frees up the custom heap used for DMA buffer allocation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mgr_p</td><td>Pointer to the buffer manager context structure.</td></tr>
    <tr><td class="paramname">freeAll</td><td>Whether all memory buffers should be freed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CY_HBDMA_MGR_SUCCESS if the heap de-init is successful. CY_HBDMA_MGR_BAD_PARAM if the parameters are invalid. </dd></dl>

</div>
</div>
<a id="ga53fb59b7fff1e3f32106cce3dfe91bee" name="ga53fb59b7fff1e3f32106cce3dfe91bee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga53fb59b7fff1e3f32106cce3dfe91bee">&#9670;&nbsp;</a></span>Cy_HBDma_BufMgr_Alloc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * Cy_HBDma_BufMgr_Alloc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__hb__dma__structs.html#structcy__stc__hbdma__buf__mgr__t">cy_stc_hbdma_buf_mgr_t</a> *&#160;</td>
          <td class="paramname"><em>mgr_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>bufferSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function allocates memory required for DMA buffers required by the firmware application. </p>
<p >The size parameter will be rounded up to the next multiple of 64 as the allocator only provides memory blocks in multiples of 64 bytes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mgr_p</td><td>Pointer to DMA buffer manager.</td></tr>
    <tr><td class="paramname">bufferSize</td><td>Size of the DMA buffer to be allocated (in bytes).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the DMA buffer. </dd></dl>

</div>
</div>
<a id="ga73272ac6afd3e262859e0651fc870eba" name="ga73272ac6afd3e262859e0651fc870eba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga73272ac6afd3e262859e0651fc870eba">&#9670;&nbsp;</a></span>Cy_HBDma_BufMgr_Free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__usbfxstack__hb__dma__enums.html#ga8a1d453b60acfddb9766af3ad7c2ddaa">cy_en_hbdma_mgr_status_t</a> Cy_HBDma_BufMgr_Free </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__hb__dma__structs.html#structcy__stc__hbdma__buf__mgr__t">cy_stc_hbdma_buf_mgr_t</a> *&#160;</td>
          <td class="paramname"><em>mgr_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buffer_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function frees memory which was previously allocated using Cy_HBDma_BufMgr_Alloc. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mgr_p</td><td>Pointer to DMA buffer manager.</td></tr>
    <tr><td class="paramname">buffer_p</td><td>Pointer to the buffer to be freed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CY_HBDMA_MGR_SUCCESS if the free operation is successful. CY_HBDMA_MGR_BAD_PARAM if the parameters are invalid. </dd></dl>

</div>
</div>
<a id="ga7b048031a2c4a5598791278aa6362ba2" name="ga7b048031a2c4a5598791278aa6362ba2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7b048031a2c4a5598791278aa6362ba2">&#9670;&nbsp;</a></span>Cy_HBDma_Mgr_Init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__usbfxstack__hb__dma__enums.html#ga8a1d453b60acfddb9766af3ad7c2ddaa">cy_en_hbdma_mgr_status_t</a> Cy_HBDma_Mgr_Init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__hb__dma__structs.html#structcy__stc__hbdma__mgr__context__t">cy_stc_hbdma_mgr_context_t</a> *&#160;</td>
          <td class="paramname"><em>context_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__hb__dma__structs.html#structcy__stc__hbdma__context__t">cy_stc_hbdma_context_t</a> *&#160;</td>
          <td class="paramname"><em>drvContext_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__hb__dma__structs.html#structcy__stc__hbdma__dscr__list__t">cy_stc_hbdma_dscr_list_t</a> *&#160;</td>
          <td class="paramname"><em>dscrPool_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__hb__dma__structs.html#structcy__stc__hbdma__buf__mgr__t">cy_stc_hbdma_buf_mgr_t</a> *&#160;</td>
          <td class="paramname"><em>bufMgr_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize the High BandWidth DMA manager library. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context_p</td><td>Pointer to the DMA manager context structure.</td></tr>
    <tr><td class="paramname">drvContext_p</td><td>Pointer to the HBDMA driver context structure.</td></tr>
    <tr><td class="paramname">dscrPool_p</td><td>Pointer to the HBDMA descriptor list.</td></tr>
    <tr><td class="paramname">bufMgr_p</td><td>Pointer to the HBDMA buffer manager context.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CY_HBDMA_MGR_SUCCESS if the DMA manager init was successful. CY_HBDMA_MGR_BAD_PARAM if the parameters are invalid. </dd></dl>

</div>
</div>
<a id="gab4961fcbc111e04c9af83e40fd1c983f" name="gab4961fcbc111e04c9af83e40fd1c983f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab4961fcbc111e04c9af83e40fd1c983f">&#9670;&nbsp;</a></span>Cy_HBDma_Mgr_DeInit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__usbfxstack__hb__dma__enums.html#ga8a1d453b60acfddb9766af3ad7c2ddaa">cy_en_hbdma_mgr_status_t</a> Cy_HBDma_Mgr_DeInit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__hb__dma__structs.html#structcy__stc__hbdma__mgr__context__t">cy_stc_hbdma_mgr_context_t</a> *&#160;</td>
          <td class="paramname"><em>context_p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>De-initialize the High BandWidth DMA manager library. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context_p</td><td>Pointer to the DMA manager context structure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CY_HBDMA_MGR_SUCCESS if the manager de-init is successful. CY_HBDMA_MGR_BAD_PARAM if the context structure passed is invalid. </dd></dl>

</div>
</div>
<a id="ga51a42ea3fc4527e840654eb2a0dc5fcd" name="ga51a42ea3fc4527e840654eb2a0dc5fcd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga51a42ea3fc4527e840654eb2a0dc5fcd">&#9670;&nbsp;</a></span>Cy_HBDma_Mgr_RegisterUsbContext()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cy_HBDma_Mgr_RegisterUsbContext </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__hb__dma__structs.html#structcy__stc__hbdma__mgr__context__t">cy_stc_hbdma_mgr_context_t</a> *&#160;</td>
          <td class="paramname"><em>context_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pUsbStackCtx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register the USB stack context pointer with the High BandWidth manager. </p>
<p >A valid stack context is required to make use of USB-HS endpoints and DataWire channels with the High BandWidth channel API.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context_p</td><td>Pointer to the DMA manager context structure. </td></tr>
    <tr><td class="paramname">pUsbStackCtx</td><td>Pointer to USB stack context structure passed as an opaque pointer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaa8a5b3b3e0cde64db51870a4d1d6e9d8" name="gaa8a5b3b3e0cde64db51870a4d1d6e9d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa8a5b3b3e0cde64db51870a4d1d6e9d8">&#9670;&nbsp;</a></span>Cy_HBDma_Mgr_UpdateMultEn()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__usbfxstack__hb__dma__enums.html#ga8a1d453b60acfddb9766af3ad7c2ddaa">cy_en_hbdma_mgr_status_t</a> Cy_HBDma_Mgr_UpdateMultEn </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__hb__dma__structs.html#structcy__stc__hbdma__mgr__context__t">cy_stc_hbdma_mgr_context_t</a> *&#160;</td>
          <td class="paramname"><em>pContext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>endpNumber</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isEgressEp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>multEnable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Update the MULT setting for sockets associated with USB endpoints. </p>
<p >When the MULT feature is enabled at the socket level, the USB32DEV endpoint memory is allowed to combine the data from multiple DMA buffers into one transfer burst, thereby getting better data throughput in typical use cases.</p>
<dl class="section warning"><dt>Warning</dt><dd>This function is expected to be called from the USB32 device stack and not directly by the user.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pContext</td><td>Pointer to the DMA manager context structure.</td></tr>
    <tr><td class="paramname">endpNumber</td><td>USB endpoint index.</td></tr>
    <tr><td class="paramname">isEgressEp</td><td>Whether this is an Egress endpoint.</td></tr>
    <tr><td class="paramname">multEnable</td><td>Whether to enable the MULT feature.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CY_HBDMA_MGR_SUCCESS if the MULT setting is updated correctly. CY_HBDMA_MGR_BAD_PARAM if the parameters are invalid. </dd></dl>

</div>
</div>
<a id="gaa82429d7fa2c2e991eceb96bc9ec8668" name="gaa82429d7fa2c2e991eceb96bc9ec8668"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa82429d7fa2c2e991eceb96bc9ec8668">&#9670;&nbsp;</a></span>Cy_HBDma_Channel_Create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__usbfxstack__hb__dma__enums.html#ga8a1d453b60acfddb9766af3ad7c2ddaa">cy_en_hbdma_mgr_status_t</a> Cy_HBDma_Channel_Create </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__hb__dma__structs.html#structcy__stc__hbdma__mgr__context__t">cy_stc_hbdma_mgr_context_t</a> *&#160;</td>
          <td class="paramname"><em>pDmaMgr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__hb__dma__structs.html#structcy__stc__hbdma__channel__t">cy_stc_hbdma_channel_t</a> *&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__hb__dma__structs.html#structcy__stc__hbdma__chn__config__t">cy_stc_hbdma_chn_config_t</a> *&#160;</td>
          <td class="paramname"><em>config</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a High BandWidth DMA channel based on the parameters specified in the config structure. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pDmaMgr</td><td>Pointer to the DMA manager context structure.</td></tr>
    <tr><td class="paramname">handle</td><td>Handle to the DMA channel structure.</td></tr>
    <tr><td class="paramname">config</td><td>Desired DMA channel configuration.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CY_HBDMA_MGR_SUCCESS if the channel creation is successful. CY_HBDMA_MGR_BAD_PARAM if the parameters are invalid. </dd></dl>

</div>
</div>
<a id="ga0d36ce61ee1a513773f7e6c964c5cab9" name="ga0d36ce61ee1a513773f7e6c964c5cab9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0d36ce61ee1a513773f7e6c964c5cab9">&#9670;&nbsp;</a></span>Cy_HBDma_Channel_Destroy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__usbfxstack__hb__dma__enums.html#ga8a1d453b60acfddb9766af3ad7c2ddaa">cy_en_hbdma_mgr_status_t</a> Cy_HBDma_Channel_Destroy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__hb__dma__structs.html#structcy__stc__hbdma__channel__t">cy_stc_hbdma_channel_t</a> *&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroy a High BandWidth DMA channel. </p>
<p >The implementation makes sure that the DMA sockets associated with the channel are disabled in addition to cleaning up the data structures and freeing memory elements.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>Handle to the DMA channel structure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CY_HBDMA_MGR_SUCCESS if the channel destroy operation is successful. CY_HBDMA_MGR_BAD_PARAM if the parameters are invalid. </dd></dl>

</div>
</div>
<a id="ga8d726d57b772a75adb666f1c082be8ed" name="ga8d726d57b772a75adb666f1c082be8ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8d726d57b772a75adb666f1c082be8ed">&#9670;&nbsp;</a></span>Cy_HBDma_Channel_Enable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__usbfxstack__hb__dma__enums.html#ga8a1d453b60acfddb9766af3ad7c2ddaa">cy_en_hbdma_mgr_status_t</a> Cy_HBDma_Channel_Enable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__hb__dma__structs.html#structcy__stc__hbdma__channel__t">cy_stc_hbdma_channel_t</a> *&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>xferSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable a High BandWidth DMA channel for data transfer. </p>
<p >Any sockets associated with the DMA channel will be enabled. If a non-zero xferSize is specified, the channel gets disabled automatically after transferring the specified amount of data.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>Handle to the DMA channel structure.</td></tr>
    <tr><td class="paramname">xferSize</td><td>Size of data to be transferred through the channel.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CY_HBDMA_MGR_SUCCESS if the channel enable operation is successful. CY_HBDMA_MGR_BAD_PARAM if the parameters are invalid. </dd></dl>

</div>
</div>
<a id="ga651b4f103e80a7bad7136db793dae675" name="ga651b4f103e80a7bad7136db793dae675"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga651b4f103e80a7bad7136db793dae675">&#9670;&nbsp;</a></span>Cy_HBDma_Channel_Disable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__usbfxstack__hb__dma__enums.html#ga8a1d453b60acfddb9766af3ad7c2ddaa">cy_en_hbdma_mgr_status_t</a> Cy_HBDma_Channel_Disable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__hb__dma__structs.html#structcy__stc__hbdma__channel__t">cy_stc_hbdma_channel_t</a> *&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disable a High BandWidth DMA channel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>Handle to the DMA channel structure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CY_HBDMA_MGR_SUCCESS if the channel disable operation is successful. CY_HBDMA_MGR_BAD_PARAM if the parameters are invalid. </dd></dl>

</div>
</div>
<a id="gac255726795e25981414fda4901d21857" name="gac255726795e25981414fda4901d21857"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac255726795e25981414fda4901d21857">&#9670;&nbsp;</a></span>Cy_HBDma_Channel_Reset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__usbfxstack__hb__dma__enums.html#ga8a1d453b60acfddb9766af3ad7c2ddaa">cy_en_hbdma_mgr_status_t</a> Cy_HBDma_Channel_Reset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__hb__dma__structs.html#structcy__stc__hbdma__channel__t">cy_stc_hbdma_channel_t</a> *&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reset a High BandWidth DMA channel. </p>
<p >This leaves all the DMA buffers associated with the channel in the empty state and the channel itself in the disabled state.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>Handle to the DMA channel structure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CY_HBDMA_MGR_SUCCESS if the channel reset operation is successful. CY_HBDMA_MGR_BAD_PARAM if the parameters are invalid. </dd></dl>

</div>
</div>
<a id="gae37cf3b7af8526e834a0f6a6457090d8" name="gae37cf3b7af8526e834a0f6a6457090d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae37cf3b7af8526e834a0f6a6457090d8">&#9670;&nbsp;</a></span>Cy_HBDma_Channel_SetWrapUp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__usbfxstack__hb__dma__enums.html#ga8a1d453b60acfddb9766af3ad7c2ddaa">cy_en_hbdma_mgr_status_t</a> Cy_HBDma_Channel_SetWrapUp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__hb__dma__structs.html#structcy__stc__hbdma__channel__t">cy_stc_hbdma_channel_t</a> *&#160;</td>
          <td class="paramname"><em>pHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>sckOffset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API is used to forcibly commit a DMA buffer to the consumer, and is useful in the case where data transfer has abruptly stopped without the producer being able to commit the data buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pHandle</td><td>Handle to the DMA channel structure.</td></tr>
    <tr><td class="paramname">sckOffset</td><td>Socket id to wrapup. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CY_HBDMA_MGR_SUCCESS if the channel reset operation is successful. CY_HBDMA_MGR_BAD_PARAM if the parameters are invalid. CY_HBDMA_MGR_SEQUENCE_ERROR if the DMA channel is not in the required state. </dd></dl>

</div>
</div>
<a id="gacdec948100f14eef4ca783584a4afbcc" name="gacdec948100f14eef4ca783584a4afbcc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacdec948100f14eef4ca783584a4afbcc">&#9670;&nbsp;</a></span>Cy_HBDma_Channel_GetBuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__usbfxstack__hb__dma__enums.html#ga8a1d453b60acfddb9766af3ad7c2ddaa">cy_en_hbdma_mgr_status_t</a> Cy_HBDma_Channel_GetBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__hb__dma__structs.html#structcy__stc__hbdma__channel__t">cy_stc_hbdma_channel_t</a> *&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__hb__dma__structs.html#structcy__stc__hbdma__buff__status__t">cy_stc_hbdma_buff_status_t</a> *&#160;</td>
          <td class="paramname"><em>bufStat_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the status of the active DMA buffer associated with the DMA channel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>Handle to the DMA channel structure.</td></tr>
    <tr><td class="paramname">bufStat_p</td><td>Return parameter to pass the buffer status through.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CY_HBDMA_MGR_SUCCESS if the operation is successful. CY_HBDMA_MGR_BAD_PARAM if the parameters are invalid. CY_HBDMA_MGR_SEQUENCE_ERROR if the API is called when the descriptor is not in the expected state. </dd></dl>

</div>
</div>
<a id="gab7e186254f83c498e9ad4de42c61dde0" name="gab7e186254f83c498e9ad4de42c61dde0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab7e186254f83c498e9ad4de42c61dde0">&#9670;&nbsp;</a></span>Cy_HBDma_Channel_CommitBuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__usbfxstack__hb__dma__enums.html#ga8a1d453b60acfddb9766af3ad7c2ddaa">cy_en_hbdma_mgr_status_t</a> Cy_HBDma_Channel_CommitBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__hb__dma__structs.html#structcy__stc__hbdma__channel__t">cy_stc_hbdma_channel_t</a> *&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__hb__dma__structs.html#structcy__stc__hbdma__buff__status__t">cy_stc_hbdma_buff_status_t</a> *&#160;</td>
          <td class="paramname"><em>bufStat_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mark a DMA buffer occupied on the consumer side of the DMA channel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>Handle to the DMA channel structure.</td></tr>
    <tr><td class="paramname">bufStat_p</td><td>Information about the buffer to be committed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CY_HBDMA_MGR_SUCCESS if the commit operation is successful. CY_HBDMA_MGR_BAD_PARAM if the parameters are invalid. </dd></dl>

</div>
</div>
<a id="ga36d9f9a1a77bd366da57f1bcf76e0c32" name="ga36d9f9a1a77bd366da57f1bcf76e0c32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga36d9f9a1a77bd366da57f1bcf76e0c32">&#9670;&nbsp;</a></span>Cy_HBDma_Channel_DiscardBuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__usbfxstack__hb__dma__enums.html#ga8a1d453b60acfddb9766af3ad7c2ddaa">cy_en_hbdma_mgr_status_t</a> Cy_HBDma_Channel_DiscardBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__hb__dma__structs.html#structcy__stc__hbdma__channel__t">cy_stc_hbdma_channel_t</a> *&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__hb__dma__structs.html#structcy__stc__hbdma__buff__status__t">cy_stc_hbdma_buff_status_t</a> *&#160;</td>
          <td class="paramname"><em>bufStat_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mark a DMA buffer empty on the producer side of the DMA channel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>Handle to the DMA channel structure.</td></tr>
    <tr><td class="paramname">bufStat_p</td><td>Information about the buffer to be dropped.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CY_HBDMA_MGR_SUCCESS if the discard operation is successful. CY_HBDMA_MGR_BAD_PARAM if the parameters are invalid. </dd></dl>

</div>
</div>
<a id="ga024377611ec57ace8d8f04222e755bdd" name="ga024377611ec57ace8d8f04222e755bdd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga024377611ec57ace8d8f04222e755bdd">&#9670;&nbsp;</a></span>Cy_HBDma_Channel_SendData()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__usbfxstack__hb__dma__enums.html#ga8a1d453b60acfddb9766af3ad7c2ddaa">cy_en_hbdma_mgr_status_t</a> Cy_HBDma_Channel_SendData </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__hb__dma__structs.html#structcy__stc__hbdma__channel__t">cy_stc_hbdma_channel_t</a> *&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>sckIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>dataBuf_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>dataSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prepares to send data through a DMA channel. </p>
<p >This API should be called when the channel is in the disabled state, and will return after the DMA operation has been queued. The Cy_HBDma_Channel_WaitForSendCplt function can be called to wait until the transfer is completed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>Handle to the DMA channel structure.</td></tr>
    <tr><td class="paramname">sckIdx</td><td>Index of consumer socket through which data is to be sent.</td></tr>
    <tr><td class="paramname">dataBuf_p</td><td>Pointer to the buffer containing data to be sent.</td></tr>
    <tr><td class="paramname">dataSize</td><td>Size of data to be sent.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CY_HBDMA_MGR_SUCCESS if the data to be sent is queued successfully. CY_HBDMA_MGR_BAD_PARAM if the parameters are invalid. CY_HBDMA_MGR_SEQUENCE_ERROR if the channel is not idle. </dd></dl>

</div>
</div>
<a id="ga959f1cb234b881a73a69ddf525b3fe23" name="ga959f1cb234b881a73a69ddf525b3fe23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga959f1cb234b881a73a69ddf525b3fe23">&#9670;&nbsp;</a></span>Cy_HBDma_Channel_WaitForSendCplt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__usbfxstack__hb__dma__enums.html#ga8a1d453b60acfddb9766af3ad7c2ddaa">cy_en_hbdma_mgr_status_t</a> Cy_HBDma_Channel_WaitForSendCplt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__hb__dma__structs.html#structcy__stc__hbdma__channel__t">cy_stc_hbdma_channel_t</a> *&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>sckIdx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Waits until the DMA transfer requested using Cy_HBDma_Channel_SendData API has been completed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>Handle to the DMA channel structure.</td></tr>
    <tr><td class="paramname">sckIdx</td><td>Index of consumer socket through which data is to be sent.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CY_HBDMA_MGR_SUCCESS if the send operation was completed. CY_HBDMA_MGR_BAD_PARAM if the parameters are invalid. CY_HBDMA_MGR_SEQUENCE_ERROR if SendData has not been called previously. CY_HBDMA_MGR_TIMEOUT if the operation times out on the consumer side. </dd></dl>

</div>
</div>
<a id="ga8c11132ed6ff40bd7509be86f65a3365" name="ga8c11132ed6ff40bd7509be86f65a3365"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8c11132ed6ff40bd7509be86f65a3365">&#9670;&nbsp;</a></span>Cy_HBDma_Channel_ReceiveData()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__usbfxstack__hb__dma__enums.html#ga8a1d453b60acfddb9766af3ad7c2ddaa">cy_en_hbdma_mgr_status_t</a> Cy_HBDma_Channel_ReceiveData </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__hb__dma__structs.html#structcy__stc__hbdma__channel__t">cy_stc_hbdma_channel_t</a> *&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>sckIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>dataBuf_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>bufferSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>actualSize_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prepare to receive a specific amount of data using a DMA channel. </p>
<p >This API should be called while the channel is in the disabled state and will return as soon as channel is enabled for data transfer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>Handle to the DMA channel structure.</td></tr>
    <tr><td class="paramname">sckIdx</td><td>Index of the producer socket within the channel through which data will be received.</td></tr>
    <tr><td class="paramname">dataBuf_p</td><td>Pointer of buffer where the received data should be placed.</td></tr>
    <tr><td class="paramname">bufferSize</td><td>Maximum amount of data that may be received.</td></tr>
    <tr><td class="paramname">actualSize_p</td><td>Return parameter to get the actual received data size through (can be NULL).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CY_HBDMA_MGR_SUCCESS if the receive operation is queued successfully. CY_HBDMA_MGR_BAD_PARAM if the parameters are invalid. CY_HBDMA_MGR_SEQUENCE_ERROR if the channel is not idle. </dd></dl>

</div>
</div>
<a id="gab3c7d15c4b19f769cfea45cd4c324163" name="gab3c7d15c4b19f769cfea45cd4c324163"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab3c7d15c4b19f769cfea45cd4c324163">&#9670;&nbsp;</a></span>Cy_HBDma_Channel_WaitForReceiveCplt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__usbfxstack__hb__dma__enums.html#ga8a1d453b60acfddb9766af3ad7c2ddaa">cy_en_hbdma_mgr_status_t</a> Cy_HBDma_Channel_WaitForReceiveCplt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__hb__dma__structs.html#structcy__stc__hbdma__channel__t">cy_stc_hbdma_channel_t</a> *&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>sckIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>actualSize_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wait until a HBW DMA operation initiated using Cy_HBDma_Channel_ReceiveData has been completed. </p>
<p >The actual amount of data read is returned through the actualSize_p parameter.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>Handle to the DMA channel structure.</td></tr>
    <tr><td class="paramname">sckIdx</td><td>Index of the producer socket in the channel to be used for data read.</td></tr>
    <tr><td class="paramname">actualSize_p</td><td>Optional return parameter to get the actual size of data received.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CY_HBDMA_MGR_SUCCESS if the data is received successfully. CY_HBDMA_MGR_BAD_PARAM if the parameters are invalid. CY_HBDMA_MGR_SEQUENCE_ERROR if a previous ReceiveData call is not pending. </dd></dl>

</div>
</div>
<a id="ga56a61ec4d579c09f43a7127961e3c121" name="ga56a61ec4d579c09f43a7127961e3c121"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga56a61ec4d579c09f43a7127961e3c121">&#9670;&nbsp;</a></span>Cy_HBDma_Channel_GetBufferInfo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__usbfxstack__hb__dma__enums.html#ga8a1d453b60acfddb9766af3ad7c2ddaa">cy_en_hbdma_mgr_status_t</a> Cy_HBDma_Channel_GetBufferInfo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__hb__dma__structs.html#structcy__stc__hbdma__channel__t">cy_stc_hbdma_channel_t</a> *&#160;</td>
          <td class="paramname"><em>pHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t **&#160;</td>
          <td class="paramname"><em>pBufPtrs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>bufferCnt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve the set of DMA buffers associated with a HBDma channel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pHandle</td><td>Handle to the DMA channel structure.</td></tr>
    <tr><td class="paramname">pBufPtrs</td><td>Return array to be filled with the DMA buffer pointers.</td></tr>
    <tr><td class="paramname">bufferCnt</td><td>Number of buffer pointers to be fetched.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CY_HBDMA_MGR_SUCCESS if the buffer query is successful. CY_HBDMA_MGR_BAD_PARAM if the parameters are invalid. </dd></dl>

</div>
</div>
<a id="ga41d83f4793be18a2879f9a4d05454e98" name="ga41d83f4793be18a2879f9a4d05454e98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga41d83f4793be18a2879f9a4d05454e98">&#9670;&nbsp;</a></span>Cy_HBDma_Channel_AutoDropData()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__usbfxstack__hb__dma__enums.html#ga8a1d453b60acfddb9766af3ad7c2ddaa">cy_en_hbdma_mgr_status_t</a> Cy_HBDma_Channel_AutoDropData </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__hb__dma__structs.html#structcy__stc__hbdma__channel__t">cy_stc_hbdma_channel_t</a> *&#160;</td>
          <td class="paramname"><em>pHandle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function allows an active Auto DMA channel to be configured to drop all data that is being received on the producer side. </p>
<p >The channel has to be reset and then enabled to restore normal operation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pHandle</td><td>Handle to the DMA channel structure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CY_HBDMA_MGR_SUCCESS if the channel has been set up to drop the incoming data. CY_HBDMA_MGR_BAD_PARAM if the channel is not valid or not an AUTO channel. CY_HBDMA_MGR_SEQUENCE_ERROR if the channel is not active. </dd></dl>

</div>
</div>
<a id="ga2e16f6d9d7ae6fd777e8b72ade3f50cd" name="ga2e16f6d9d7ae6fd777e8b72ade3f50cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2e16f6d9d7ae6fd777e8b72ade3f50cd">&#9670;&nbsp;</a></span>Cy_HBDma_Channel_Cb()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Cy_HBDma_Channel_Cb </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__hb__dma__enums.html#gab83411cd9077b5c27dda0bad41d89a06">cy_hbdma_socket_id_t</a>&#160;</td>
          <td class="paramname"><em>socketId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__hb__dma__enums.html#ga9fa6002eb355bdec4f739851bac4590a">cy_en_hbdma_sock_evt_t</a>&#160;</td>
          <td class="paramname"><em>intrType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>curDscr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>userCtx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>High BandWidth DMA channel callback function implementation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">socketId</td><td>Socket on which interrupt was received.</td></tr>
    <tr><td class="paramname">intrType</td><td>Type of interrupt which was received.</td></tr>
    <tr><td class="paramname">curDscr</td><td>Active descriptor for the socket.</td></tr>
    <tr><td class="paramname">userCtx</td><td>User context for the callback.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if further interrupt processing is to be disabled. </dd></dl>

</div>
</div>
<a id="gaf0c60cfe5c5ca8ceedf96d38d2ff258d" name="gaf0c60cfe5c5ca8ceedf96d38d2ff258d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf0c60cfe5c5ca8ceedf96d38d2ff258d">&#9670;&nbsp;</a></span>Cy_HBDma_Mgr_TaskHandler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cy_HBDma_Mgr_TaskHandler </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pTaskParam</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>High BandWidth DMA manager task. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pTaskParam</td><td>Pointer to the HBDma manager context structure. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gab693e55b497981a5cefa84973457088d" name="gab693e55b497981a5cefa84973457088d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab693e55b497981a5cefa84973457088d">&#9670;&nbsp;</a></span>Cy_HBDma_Mgr_RegisterISRCtrlCallback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cy_HBDma_Mgr_RegisterISRCtrlCallback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__hb__dma__structs.html#structcy__stc__hbdma__mgr__context__t">cy_stc_hbdma_mgr_context_t</a> *&#160;</td>
          <td class="paramname"><em>pDmaMgr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__hb__dma__typedefs.html#gaf82cec3d6d5f7b17e52508a08794b34f">cy_cb_hbdma_mgr_intr_ctrl_cb_t</a>&#160;</td>
          <td class="paramname"><em>cb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register a function callback that the DMA manager can call to dynamically enable or disable the HBDMA interrupts based on the state of the interrupt notification message queue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pDmaMgr</td><td>Pointer to the DMA manager context structure.</td></tr>
    <tr><td class="paramname">cb</td><td>Pointer to function callback. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga6999b46a26a52114850ff548a989506b" name="ga6999b46a26a52114850ff548a989506b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6999b46a26a52114850ff548a989506b">&#9670;&nbsp;</a></span>Cy_HBDma_Channel_GetChannelState()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__usbfxstack__hb__dma__enums.html#ga5e9d5386a585e87f3d3a0991ff321c7f">cy_en_hbdma_chn_state_t</a> Cy_HBDma_Channel_GetChannelState </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__hb__dma__structs.html#structcy__stc__hbdma__channel__t">cy_stc_hbdma_channel_t</a> *&#160;</td>
          <td class="paramname"><em>pHandle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve the state of DMA channel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pHandle</td><td>Handle to the DMA channel structure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>channel state. </dd></dl>

</div>
</div>
<a id="gaa54235631fbe7834dc902810a619a292" name="gaa54235631fbe7834dc902810a619a292"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa54235631fbe7834dc902810a619a292">&#9670;&nbsp;</a></span>Cy_HBDma_Mgr_DmaCallbackConfigure()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cy_HBDma_Mgr_DmaCallbackConfigure </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__hb__dma__structs.html#structcy__stc__hbdma__mgr__context__t">cy_stc_hbdma_mgr_context_t</a> *&#160;</td>
          <td class="paramname"><em>pDmaMgr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>callbackFromISREnable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to configure context from which DMA callback functions are generated. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pDmaMgr</td><td>Pointer to DMA manager context structure.</td></tr>
    <tr><td class="paramname">callbackFromISREnable</td><td>Whether sending of DMA callbacks directly from ISR is enabled. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga580bac11a3a9eb4d2580d3c242fcf497" name="ga580bac11a3a9eb4d2580d3c242fcf497"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga580bac11a3a9eb4d2580d3c242fcf497">&#9670;&nbsp;</a></span>Cy_HBDma_Mgr_GetIntrDropCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t Cy_HBDma_Mgr_GetIntrDropCount </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__hb__dma__structs.html#structcy__stc__hbdma__mgr__context__t">cy_stc_hbdma_mgr_context_t</a> *&#160;</td>
          <td class="paramname"><em>pDmaMgr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to get count of DMA interrupt messages dropped due to message queue overflow. </p>
<p >If the count is non-zero at any stage, it indicates that DMA interrupts are being generated too fast for the CPU to handle. Either larger DMA buffers should be used to reduce interrupt frequency or the <a class="el" href="group__group__usbfxstack__hb__dma__functions.html#gab693e55b497981a5cefa84973457088d" title="Register a function callback that the DMA manager can call to dynamically enable or disable the HBDMA...">Cy_HBDma_Mgr_RegisterISRCtrlCallback()</a> API should be used to dynamically throttle DMA interrupts.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pDmaMgr</td><td>Pointer to DMA manager context structure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Count of DMA interrupt messages which have been dropped so far. </dd></dl>

</div>
</div>
<a id="gacc1cb4929f6b9a4002de6498e31ef1ca" name="gacc1cb4929f6b9a4002de6498e31ef1ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacc1cb4929f6b9a4002de6498e31ef1ca">&#9670;&nbsp;</a></span>Cy_HBDma_Mgr_SetUsbEgressAdapterDelay()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cy_HBDma_Mgr_SetUsbEgressAdapterDelay </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__hb__dma__structs.html#structcy__stc__hbdma__mgr__context__t">cy_stc_hbdma_mgr_context_t</a> *&#160;</td>
          <td class="paramname"><em>pDmaMgr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>gblDelayCycles</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Update the number of cycles of delay to be applied between consecutive AXI data fetches made by the USB egress DMA adapter. </p>
<p >The function is meant to be used by the USB stack based on current USB speed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pDmaMgr</td><td>Pointer to DMA manager context structure.</td></tr>
    <tr><td class="paramname">gblDelayCycles</td><td>Number of delay cycles to be applied in the range of 0 to 15. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gadf9f54714f6cd6888ca8947d9968ee33" name="gadf9f54714f6cd6888ca8947d9968ee33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadf9f54714f6cd6888ca8947d9968ee33">&#9670;&nbsp;</a></span>Cy_HBDma_Mgr_SetLvdsAdapterIngressMode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cy_HBDma_Mgr_SetLvdsAdapterIngressMode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__hb__dma__structs.html#structcy__stc__hbdma__mgr__context__t">cy_stc_hbdma_mgr_context_t</a> *&#160;</td>
          <td class="paramname"><em>pDmaMgr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isAdap0Ingress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isAdap1Ingress</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function enables or disables the support for egress data transfers from RAM buffers which are not 16-byte aligned based on whether the specified LVDS DMA adapters are working in Ingress only mode or not. </p>
<p >For any ingress-only adapter, this support can be disabled to gain better DMA performance.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pDmaMgr</td><td>Pointer to DMA manager context structure.</td></tr>
    <tr><td class="paramname">isAdap0Ingress</td><td>Whether adapter 0 (sockets 0 to 15) is being used only in ingress direction.</td></tr>
    <tr><td class="paramname">isAdap1Ingress</td><td>Whether adapter 1 (sockets 16 to 31) is being used only in ingress direction. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaae9cb0b7fcd758e64980ddfe4a784cdf" name="gaae9cb0b7fcd758e64980ddfe4a784cdf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaae9cb0b7fcd758e64980ddfe4a784cdf">&#9670;&nbsp;</a></span>Cy_HBDma_DW_Configure()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__usbfxstack__hb__dma__enums.html#ga8a1d453b60acfddb9766af3ad7c2ddaa">cy_en_hbdma_mgr_status_t</a> Cy_HBDma_DW_Configure </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__hb__dma__structs.html#structcy__stc__hbdma__channel__t">cy_stc_hbdma_channel_t</a> *&#160;</td>
          <td class="paramname"><em>pHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configure the trigger connections for the DataWire used for transfers through a USB High-Speed Endpoint. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pHandle</td><td>Handle to the DMA channel. </td></tr>
    <tr><td class="paramname">enable</td><td>Whether trigger connections are to be enabled or disabled.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CY_HBDMA_MGR_SUCCESS if function is successful, error code otherwise. </dd></dl>

</div>
</div>
<a id="ga66412f84c789f6489d484b78b86be607" name="ga66412f84c789f6489d484b78b86be607"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga66412f84c789f6489d484b78b86be607">&#9670;&nbsp;</a></span>Cy_HBDma_DW_QueueRead()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__usbfxstack__hb__dma__enums.html#ga8a1d453b60acfddb9766af3ad7c2ddaa">cy_en_hbdma_mgr_status_t</a> Cy_HBDma_DW_QueueRead </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__hb__dma__structs.html#structcy__stc__hbdma__channel__t">cy_stc_hbdma_channel_t</a> *&#160;</td>
          <td class="paramname"><em>pHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>prodIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>pBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>dataSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function which queues read operation using DataWire DMA on USBHS OUT endpoint corresponding to a DMA channel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pHandle</td><td>Handle to the DMA channel. </td></tr>
    <tr><td class="paramname">prodIndex</td><td>Index of the producer from which to read data. </td></tr>
    <tr><td class="paramname">pBuffer</td><td>Pointer to the data buffer to read data into. </td></tr>
    <tr><td class="paramname">dataSize</td><td>Size of data expected. This should be a multiple of the max packet size.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CY_HBDMA_MGR_SUCCESS if function is successful, error code otherwise. </dd></dl>

</div>
</div>
<a id="gad56befbc8bbb358ad4c43f8d0978f91d" name="gad56befbc8bbb358ad4c43f8d0978f91d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad56befbc8bbb358ad4c43f8d0978f91d">&#9670;&nbsp;</a></span>Cy_HBDma_DW_CompleteShortRead()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__usbfxstack__hb__dma__enums.html#ga8a1d453b60acfddb9766af3ad7c2ddaa">cy_en_hbdma_mgr_status_t</a> Cy_HBDma_DW_CompleteShortRead </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__hb__dma__structs.html#structcy__stc__hbdma__channel__t">cy_stc_hbdma_channel_t</a> *&#160;</td>
          <td class="paramname"><em>pHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>prodIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>shortPktSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function which terminates ongoing USBHS ingress transfer when a short packet has been received on the endpoint. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pHandle</td><td>Handle to the DMA channel. </td></tr>
    <tr><td class="paramname">prodIndex</td><td>Index of the producer from which to read data. </td></tr>
    <tr><td class="paramname">shortPktSize</td><td>Size of the short packet received in bytes.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CY_HBDMA_MGR_SUCCESS if function is successful, error code otherwise. </dd></dl>

</div>
</div>
<a id="gad15112511c48efacc81b3655efb173a7" name="gad15112511c48efacc81b3655efb173a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad15112511c48efacc81b3655efb173a7">&#9670;&nbsp;</a></span>Cy_HBDma_DW_QueueWrite()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__usbfxstack__hb__dma__enums.html#ga8a1d453b60acfddb9766af3ad7c2ddaa">cy_en_hbdma_mgr_status_t</a> Cy_HBDma_DW_QueueWrite </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__hb__dma__structs.html#structcy__stc__hbdma__channel__t">cy_stc_hbdma_channel_t</a> *&#160;</td>
          <td class="paramname"><em>pHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>consIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>pBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>dataSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function which queues write operation using DataWire DMA on USBHS IN endpoint corresponding to a DMA channel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pHandle</td><td>Handle to the DMA channel. </td></tr>
    <tr><td class="paramname">consIndex</td><td>Index of the consumer to write data into. </td></tr>
    <tr><td class="paramname">pBuffer</td><td>Pointer to the data buffer containing the data. </td></tr>
    <tr><td class="paramname">dataSize</td><td>Size of data to be transferred.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CY_HBDMA_MGR_SUCCESS if function is successful, error code otherwise. </dd></dl>

</div>
</div>
<a id="ga239ee6292b479e83cb5645c837d9b75d" name="ga239ee6292b479e83cb5645c837d9b75d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga239ee6292b479e83cb5645c837d9b75d">&#9670;&nbsp;</a></span>Cy_HBDma_Mgr_HandleDW0Interrupt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cy_HBDma_Mgr_HandleDW0Interrupt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__hb__dma__structs.html#structcy__stc__hbdma__mgr__context__t">cy_stc_hbdma_mgr_context_t</a> *&#160;</td>
          <td class="paramname"><em>pDmaMgr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>DMA manager function that handles transfer completion interrupt from any of the DataWire channels associated with non EP0 USB-HS OUT endpoints (channels 1 to 15). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pDmaMgr</td><td>Handle to the DMA manager context. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga6a3d090dba3c10f62e5268af3337bdbf" name="ga6a3d090dba3c10f62e5268af3337bdbf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6a3d090dba3c10f62e5268af3337bdbf">&#9670;&nbsp;</a></span>Cy_HBDma_Mgr_HandleDW1Interrupt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cy_HBDma_Mgr_HandleDW1Interrupt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__hb__dma__structs.html#structcy__stc__hbdma__mgr__context__t">cy_stc_hbdma_mgr_context_t</a> *&#160;</td>
          <td class="paramname"><em>pDmaMgr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>DMA manager function that handles transfer completion interrupt from any of the DataWire channels associated with non EP0 USB-HS IN endpoints (channels 1 to 15). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pDmaMgr</td><td>Handle to the DMA manager context. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gafc5003e1a752a17ac8e38636b36cec9d" name="gafc5003e1a752a17ac8e38636b36cec9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafc5003e1a752a17ac8e38636b36cec9d">&#9670;&nbsp;</a></span>Cy_HBDma_Mgr_HandleUsbShortInterrupt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cy_HBDma_Mgr_HandleUsbShortInterrupt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__usbfxstack__hb__dma__structs.html#structcy__stc__hbdma__mgr__context__t">cy_stc_hbdma_mgr_context_t</a> *&#160;</td>
          <td class="paramname"><em>pDmaMgr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>epNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>pktSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>DMA manager function that handles SLP or ZLP interrupts from USB-HS OUT endpoints. </p>
<p >This is expected to be triggered from interrupt callback provided by the USB stack.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pDmaMgr</td><td>Handle to the DMA manager context. </td></tr>
    <tr><td class="paramname">epNum</td><td>Endpoint number on which SLP/ZLP was received. </td></tr>
    <tr><td class="paramname">pktSize</td><td>Actual size (in bytes) of the packet received. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part
<div id="nav-path" class="navpath">
    <ul>
        <li class="footer">
            Generated for <b>ModusToolbox USBFXStack</b> by <b>Cypress Semiconductor Corporation</b>.
            All rights reserved.
        </li>
    </ul>
</div>
-->
</body>
</html>
